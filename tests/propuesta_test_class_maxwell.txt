"""
Suite de pruebas exhaustivas para DiscreteVectorCalculus, MaxwellFDTDSolver
y PortHamiltonianController.

Ejecutar con: pytest -v test_discrete_calculus.py
O con cobertura: pytest --cov=. --cov-report=html test_discrete_calculus.py

Autor: Artesano Programador Senior
"""

import pytest
import numpy as np
import networkx as nx
from scipy import sparse
from scipy.sparse.linalg import eigsh, norm as sparse_norm
from typing import Dict, Set, Tuple, List
import warnings

# Importar las clases a probar (ajustar según estructura del proyecto)
from discrete_calculus import (
    DiscreteVectorCalculus,
    MaxwellFDTDSolver,
    PortHamiltonianController
)


# =============================================================================
# FIXTURES: Grafos y configuraciones de prueba
# =============================================================================

@pytest.fixture
def single_triangle() -> Dict[int, Set[int]]:
    """Grafo más simple con un 2-símplice: un triángulo."""
    return {
        0: {1, 2},
        1: {0, 2},
        2: {0, 1}
    }


@pytest.fixture
def tetrahedron() -> Dict[int, Set[int]]:
    """Tetraedro: 4 nodos, 6 aristas, 4 triángulos."""
    return {
        0: {1, 2, 3},
        1: {0, 2, 3},
        2: {0, 1, 3},
        3: {0, 1, 2}
    }


@pytest.fixture
def square_graph() -> Dict[int, Set[int]]:
    """Cuadrado: 4 nodos, 4 aristas, sin triángulos."""
    return {
        0: {1, 3},
        1: {0, 2},
        2: {1, 3},
        3: {0, 2}
    }


@pytest.fixture
def square_with_diagonal() -> Dict[int, Set[int]]:
    """Cuadrado con diagonal: 4 nodos, 5 aristas, 2 triángulos."""
    return {
        0: {1, 2, 3},
        1: {0, 2},
        2: {0, 1, 3},
        3: {0, 2}
    }


@pytest.fixture
def path_graph() -> Dict[int, Set[int]]:
    """Camino lineal: sin ciclos ni triángulos."""
    return {
        0: {1},
        1: {0, 2},
        2: {1, 3},
        3: {2}
    }


@pytest.fixture
def star_graph() -> Dict[int, Set[int]]:
    """Estrella: nodo central conectado a 4 hojas."""
    return {
        0: {1, 2, 3, 4},
        1: {0},
        2: {0},
        3: {0},
        4: {0}
    }


@pytest.fixture
def disconnected_graph() -> Dict[int, Set[int]]:
    """Grafo con dos componentes conexas."""
    return {
        0: {1},
        1: {0},
        2: {3},
        3: {2}
    }


@pytest.fixture
def single_node() -> Dict[int, Set[int]]:
    """Grafo trivial con un solo nodo."""
    return {0: set()}


@pytest.fixture
def two_triangles_shared_edge() -> Dict[int, Set[int]]:
    """Dos triángulos compartiendo una arista (mariposa)."""
    return {
        0: {1, 2},
        1: {0, 2, 3},
        2: {0, 1, 3},
        3: {1, 2}
    }


@pytest.fixture
def octahedron() -> Dict[int, Set[int]]:
    """Octaedro: superficie cerrada con 6 vértices, 12 aristas, 8 caras."""
    return {
        0: {1, 2, 3, 4},  # polo norte
        1: {0, 2, 4, 5},  # ecuador
        2: {0, 1, 3, 5},  # ecuador
        3: {0, 2, 4, 5},  # ecuador
        4: {0, 1, 3, 5},  # ecuador
        5: {1, 2, 3, 4}   # polo sur
    }


@pytest.fixture
def grid_2x2() -> Dict[int, Set[int]]:
    """Malla 2x2 triangulada."""
    # Nodos: 0-1-2
    #        3-4-5
    #        6-7-8
    adj = {i: set() for i in range(9)}
    # Conexiones horizontales
    for row in range(3):
        for col in range(2):
            i, j = row * 3 + col, row * 3 + col + 1
            adj[i].add(j)
            adj[j].add(i)
    # Conexiones verticales
    for row in range(2):
        for col in range(3):
            i, j = row * 3 + col, (row + 1) * 3 + col
            adj[i].add(j)
            adj[j].add(i)
    # Diagonales para triangulación
    for row in range(2):
        for col in range(2):
            i = row * 3 + col
            j = (row + 1) * 3 + col + 1
            adj[i].add(j)
            adj[j].add(i)
    return adj


# =============================================================================
# TESTS: DiscreteVectorCalculus - Construcción y Estructura
# =============================================================================

class TestDiscreteVectorCalculusConstruction:
    """Tests para la construcción correcta del complejo simplicial."""
    
    def test_empty_graph_raises_error(self):
        """Grafo vacío debe lanzar error."""
        with pytest.raises(ValueError, match="no puede estar vacío"):
            DiscreteVectorCalculus({})
    
    def test_single_node_construction(self, single_node):
        """Grafo de un nodo debe construirse con advertencia."""
        with pytest.warns(UserWarning, match="trivial"):
            calc = DiscreteVectorCalculus(single_node)
        
        assert calc.num_nodes == 1
        assert calc.num_edges == 0
        assert calc.num_faces == 0
    
    def test_triangle_construction(self, single_triangle):
        """Triángulo debe tener exactamente 1 cara."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        assert calc.num_nodes == 3
        assert calc.num_edges == 3
        assert calc.num_faces == 1
        assert calc.is_connected
    
    def test_tetrahedron_construction(self, tetrahedron):
        """Tetraedro debe tener 4 caras."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        assert calc.num_nodes == 4
        assert calc.num_edges == 6
        assert calc.num_faces == 4
    
    def test_square_no_faces(self, square_graph):
        """Cuadrado sin diagonal no tiene triángulos."""
        calc = DiscreteVectorCalculus(square_graph)
        
        assert calc.num_nodes == 4
        assert calc.num_edges == 4
        assert calc.num_faces == 0
    
    def test_disconnected_graph_warning(self, disconnected_graph):
        """Grafo desconectado debe emitir advertencia."""
        with pytest.warns(UserWarning, match="componentes conexas"):
            calc = DiscreteVectorCalculus(disconnected_graph)
        
        assert calc.num_components == 2
        assert not calc.is_connected
    
    def test_edge_orientation_consistency(self, single_triangle):
        """La orientación de aristas debe ser consistente."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        for (u, v) in calc.edges:
            assert u < v, "Aristas deben estar orientadas menor → mayor"
            assert calc.edge_orientation[(u, v)] == 1
            assert calc.edge_orientation[(v, u)] == -1
    
    def test_node_mapping_bijection(self, tetrahedron):
        """El mapeo de nodos debe ser biyectivo."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        # Verificar que node_to_idx es biyección
        assert len(calc.node_to_idx) == calc.num_nodes
        indices = list(calc.node_to_idx.values())
        assert sorted(indices) == list(range(calc.num_nodes))
    
    def test_edge_face_adjacency(self, two_triangles_shared_edge):
        """Adyacencia arista-cara debe estar precalculada correctamente."""
        calc = DiscreteVectorCalculus(two_triangles_shared_edge)
        
        # La arista compartida debe tener 2 caras adyacentes
        shared_edge_faces = 0
        for edge_idx, adjacent in calc.edge_to_faces.items():
            if len(adjacent) == 2:
                shared_edge_faces += 1
        
        assert shared_edge_faces >= 1, "Debe haber al menos una arista compartida"


# =============================================================================
# TESTS: DiscreteVectorCalculus - Invariantes Topológicos
# =============================================================================

class TestTopologicalInvariants:
    """Tests para invariantes topológicos y fórmula de Euler."""
    
    def test_euler_characteristic_triangle(self, single_triangle):
        """χ = V - E + F = 3 - 3 + 1 = 1 para triángulo."""
        calc = DiscreteVectorCalculus(single_triangle)
        assert calc.euler_characteristic == 1
    
    def test_euler_characteristic_tetrahedron(self, tetrahedron):
        """χ = 4 - 6 + 4 = 2 para superficie de tetraedro."""
        calc = DiscreteVectorCalculus(tetrahedron)
        assert calc.euler_characteristic == 2
    
    def test_euler_characteristic_path(self, path_graph):
        """χ = 4 - 3 + 0 = 1 para camino (árbol)."""
        calc = DiscreteVectorCalculus(path_graph)
        assert calc.euler_characteristic == 1
    
    def test_betti_0_connected(self, single_triangle):
        """β₀ = 1 para grafo conexo."""
        calc = DiscreteVectorCalculus(single_triangle)
        assert calc.betti_0 == 1
    
    def test_betti_0_disconnected(self, disconnected_graph):
        """β₀ = número de componentes conexas."""
        with pytest.warns(UserWarning):
            calc = DiscreteVectorCalculus(disconnected_graph)
        assert calc.betti_0 == 2
    
    def test_betti_1_cycle(self, square_graph):
        """β₁ = 1 para cuadrado (un ciclo independiente)."""
        calc = DiscreteVectorCalculus(square_graph)
        # β₁ = β₀ + β₂ - χ = 1 + 0 - 0 = 1
        assert calc.betti_1 == 1
    
    def test_betti_1_tree(self, path_graph):
        """β₁ = 0 para árbol (sin ciclos)."""
        calc = DiscreteVectorCalculus(path_graph)
        assert calc.betti_1 == 0


# =============================================================================
# TESTS: DiscreteVectorCalculus - Operadores Frontera
# =============================================================================

class TestBoundaryOperators:
    """Tests para operadores frontera ∂₁ y ∂₂."""
    
    def test_boundary1_shape(self, tetrahedron):
        """∂₁ debe tener shape (num_nodes, num_edges)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        assert calc.boundary1.shape == (calc.num_nodes, calc.num_edges)
    
    def test_boundary2_shape(self, tetrahedron):
        """∂₂ debe tener shape (num_edges, num_faces)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        assert calc.boundary2.shape == (calc.num_edges, calc.num_faces)
    
    def test_boundary1_column_sum_zero(self, single_triangle):
        """Cada columna de ∂₁ debe sumar 0 (∂₁[e] = v₂ - v₁)."""
        calc = DiscreteVectorCalculus(single_triangle)
        col_sums = np.array(calc.boundary1.sum(axis=0)).flatten()
        np.testing.assert_allclose(col_sums, 0, atol=1e-14)
    
    def test_boundary1_entries(self, single_triangle):
        """Cada columna de ∂₁ debe tener exactamente un +1 y un -1."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        for col in range(calc.num_edges):
            column = calc.boundary1.getcol(col).toarray().flatten()
            assert np.sum(column == 1) == 1
            assert np.sum(column == -1) == 1
            assert np.sum(column == 0) == calc.num_nodes - 2
    
    def test_boundary2_column_sum_zero(self, single_triangle):
        """Cada columna de ∂₂ debe sumar 0 (∂[σ] es ciclo cerrado)."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        if calc.num_faces > 0:
            col_sums = np.array(calc.boundary2.sum(axis=0)).flatten()
            np.testing.assert_allclose(col_sums, 0, atol=1e-14)
    
    def test_boundary_composition_zero(self, tetrahedron):
        """∂₁ ∘ ∂₂ = 0 (propiedad fundamental de complejos de cadenas)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        composition = calc.boundary1 @ calc.boundary2
        
        if composition.nnz > 0:
            max_error = np.max(np.abs(composition.data))
        else:
            max_error = 0.0
        
        assert max_error < 1e-12, f"∂₁∂₂ ≠ 0, error máximo: {max_error}"
    
    @pytest.mark.parametrize("graph_fixture", [
        "single_triangle", "tetrahedron", "two_triangles_shared_edge",
        "square_with_diagonal", "grid_2x2"
    ])
    def test_boundary_composition_zero_parametrized(self, graph_fixture, request):
        """Verificar ∂₁∂₂ = 0 en múltiples grafos."""
        adj = request.getfixturevalue(graph_fixture)
        calc = DiscreteVectorCalculus(adj)
        
        result = calc.verify_complex_exactness()
        assert result["∂₁∂₂_is_zero"], f"∂₁∂₂ ≠ 0 en {graph_fixture}"


# =============================================================================
# TESTS: DiscreteVectorCalculus - Operadores de Cálculo Vectorial
# =============================================================================

class TestCalculusOperators:
    """Tests para gradiente, divergencia, curl y codiferenciales."""
    
    def test_gradient_shape(self, single_triangle):
        """Gradiente debe mapear 0-formas a 1-formas."""
        calc = DiscreteVectorCalculus(single_triangle)
        φ = np.array([1.0, 2.0, 3.0])
        
        grad_φ = calc.gradient(φ)
        
        assert grad_φ.shape == (calc.num_edges,)
    
    def test_gradient_of_constant(self, tetrahedron):
        """Gradiente de función constante es cero."""
        calc = DiscreteVectorCalculus(tetrahedron)
        φ = np.ones(calc.num_nodes) * 5.0
        
        grad_φ = calc.gradient(φ)
        
        np.testing.assert_allclose(grad_φ, 0, atol=1e-14)
    
    def test_gradient_wrong_size_raises(self, single_triangle):
        """Gradiente con tamaño incorrecto debe lanzar error."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        with pytest.raises(ValueError, match="Esperado tamaño"):
            calc.gradient(np.array([1.0, 2.0]))  # Tamaño incorrecto
    
    def test_divergence_shape(self, single_triangle):
        """Divergencia debe mapear 1-formas a 0-formas."""
        calc = DiscreteVectorCalculus(single_triangle)
        v = np.array([1.0, 2.0, 3.0])
        
        div_v = calc.divergence(v)
        
        assert div_v.shape == (calc.num_nodes,)
    
    def test_divergence_sum_zero(self, single_triangle):
        """Suma de divergencia debe ser cero (sin fuentes/sumideros netos)."""
        calc = DiscreteVectorCalculus(single_triangle)
        v = np.random.randn(calc.num_edges)
        
        div_v = calc.divergence(v)
        
        # Para operador con Hodge: puede no ser exactamente 0
        # pero para ∂₁v simple, sí
        raw_div = calc.boundary1 @ v
        np.testing.assert_allclose(np.sum(raw_div), 0, atol=1e-14)
    
    def test_curl_shape(self, single_triangle):
        """Curl debe mapear 1-formas a 2-formas."""
        calc = DiscreteVectorCalculus(single_triangle)
        v = np.array([1.0, 2.0, 3.0])
        
        curl_v = calc.curl(v)
        
        assert curl_v.shape == (calc.num_faces,)
    
    def test_curl_empty_when_no_faces(self, path_graph):
        """Curl debe retornar array vacío si no hay caras."""
        calc = DiscreteVectorCalculus(path_graph)
        v = np.random.randn(calc.num_edges)
        
        curl_v = calc.curl(v)
        
        assert curl_v.size == 0
    
    def test_curl_of_gradient_zero(self, tetrahedron):
        """∇ × ∇φ = 0 (identidad vectorial fundamental)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        φ = np.random.randn(calc.num_nodes)
        
        grad_φ = calc.gradient(φ)
        curl_grad_φ = calc.curl(grad_φ)
        
        np.testing.assert_allclose(
            curl_grad_φ, 0, atol=1e-12,
            err_msg="curl(grad(φ)) ≠ 0"
        )
    
    @pytest.mark.parametrize("graph_fixture", [
        "single_triangle", "tetrahedron", "two_triangles_shared_edge",
        "square_with_diagonal", "grid_2x2", "octahedron"
    ])
    def test_curl_grad_zero_parametrized(self, graph_fixture, request):
        """Verificar curl(grad(φ)) = 0 en múltiples grafos."""
        adj = request.getfixturevalue(graph_fixture)
        calc = DiscreteVectorCalculus(adj)
        
        if calc.num_faces == 0:
            pytest.skip("Sin caras, curl no aplica")
        
        φ = np.random.randn(calc.num_nodes)
        curl_grad = calc.curl(calc.gradient(φ))
        
        norm_φ = np.linalg.norm(φ)
        np.testing.assert_allclose(
            curl_grad, 0, atol=1e-12 * norm_φ,
            err_msg=f"curl(grad) ≠ 0 en {graph_fixture}"
        )
    
    def test_codifferential_degree_1(self, single_triangle):
        """Codiferencial de grado 1 (divergencia L²)."""
        calc = DiscreteVectorCalculus(single_triangle)
        v = np.random.randn(calc.num_edges)
        
        δv = calc.codifferential(v, degree=1)
        
        assert δv.shape == (calc.num_nodes,)
    
    def test_codifferential_degree_2(self, single_triangle):
        """Codiferencial de grado 2 (co-curl)."""
        calc = DiscreteVectorCalculus(single_triangle)
        ω = np.random.randn(calc.num_faces)
        
        δω = calc.codifferential(ω, degree=2)
        
        assert δω.shape == (calc.num_edges,)
    
    def test_codifferential_invalid_degree(self, single_triangle):
        """Codiferencial con grado inválido debe lanzar error."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        with pytest.raises(ValueError, match="Grado debe ser"):
            calc.codifferential(np.array([1.0]), degree=0)


# =============================================================================
# TESTS: DiscreteVectorCalculus - Laplacianos de Hodge
# =============================================================================

class TestHodgeLaplacians:
    """Tests para Laplacianos de Hodge Δ₀ y Δ₁."""
    
    def test_laplacian_0_shape(self, tetrahedron):
        """Δ₀ debe ser matriz (num_nodes × num_nodes)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        Δ0 = calc.laplacian(0)
        
        assert Δ0.shape == (calc.num_nodes, calc.num_nodes)
    
    def test_laplacian_1_shape(self, tetrahedron):
        """Δ₁ debe ser matriz (num_edges × num_edges)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        Δ1 = calc.laplacian(1)
        
        assert Δ1.shape == (calc.num_edges, calc.num_edges)
    
    def test_laplacian_0_symmetric(self, tetrahedron):
        """Δ₀ debe ser simétrica."""
        calc = DiscreteVectorCalculus(tetrahedron)
        Δ0 = calc.laplacian(0)
        
        diff = Δ0 - Δ0.T
        assert sparse_norm(diff) < 1e-12
    
    def test_laplacian_1_symmetric(self, tetrahedron):
        """Δ₁ debe ser simétrica."""
        calc = DiscreteVectorCalculus(tetrahedron)
        Δ1 = calc.laplacian(1)
        
        diff = Δ1 - Δ1.T
        assert sparse_norm(diff) < 1e-12
    
    def test_laplacian_0_positive_semidefinite(self, tetrahedron):
        """Δ₀ debe ser semidefinida positiva."""
        calc = DiscreteVectorCalculus(tetrahedron)
        Δ0 = calc.laplacian(0).toarray()
        
        eigenvalues = np.linalg.eigvalsh(Δ0)
        assert np.all(eigenvalues >= -1e-10), "Δ₀ tiene autovalores negativos"
    
    def test_laplacian_0_kernel_dimension(self, single_triangle):
        """dim(ker Δ₀) = β₀ = componentes conexas."""
        calc = DiscreteVectorCalculus(single_triangle)
        Δ0 = calc.laplacian(0).toarray()
        
        eigenvalues = np.linalg.eigvalsh(Δ0)
        num_zero_eigenvalues = np.sum(np.abs(eigenvalues) < 1e-10)
        
        assert num_zero_eigenvalues == calc.betti_0
    
    def test_laplacian_0_kernel_are_constants(self, single_triangle):
        """El núcleo de Δ₀ en grafo conexo son las funciones constantes."""
        calc = DiscreteVectorCalculus(single_triangle)
        Δ0 = calc.laplacian(0)
        
        constant = np.ones(calc.num_nodes)
        Δ0_const = Δ0 @ constant
        
        np.testing.assert_allclose(Δ0_const, 0, atol=1e-12)
    
    def test_laplacian_invalid_degree(self, single_triangle):
        """Laplaciano con grado inválido debe lanzar error."""
        calc = DiscreteVectorCalculus(single_triangle)
        
        with pytest.raises(ValueError, match="Grado debe ser"):
            calc.laplacian(2)
    
    def test_laplacian_caching(self, tetrahedron):
        """Laplaciano debe estar cacheado."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        Δ0_first = calc.laplacian(0)
        Δ0_second = calc.laplacian(0)
        
        assert Δ0_first is Δ0_second, "Laplaciano no está cacheado"


# =============================================================================
# TESTS: DiscreteVectorCalculus - Descomposición de Hodge
# =============================================================================

class TestHodgeDecomposition:
    """Tests para la descomposición de Hodge de 1-formas."""
    
    def test_hodge_decomposition_reconstruction(self, tetrahedron):
        """ω = dα + δβ + γ debe reconstruir ω."""
        calc = DiscreteVectorCalculus(tetrahedron)
        ω = np.random.randn(calc.num_edges)
        
        result = calc.hodge_decomposition(ω)
        
        reconstructed = result["exact"] + result["coexact"] + result["harmonic"]
        np.testing.assert_allclose(
            ω, reconstructed, atol=1e-8,
            err_msg="Descomposición de Hodge no reconstruye ω"
        )
    
    def test_hodge_exact_component_is_gradient(self, tetrahedron):
        """Componente exacta debe ser un gradiente."""
        calc = DiscreteVectorCalculus(tetrahedron)
        ω = np.random.randn(calc.num_edges)
        
        result = calc.hodge_decomposition(ω)
        
        # La componente exacta es grad(α)
        expected_exact = calc.gradient(result["exact_potential"])
        np.testing.assert_allclose(
            result["exact"], expected_exact, atol=1e-8
        )
    
    def test_hodge_pure_gradient(self, tetrahedron):
        """Gradiente puro debe tener solo componente exacta."""
        calc = DiscreteVectorCalculus(tetrahedron)
        φ = np.random.randn(calc.num_nodes)
        ω = calc.gradient(φ)
        
        result = calc.hodge_decomposition(ω)
        
        np.testing.assert_allclose(
            result["coexact"], 0, atol=1e-8,
            err_msg="Gradiente tiene componente co-exacta no nula"
        )
    
    def test_hodge_harmonic_in_kernel(self, square_graph):
        """Componente armónica debe estar en ker(Δ₁)."""
        calc = DiscreteVectorCalculus(square_graph)
        ω = np.random.randn(calc.num_edges)
        
        result = calc.hodge_decomposition(ω)
        γ = result["harmonic"]
        
        Δ1 = calc.laplacian(1)
        Δ1_γ = Δ1 @ γ
        
        # Tolerancia más alta por la regularización
        np.testing.assert_allclose(
            Δ1_γ, 0, atol=1e-6,
            err_msg="Componente armónica no está en ker(Δ₁)"
        )


# =============================================================================
# TESTS: DiscreteVectorCalculus - Estrellas de Hodge
# =============================================================================

class TestHodgeStars:
    """Tests para operadores estrella de Hodge."""
    
    def test_star0_diagonal_positive(self, tetrahedron):
        """⋆₀ debe tener diagonal estrictamente positiva."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        diag = calc.star0.diagonal()
        assert np.all(diag > 0), "⋆₀ tiene entradas no positivas"
    
    def test_star1_diagonal_positive(self, tetrahedron):
        """⋆₁ debe tener diagonal estrictamente positiva."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        diag = calc.star1.diagonal()
        assert np.all(diag > 0), "⋆₁ tiene entradas no positivas"
    
    def test_star_inverse_correct(self, tetrahedron):
        """⋆ₖ⁻¹ ⋆ₖ = I."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        # Star 0
        product0 = calc.star0_inv @ calc.star0
        np.testing.assert_allclose(
            product0.toarray(), np.eye(calc.num_nodes), atol=1e-12
        )
        
        # Star 1
        product1 = calc.star1_inv @ calc.star1
        np.testing.assert_allclose(
            product1.toarray(), np.eye(calc.num_edges), atol=1e-12
        )
    
    def test_star2_with_faces(self, tetrahedron):
        """⋆₂ debe existir y ser consistente si hay caras."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        assert calc.star2.shape == (calc.num_faces, calc.num_faces)
        
        diag = calc.star2.diagonal()
        assert np.all(diag > 0)


# =============================================================================
# TESTS: MaxwellFDTDSolver - Construcción
# =============================================================================

class TestMaxwellSolverConstruction:
    """Tests para la construcción del solver Maxwell FDTD."""
    
    def test_basic_construction(self, single_triangle):
        """Construcción básica debe funcionar."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        assert solver.E.shape == (calc.num_edges,)
        assert solver.B.shape == (calc.num_faces,)
        assert solver.dt_cfl > 0
    
    def test_custom_material_parameters(self, single_triangle):
        """Parámetros de material personalizados."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(
            calc,
            permittivity=2.0,
            permeability=1.5,
            electric_conductivity=0.1,
            magnetic_conductivity=0.05
        )
        
        assert solver.epsilon == 2.0
        assert solver.mu == 1.5
        assert solver.sigma_e == 0.1
        assert solver.sigma_m == 0.05
    
    def test_phase_velocity(self, single_triangle):
        """Velocidad de fase c = 1/√(εμ)."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc, permittivity=4.0, permeability=1.0)
        
        expected_c = 1.0 / np.sqrt(4.0 * 1.0)
        assert np.isclose(solver.c, expected_c)
    
    def test_cfl_limit_positive(self, tetrahedron):
        """Límite CFL debe ser positivo."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        assert solver.dt_cfl > 0
        assert np.isfinite(solver.dt_cfl)
    
    def test_initial_fields_zero(self, single_triangle):
        """Campos iniciales deben ser cero por defecto."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        np.testing.assert_array_equal(solver.E, 0)
        np.testing.assert_array_equal(solver.B, 0)
        np.testing.assert_array_equal(solver.D, 0)
        np.testing.assert_array_equal(solver.H, 0)


# =============================================================================
# TESTS: MaxwellFDTDSolver - Dinámica y Conservación
# =============================================================================

class TestMaxwellDynamics:
    """Tests para la dinámica y conservación de energía."""
    
    def test_leapfrog_step_increments_time(self, single_triangle):
        """Paso leapfrog debe incrementar tiempo y contador."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        initial_time = solver.time
        initial_step = solver.step_count
        
        solver.leapfrog_step()
        
        assert solver.time > initial_time
        assert solver.step_count == initial_step + 1
    
    def test_energy_recorded(self, single_triangle):
        """Energía debe registrarse en historial."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges) * 0.1
        solver.update_constitutive_relations()
        
        solver.leapfrog_step()
        
        assert len(solver.energy_history) > 0
    
    def test_energy_conservation_lossless(self, tetrahedron):
        """Energía debe conservarse sin pérdidas ni fuentes."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(
            calc,
            electric_conductivity=0.0,
            magnetic_conductivity=0.0
        )
        
        # Condición inicial no trivial
        solver.E = np.random.randn(calc.num_edges)
        solver.B = np.random.randn(calc.num_faces)
        solver.update_constitutive_relations()
        
        result = solver.verify_energy_conservation(num_steps=200)
        
        assert result["is_conservative"], (
            f"Energía no conservada: desviación relativa = "
            f"{result['max_relative_deviation']:.2e}"
        )
    
    def test_energy_decreases_with_losses(self, tetrahedron):
        """Energía debe decrecer con pérdidas óhmicas."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(
            calc,
            electric_conductivity=0.5,  # Pérdidas significativas
            magnetic_conductivity=0.0
        )
        
        # Condición inicial
        solver.E = np.ones(calc.num_edges)
        solver.update_constitutive_relations()
        
        initial_energy = solver.total_energy()
        
        for _ in range(50):
            solver.leapfrog_step()
        
        final_energy = solver.total_energy()
        
        assert final_energy < initial_energy, "Energía no decrece con pérdidas"
    
    def test_cfl_warning(self, single_triangle):
        """Debe advertir si dt > dt_cfl."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        with pytest.warns(UserWarning, match="inestabilidad"):
            solver.leapfrog_step(dt=solver.dt_cfl * 2)
    
    def test_set_initial_conditions(self, tetrahedron):
        """Condiciones iniciales deben establecerse correctamente."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        E0 = np.random.randn(calc.num_edges)
        B0 = np.random.randn(calc.num_faces)
        
        solver.set_initial_conditions(E0=E0, B0=B0)
        
        np.testing.assert_array_equal(solver.E, E0)
        np.testing.assert_array_equal(solver.B, B0)
        # D y H deben actualizarse
        assert not np.allclose(solver.D, 0)
    
    def test_initial_conditions_wrong_size(self, single_triangle):
        """Condiciones iniciales con tamaño incorrecto deben fallar."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        with pytest.raises(ValueError):
            solver.set_initial_conditions(E0=np.array([1.0]))  # Tamaño incorrecto


# =============================================================================
# TESTS: MaxwellFDTDSolver - Relaciones Constitutivas
# =============================================================================

class TestConstitutiveRelations:
    """Tests para relaciones constitutivas D = εE, B = μH."""
    
    def test_constitutive_D_from_E(self, single_triangle):
        """D = ε⋆₁E."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc, permittivity=2.0)
        
        solver.E = np.array([1.0, 2.0, 3.0])
        solver.update_constitutive_relations()
        
        expected_D = 2.0 * (calc.star1 @ solver.E)
        np.testing.assert_allclose(solver.D, expected_D)
    
    def test_constitutive_H_from_B(self, single_triangle):
        """H = (1/μ)⋆₂⁻¹B."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc, permeability=2.0)
        
        solver.B = np.array([1.0])
        solver.update_constitutive_relations()
        
        expected_H = 0.5 * (calc.star2_inv @ solver.B)
        np.testing.assert_allclose(solver.H, expected_H)


# =============================================================================
# TESTS: MaxwellFDTDSolver - Vector de Poynting
# =============================================================================

class TestPoyntingFlux:
    """Tests para el flujo de Poynting."""
    
    def test_poynting_shape(self, tetrahedron):
        """Poynting debe tener tamaño num_edges."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        S = solver.poynting_flux()
        
        assert S.shape == (calc.num_edges,)
    
    def test_poynting_zero_for_zero_fields(self, tetrahedron):
        """Poynting es cero si E o H son cero."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        S = solver.poynting_flux()
        
        np.testing.assert_array_equal(S, 0)
    
    def test_poynting_nonzero_for_nonzero_fields(self, tetrahedron):
        """Poynting es no nulo con campos no nulos."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        solver.E = np.ones(calc.num_edges)
        solver.B = np.ones(calc.num_faces)
        solver.update_constitutive_relations()
        
        S = solver.poynting_flux()
        
        assert not np.allclose(S, 0)


# =============================================================================
# TESTS: PortHamiltonianController - Construcción
# =============================================================================

class TestPHSControllerConstruction:
    """Tests para construcción del controlador PHS."""
    
    def test_basic_construction(self, tetrahedron):
        """Construcción básica debe funcionar."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver, target_energy=1.0)
        
        assert controller.H_target == 1.0
        assert controller.n_x == calc.num_edges + calc.num_faces
    
    def test_target_energy_positive(self, single_triangle):
        """Energía objetivo debe ser positiva."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver, target_energy=-1.0)
        
        assert controller.H_target > 0


# =============================================================================
# TESTS: PortHamiltonianController - Matrices PHS
# =============================================================================

class TestPHSMatrices:
    """Tests para matrices de estructura PHS."""
    
    def test_J_antisymmetric(self, tetrahedron):
        """Matriz J debe ser antisimétrica."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver)
        
        J = controller.J_phs
        J_plus_JT = J + J.T
        
        assert sparse_norm(J_plus_JT) < 1e-12, "J no es antisimétrica"
    
    def test_R_symmetric(self, tetrahedron):
        """Matriz R debe ser simétrica."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver)
        
        R = controller.R_phs
        R_minus_RT = R - R.T
        
        assert sparse_norm(R_minus_RT) < 1e-12, "R no es simétrica"
    
    def test_R_positive_semidefinite(self, tetrahedron):
        """Matriz R debe ser semidefinida positiva."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc, electric_conductivity=0.1)
        controller = PortHamiltonianController(solver)
        
        R = controller.R_phs.toarray()
        eigenvalues = np.linalg.eigvalsh(R)
        
        assert np.all(eigenvalues >= -1e-10), "R tiene autovalores negativos"
    
    def test_g_matrix_shape(self, tetrahedron):
        """Matriz g debe tener forma correcta."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver)
        
        expected_size = calc.num_edges + calc.num_faces
        assert controller.g_matrix.shape == (expected_size, expected_size)


# =============================================================================
# TESTS: PortHamiltonianController - Hamiltoniano y Gradiente
# =============================================================================

class TestPHSHamiltonian:
    """Tests para Hamiltoniano y su gradiente."""
    
    def test_hamiltonian_equals_solver_energy(self, tetrahedron):
        """Hamiltoniano debe coincidir con energía del solver."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges)
        solver.B = np.random.randn(calc.num_faces)
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver)
        
        H_controller = controller.hamiltonian()
        H_solver = solver.total_energy()
        
        np.testing.assert_allclose(H_controller, H_solver)
    
    def test_hamiltonian_from_state_vector(self, tetrahedron):
        """Hamiltoniano debe calcularse desde vector de estado."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver)
        
        x = np.random.randn(calc.num_edges + calc.num_faces)
        H = controller.hamiltonian(x)
        
        assert H >= 0, "Hamiltoniano debe ser no negativo"
    
    def test_gradient_shape(self, tetrahedron):
        """Gradiente del Hamiltoniano debe tener forma correcta."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver)
        
        grad_H = controller.hamiltonian_gradient()
        
        expected_size = calc.num_edges + calc.num_faces
        assert grad_H.shape == (expected_size,)
    
    def test_gradient_is_dual_fields(self, tetrahedron):
        """∂H/∂x = [D, H]ᵀ."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges)
        solver.B = np.random.randn(calc.num_faces)
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver)
        grad_H = controller.hamiltonian_gradient()
        
        np.testing.assert_allclose(grad_H[:calc.num_edges], solver.D)
        np.testing.assert_allclose(grad_H[calc.num_edges:], solver.H)


# =============================================================================
# TESTS: PortHamiltonianController - Control y Pasividad
# =============================================================================

class TestPHSControl:
    """Tests para ley de control y pasividad."""
    
    def test_control_shape(self, tetrahedron):
        """Señal de control debe tener forma correcta."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges)
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver)
        u = controller.compute_control()
        
        expected_size = calc.num_edges + calc.num_faces
        assert u.shape == (expected_size,)
    
    def test_control_direction(self, tetrahedron):
        """Control debe tener signo correcto según error de energía."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        # Energía alta → control disipa
        solver.E = np.ones(calc.num_edges) * 10
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver, target_energy=0.1)
        u_high = controller.compute_control()
        grad_H = controller.hamiltonian_gradient()
        
        # u · ∇H debería ser negativo (disipando energía)
        power = np.dot(u_high, grad_H)
        assert power < 0, "Control no disipa cuando H > H*"
    
    def test_storage_function_nonnegative(self, tetrahedron):
        """Función de almacenamiento debe ser no negativa."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges)
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver)
        V = controller.storage_function()
        
        assert V >= 0
    
    def test_storage_function_zero_at_target(self, tetrahedron):
        """V = 0 cuando H = H*."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        target = 1.0
        controller = PortHamiltonianController(solver, target_energy=target)
        
        # Configurar para que H ≈ H*
        # U = (1/2)εE² → E = √(2U/ε)
        E_mag = np.sqrt(2 * target / solver.epsilon)
        solver.E = np.ones(calc.num_edges) * E_mag / np.sqrt(calc.num_edges)
        solver.update_constitutive_relations()
        
        H = controller.hamiltonian()
        V = controller.storage_function()
        
        # V = (1/2)(H - H*)² ≈ 0 si H ≈ H*
        np.testing.assert_allclose(V, 0.5 * (H - target)**2)
    
    def test_controlled_step_updates_sources(self, tetrahedron):
        """Paso controlado debe aplicar fuentes temporalmente."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges)
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver)
        controller.controlled_step()
        
        # Después del paso, las fuentes deben estar limpias
        np.testing.assert_array_equal(solver.J_e, 0)
        np.testing.assert_array_equal(solver.J_m, 0)
    
    def test_passivity_verification(self, tetrahedron):
        """Verificación de pasividad debe ejecutarse."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        controller = PortHamiltonianController(solver)
        
        result = controller.verify_passivity(num_steps=20)
        
        assert "is_passive" in result
        assert "max_violation" in result


# =============================================================================
# TESTS: PortHamiltonianController - Simulación de Regulación
# =============================================================================

class TestPHSRegulation:
    """Tests para simulación de regulación hacia energía objetivo."""
    
    def test_regulation_simulation_runs(self, tetrahedron):
        """Simulación de regulación debe ejecutarse sin errores."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges) * 2
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(solver, target_energy=0.5)
        result = controller.simulate_regulation(num_steps=50)
        
        assert "energy" in result
        assert len(result["energy"]) == 50
    
    def test_regulation_decreases_storage_function(self, tetrahedron):
        """La regulación debe disminuir la función de almacenamiento."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        # Condición inicial lejos del objetivo
        solver.E = np.ones(calc.num_edges) * 5
        solver.update_constitutive_relations()
        
        controller = PortHamiltonianController(
            solver, 
            target_energy=0.1,
            damping_injection=0.5
        )
        
        V_initial = controller.storage_function()
        result = controller.simulate_regulation(num_steps=200)
        V_final = controller.storage_function()
        
        # La función de Lyapunov debe decrecer (o al menos no crecer mucho)
        assert V_final < V_initial * 1.1, (
            f"Storage function no decrece: {V_initial:.4f} → {V_final:.4f}"
        )


# =============================================================================
# TESTS: Casos Edge y Robustez
# =============================================================================

class TestEdgeCases:
    """Tests para casos límite y robustez."""
    
    def test_graph_with_no_edges(self):
        """Grafo sin aristas (nodos aislados)."""
        adj = {0: set(), 1: set(), 2: set()}
        
        with pytest.warns(UserWarning):
            calc = DiscreteVectorCalculus(adj)
        
        assert calc.num_edges == 0
        assert calc.num_faces == 0
    
    def test_very_large_graph(self):
        """Grafo grande para verificar escalabilidad."""
        # Crear grafo de Erdős-Rényi
        n = 100
        p = 0.1
        G = nx.erdos_renyi_graph(n, p, seed=42)
        adj = {node: set(G.neighbors(node)) for node in G.nodes()}
        
        # Debe construirse sin errores
        calc = DiscreteVectorCalculus(adj)
        
        assert calc.num_nodes == n
        assert calc.num_edges > 0
    
    def test_numerical_stability_small_values(self, single_triangle):
        """Estabilidad con valores muy pequeños."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        # Campos muy pequeños
        solver.E = np.ones(calc.num_edges) * 1e-15
        solver.update_constitutive_relations()
        
        # No debe producir NaN o Inf
        for _ in range(10):
            solver.leapfrog_step()
        
        assert np.all(np.isfinite(solver.E))
        assert np.all(np.isfinite(solver.B))
    
    def test_numerical_stability_large_values(self, single_triangle):
        """Estabilidad con valores grandes."""
        calc = DiscreteVectorCalculus(single_triangle)
        solver = MaxwellFDTDSolver(calc)
        
        # Campos grandes pero razonables
        solver.E = np.ones(calc.num_edges) * 1e6
        solver.update_constitutive_relations()
        
        # Con dt pequeño, debe ser estable
        for _ in range(10):
            solver.leapfrog_step(dt=solver.dt_cfl * 0.1)
        
        assert np.all(np.isfinite(solver.E))


# =============================================================================
# TESTS: Integración
# =============================================================================

class TestIntegration:
    """Tests de integración entre componentes."""
    
    def test_full_pipeline(self, tetrahedron):
        """Pipeline completo: Calculus → Solver → Controller."""
        # 1. Crear cálculo discreto
        calc = DiscreteVectorCalculus(tetrahedron)
        
        # 2. Verificar propiedades topológicas
        exactness = calc.verify_complex_exactness()
        assert exactness["∂₁∂₂_is_zero"]
        
        # 3. Crear solver
        solver = MaxwellFDTDSolver(calc)
        solver.E = np.random.randn(calc.num_edges)
        solver.B = np.random.randn(calc.num_faces)
        solver.update_constitutive_relations()
        
        # 4. Verificar conservación
        conservation = solver.verify_energy_conservation(num_steps=50)
        assert conservation["is_conservative"]
        
        # 5. Crear controlador
        controller = PortHamiltonianController(solver, target_energy=0.5)
        
        # 6. Simular regulación
        result = controller.simulate_regulation(num_steps=100)
        
        # 7. Verificar que el sistema evoluciona
        assert len(result["energy"]) == 100
        assert result["final_error"] < 10  # Error razonable
    
    def test_calculus_solver_consistency(self, tetrahedron):
        """Operadores del cálculo deben ser consistentes con solver."""
        calc = DiscreteVectorCalculus(tetrahedron)
        solver = MaxwellFDTDSolver(calc)
        
        # El curl usado en el solver debe coincidir con calc.curl
        E = np.random.randn(calc.num_edges)
        
        curl_from_calc = calc.curl(E)
        curl_from_op = calc.curl_op @ E
        
        np.testing.assert_allclose(curl_from_calc, curl_from_op)


# =============================================================================
# TESTS: Propiedades Matemáticas Avanzadas
# =============================================================================

class TestAdvancedMathematicalProperties:
    """Tests para propiedades matemáticas avanzadas."""
    
    def test_laplacian_commutes_with_d(self, tetrahedron):
        """[Δ, d] = 0 (Laplaciano conmuta con diferencial)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        if calc.num_faces == 0:
            pytest.skip("Requiere caras para d₁")
        
        # Para φ ∈ C⁰: d₁(Δ₀φ) = Δ₁(d₀φ)
        # Nota: Esto es una propiedad que puede no cumplirse exactamente
        # en el discreto, pero verificamos la aproximación
        
        φ = np.random.randn(calc.num_nodes)
        
        # Lado izquierdo: d₁(Δ₀φ) - pero d₁ actúa en 1-formas...
        # Realmente verificamos: Δ₀ d₀ᵀ = d₀ᵀ Δ₁ (adjuntos)
        # Esto es complejo en el discreto, saltamos por ahora
        pass
    
    def test_hodge_star_involution(self, tetrahedron):
        """⋆⋆ = ±id (involutividad de Hodge star)."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        # Para 1-formas en 2D: ⋆₁⋆₁ = -id típicamente
        # Pero nuestra implementación usa métricas diagonales
        # Verificamos que star1_inv @ star1 = id
        
        product = calc.star1_inv @ calc.star1
        np.testing.assert_allclose(
            product.toarray(), 
            np.eye(calc.num_edges),
            atol=1e-12
        )
    
    def test_green_identity_discrete(self, tetrahedron):
        """Identidad de Green discreta: ⟨Δφ, ψ⟩ = ⟨∇φ, ∇ψ⟩."""
        calc = DiscreteVectorCalculus(tetrahedron)
        
        φ = np.random.randn(calc.num_nodes)
        ψ = np.random.randn(calc.num_nodes)
        
        # Lado izquierdo: ⟨Δ₀φ, ψ⟩ con métrica ⋆₀
        Δφ = calc.laplacian(0) @ φ
        lhs = np.dot(calc.star0 @ Δφ, ψ)
        
        # Lado derecho: ⟨∇φ, ∇ψ⟩ con métrica ⋆₁
        grad_φ = calc.gradient(φ)
        grad_ψ = calc.gradient(ψ)
        rhs = np.dot(calc.star1 @ grad_φ, grad_ψ)
        
        # Puede haber diferencias por las métricas, verificamos orden de magnitud
        if np.abs(lhs) > 1e-10:
            relative_error = np.abs(lhs - rhs) / np.abs(lhs)
            assert relative_error < 0.5, f"Green identity error: {relative_error}"


# =============================================================================
# CONFIGURACIÓN DE PYTEST
# =============================================================================

if __name__ == "__main__":
    pytest.main([
        __file__,
        "-v",
        "--tb=short",
        "-x",  # Parar en primer fallo
        "--durations=10"  # Mostrar 10 tests más lentos
    ])