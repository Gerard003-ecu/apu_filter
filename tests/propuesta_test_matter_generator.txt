### Propuesta 2

import pytest
import networkx as nx
import math
from app.matter_generator import MatterGenerator, MaterialRequirement, BillOfMaterials

class TestMatterGenerator:

    @pytest.fixture
    def sample_graph(self):
        """
        Crea un grafo piramidal de prueba:
        ROOT -> APU1 (x2) -> INS1 (x5)
        ROOT -> APU2 (x1) -> INS1 (x3)
                          -> INS2 (x10)

        Total INS1: (2 * 5) + (1 * 3) = 13
        Total INS2: (1 * 10) = 10
        """
        G = nx.DiGraph()

        # Nodos
        G.add_node("PROYECTO_TOTAL", type="ROOT", level=0, description="Proyecto")
        G.add_node("APU1", type="APU", level=2, description="Muro Ladrillo")
        G.add_node("APU2", type="APU", level=2, description="Piso Concreto")
        G.add_node("INS1", type="INSUMO", level=3, description="Cemento", 
                  unit_cost=100.0, unit="kg", material_category="GENERIC")
        G.add_node("INS2", type="INSUMO", level=3, description="Arena", 
                  unit_cost=50.0, unit="m3", material_category="BULKY")

        # Aristas (Cantidades)
        # Nivel 1 (Proyecto -> APU)
        G.add_edge("PROYECTO_TOTAL", "APU1", quantity=2.0)
        G.add_edge("PROYECTO_TOTAL", "APU2", quantity=1.0)

        # Nivel 2 (APU -> Insumo)
        G.add_edge("APU1", "INS1", quantity=5.0)
        G.add_edge("APU2", "INS1", quantity=3.0)
        G.add_edge("APU2", "INS2", quantity=10.0)

        return G

    @pytest.fixture
    def complex_graph(self):
        """Grafo más complejo con múltiples caminos y materiales especiales."""
        G = nx.DiGraph()
        
        # Nodos de diferentes tipos
        G.add_node("ROOT", type="ROOT", description="Proyecto Complejo")
        
        # APUs
        G.add_node("APU_A", type="APU", description="Estructura Principal")
        G.add_node("APU_B", type="APU", description="Acabados")
        G.add_node("APU_C", type="APU", description="Instalaciones")
        
        # Materiales con diferentes categorías
        G.add_node("MAT1", type="INSUMO", description="Vidrio Templado",
                  unit_cost=200.0, unit="m2", material_category="FRAGILE")
        G.add_node("MAT2", type="INSUMO", description="Pintura Epóxica",
                  unit_cost=80.0, unit="gal", material_category="HAZARDOUS")
        G.add_node("MAT3", type="INSUMO", description="Tubería PVC",
                  unit_cost=30.0, unit="m", material_category="PRECISION")
        G.add_node("MAT4", type="INSUMO", description="Cemento Rápido",
                  unit_cost=120.0, unit="kg", material_category="PERISHABLE")
        G.add_node("MAT5", type="INSUMO", description="Arena Fina",
                  unit_cost=40.0, unit="m3", material_category="BULKY")
        
        # Conexiones complejas con múltiples caminos
        G.add_edge("ROOT", "APU_A", quantity=1.0)
        G.add_edge("ROOT", "APU_B", quantity=1.0)
        G.add_edge("ROOT", "APU_C", quantity=1.0)
        
        G.add_edge("APU_A", "MAT1", quantity=2.5)
        G.add_edge("APU_A", "MAT3", quantity=8.0)
        G.add_edge("APU_A", "MAT4", quantity=15.0)
        
        G.add_edge("APU_B", "MAT1", quantity=1.0)  # Otro camino a MAT1
        G.add_edge("APU_B", "MAT2", quantity=3.0)
        
        G.add_edge("APU_C", "MAT3", quantity=5.0)  # Otro camino a MAT3
        G.add_edge("APU_C", "MAT5", quantity=2.0)
        
        return G

    @pytest.fixture
    def cyclic_graph(self):
        """Grafo con ciclo para probar detección."""
        G = nx.DiGraph()
        G.add_node("A", type="APU")
        G.add_node("B", type="APU")
        G.add_node("C", type="APU")
        G.add_node("INS", type="INSUMO", unit_cost=10.0)
        
        G.add_edge("A", "B")
        G.add_edge("B", "C")
        G.add_edge("C", "A")  # Ciclo A -> B -> C -> A
        G.add_edge("A", "INS", quantity=5.0)
        
        return G

    def test_materialize_project_structure(self, sample_graph):
        """Prueba la estructura básica del BOM generado."""
        generator = MatterGenerator()
        bom = generator.materialize_project(sample_graph)

        assert isinstance(bom, BillOfMaterials)
        assert len(bom.requirements) == 2  # Cemento y Arena

        # Verificar totales base (sin factores)
        cemento = next(r for r in bom.requirements if r.id == "INS1")
        arena = next(r for r in bom.requirements if r.id == "INS2")

        assert cemento.quantity_base == 13.0
        assert arena.quantity_base == 10.0

        # Costos sin factores
        assert cemento.total_cost == 13.0 * 100.0
        assert arena.total_cost == 10.0 * 50.0

        # Costo total debe coincidir con suma de costos individuales
        assert bom.total_material_cost == pytest.approx(1300.0 + 500.0)
        
        # Validar coherencia interna del BOM
        assert bom.total_material_cost == pytest.approx(
            sum(r.total_cost for r in bom.requirements)
        )

        # Verificar metadata
        assert bom.metadata["topological_invariants"]["is_dag"] is True
        assert bom.metadata["graph_metrics"]["node_count"] == 5
        assert bom.metadata["cost_analysis"]["item_count"] == 2
        assert "generation_info" in bom.metadata

    def test_apply_entropy_factors_clean(self, sample_graph):
        """Prueba sin factores de riesgo (caso ideal)."""
        generator = MatterGenerator()
        bom = generator.materialize_project(sample_graph)

        for req in bom.requirements:
            assert req.waste_factor == 0.0
            assert req.quantity_total == pytest.approx(req.quantity_base)

    def test_apply_entropy_factors_high_risk(self, sample_graph):
        """
        Prueba con métricas de flujo adversas usando composición de monoides (multiplicativo).
        Factor Base = 1.05 (Saturation) * 1.03 (Stability) = 1.0815
        Waste Factor = 0.0815
        """
        generator = MatterGenerator()
        flux_metrics = {
            "avg_saturation": 0.9,  # > 0.8 triggers * 1.05
            "pyramid_stability": 0.5  # < 1.0 triggers * 1.03
        }

        bom = generator.materialize_project(sample_graph, flux_metrics=flux_metrics)

        # Cálculo esperado: 1.05 * 1.03 = 1.0815
        expected_multiplier = 1.05 * 1.03
        expected_waste = expected_multiplier - 1.0

        for req in bom.requirements:
            assert req.waste_factor == pytest.approx(expected_waste, rel=1e-3)
            assert req.quantity_total == pytest.approx(req.quantity_base * expected_multiplier, rel=1e-3)

    def test_apply_entropy_factors_with_risk_profile(self, sample_graph):
        """Prueba con perfil de riesgo CRITICAL y materiales específicos."""
        generator = MatterGenerator()
        risk_profile = {"level": "CRITICAL"}
        
        bom = generator.materialize_project(
            sample_graph, 
            risk_profile=risk_profile
        )

        # Factor base para CRITICAL: 1.15
        expected_multiplier = 1.15
        
        # Factor específico para BULKY (Arena): 1.02
        arena = next(r for r in bom.requirements if r.id == "INS2")
        expected_arena_multiplier = 1.15 * 1.02  # base * specific
        
        assert arena.waste_factor == pytest.approx(expected_arena_multiplier - 1.0, rel=1e-3)
        assert arena.quantity_total == pytest.approx(arena.quantity_base * expected_arena_multiplier, rel=1e-3)

    def test_source_tracking(self, sample_graph):
        """Verifica que se rastreen los APUs de origen."""
        generator = MatterGenerator()
        bom = generator.materialize_project(sample_graph)

        cemento = next(r for r in bom.requirements if r.id == "INS1")
        assert "APU1" in cemento.source_apus
        assert "APU2" in cemento.source_apus
        assert len(cemento.source_apus) == 2

        arena = next(r for r in bom.requirements if r.id == "INS2")
        assert "APU2" in arena.source_apus
        assert "APU1" not in arena.source_apus
        assert len(arena.source_apus) == 1

    def test_missing_root_fallback(self):
        """Prueba comportamiento cuando no hay nodo ROOT explícito."""
        G = nx.DiGraph()
        # Grafo con APU como raíz implícita
        G.add_node("APU1", type="APU")
        G.add_node("INS1", type="INSUMO", unit_cost=10.0, description="Material")
        G.add_edge("APU1", "INS1", quantity=5.0)

        generator = MatterGenerator()
        bom = generator.materialize_project(G)

        assert len(bom.requirements) == 1
        assert bom.requirements[0].quantity_base == 5.0
        assert bom.requirements[0].source_apus == ["APU1"]

    def test_cycle_detection(self, cyclic_graph):
        """Verifica que el sistema rechace grafos cíclicos con mensaje informativo."""
        generator = MatterGenerator()

        with pytest.raises(ValueError, match="ciclo") as exc_info:
            generator.materialize_project(cyclic_graph)
        
        # Verificar que el mensaje de error contiene información útil
        error_msg = str(exc_info.value).lower()
        assert any(word in error_msg for word in ["ciclo", "cycle", "dag"])

    def test_empty_graph(self):
        """Prueba con grafo vacío."""
        G = nx.DiGraph()
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        assert len(bom.requirements) == 0
        assert bom.total_material_cost == 0.0
        assert bom.metadata["cost_analysis"]["empty"] is True

    def test_graph_without_insumos(self):
        """Prueba grafo sin nodos INSUMO."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        G.add_node("APU1", type="APU")
        G.add_edge("ROOT", "APU1", quantity=1.0)
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        assert len(bom.requirements) == 0
        assert bom.total_material_cost == 0.0

    def test_negative_quantities_handling(self):
        """Prueba manejo de cantidades negativas en aristas."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        G.add_node("INS", type="INSUMO", unit_cost=10.0)
        G.add_edge("ROOT", "INS", quantity=-2.0)  # Cantidad negativa
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        # El sistema debe usar 1.0 como valor por defecto para cantidades no positivas
        assert bom.requirements[0].quantity_base == 1.0

    def test_zero_unit_cost_handling(self):
        """Prueba manejo de costo unitario cero."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        G.add_node("INS", type="INSUMO", unit_cost=0.0, description="Material Gratuito")
        G.add_edge("ROOT", "INS", quantity=5.0)
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        assert bom.requirements[0].total_cost == 0.0
        assert bom.total_material_cost == 0.0

    def test_complex_graph_clustering(self, complex_graph):
        """Prueba clustering semántico en grafo complejo."""
        generator = MatterGenerator()
        bom = generator.materialize_project(complex_graph)
        
        # Verificar que materiales duplicados (MAT1 y MAT3) se agrupan
        mat_ids = [req.id for req in bom.requirements]
        
        # MAT1 aparece desde APU_A y APU_B, debe agruparse
        mat1 = next(r for r in bom.requirements if r.id == "MAT1")
        assert "APU_A" in mat1.source_apus
        assert "APU_B" in mat1.source_apus
        assert len(mat1.source_apus) == 2
        
        # MAT3 aparece desde APU_A y APU_C, debe agruparse
        mat3 = next(r for r in bom.requirements if r.id == "MAT3")
        assert "APU_A" in mat3.source_apus
        assert "APU_C" in mat3.source_apus
        assert len(mat3.source_apus) == 2
        
        # Cantidad total para MAT1: (1 * 2.5) + (1 * 1.0) = 3.5
        assert mat1.quantity_base == pytest.approx(3.5)

    def test_material_specific_factors(self, complex_graph):
        """Prueba factores específicos por categoría de material."""
        generator = MatterGenerator()
        bom = generator.materialize_project(complex_graph)
        
        # Encontrar materiales por categoría
        fragile = next(r for r in bom.requirements if r.description == "Vidrio Templado")
        hazardous = next(r for r in bom.requirements if r.description == "Pintura Epóxica")
        perishable = next(r for r in bom.requirements if r.description == "Cemento Rápido")
        
        # Verificar que los factores específicos se aplican
        # FRAGILE: 1.02, HAZARDOUS: 1.06, PERISHABLE: 1.04
        # (Solo factores específicos, sin factores base)
        assert fragile.waste_factor == pytest.approx(1.02 - 1.0, rel=1e-3)
        assert hazardous.waste_factor == pytest.approx(1.06 - 1.0, rel=1e-3)
        assert perishable.waste_factor == pytest.approx(1.04 - 1.0, rel=1e-3)

    def test_pareto_analysis_in_metadata(self, complex_graph):
        """Prueba que el análisis de Pareto se incluya en metadata."""
        generator = MatterGenerator()
        bom = generator.materialize_project(complex_graph)
        
        pareto_info = bom.metadata["cost_analysis"]["pareto_analysis"]
        
        assert "pareto_20_percent" in pareto_info
        assert "pareto_cost_percentage" in pareto_info
        assert parelo_info["pareto_cost_percentage"] >= 80.0  # Debe cumplir regla 80/20

    def test_overflow_protection(self):
        """Prueba protección contra overflow numérico."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        
        # Agregar muchos nodos para exceder límite de complejidad
        for i in range(200):
            G.add_node(f"INS_{i}", type="INSUMO", unit_cost=1000.0)
            G.add_edge("ROOT", f"INS_{i}", quantity=1000.0)
        
        generator = MatterGenerator(max_graph_complexity=10000)
        
        # Debería lanzar OverflowError por exceder complejidad
        with pytest.raises(OverflowError, match="complejidad"):
            generator.materialize_project(G)

    def test_invalid_material_skipping(self):
        """Prueba que materiales inválidos se omiten sin romper el proceso."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        
        # Material válido
        G.add_node("VALID", type="INSUMO", unit_cost=10.0, description="Válido")
        G.add_edge("ROOT", "VALID", quantity=5.0)
        
        # Material con cantidad base cero (será omitido)
        G.add_node("ZERO_QTY", type="INSUMO", unit_cost=10.0, description="Cero")
        G.add_edge("ROOT", "ZERO_QTY", quantity=0.0)
        
        # Material con costo negativo (será ajustado)
        G.add_node("NEG_COST", type="INSUMO", unit_cost=-5.0, description="Negativo")
        G.add_edge("ROOT", "NEG_COST", quantity=2.0)
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        # Solo el material válido debe aparecer
        assert len(bom.requirements) == 1
        assert bom.requirements[0].id == "VALID"

    def test_kahan_summation_precision(self):
        """Prueba precisión de la suma de Kahan para costos."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        
        # Agregar muchos materiales con costos pequeños
        num_materials = 1000
        for i in range(num_materials):
            G.add_node(f"INS_{i}", type="INSUMO", unit_cost=0.01)  # Costo pequeño
            G.add_edge("ROOT", f"INS_{i}", quantity=1.0)
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        # Costo esperado: 1000 * 0.01 = 10.0
        expected_cost = num_materials * 0.01
        
        # La suma debe ser precisa
        assert bom.total_material_cost == pytest.approx(expected_cost, rel=1e-9)

    def test_post_init_validation(self):
        """Prueba validación post-inicialización de MaterialRequirement."""
        # Debería fallar con cantidad base no positiva
        with pytest.raises(ValueError, match="Cantidad base no positiva"):
            MaterialRequirement(
                id="TEST",
                description="Test",
                quantity_base=0.0,
                unit="kg",
                waste_factor=0.0,
                quantity_total=0.0,
                unit_cost=10.0,
                total_cost=0.0
            )
        
        # Debería fallar con factor de desperdicio negativo
        with pytest.raises(ValueError, match="Factor de desperdicio negativo"):
            MaterialRequirement(
                id="TEST",
                description="Test",
                quantity_base=1.0,
                unit="kg",
                waste_factor=-0.5,
                quantity_total=0.5,
                unit_cost=10.0,
                total_cost=5.0
            )

    def test_bom_internal_consistency(self, sample_graph):
        """Prueba coherencia interna del BillOfMaterials."""
        generator = MatterGenerator()
        bom = generator.materialize_project(sample_graph)
        
        # Verificar que el costo total declarado coincide con la suma
        computed_total = sum(req.total_cost for req in bom.requirements)
        assert bom.total_material_cost == pytest.approx(computed_total, rel=1e-9)
        
        # Si manipulamos manualmente el total, debe fallar la validación
        bom.total_material_cost = 9999.0
        
        with pytest.raises(ValueError, match="inconsistente"):
            bom.__post_init__()  # Forzar validación

    def test_metadata_completeness(self, sample_graph):
        """Prueba que la metadata incluya todos los campos requeridos."""
        generator = MatterGenerator()
        bom = generator.materialize_project(sample_graph)
        
        metadata = bom.metadata
        
        # Verificar secciones principales
        required_sections = [
            "topological_invariants",
            "graph_metrics", 
            "cost_analysis",
            "risk_analysis",
            "generation_info"
        ]
        
        for section in required_sections:
            assert section in metadata
            
        # Verificar campos específicos
        assert "timestamp" in metadata["generation_info"]
        assert "generator_version" in metadata["generation_info"]
        assert "node_count" in metadata["graph_metrics"]
        assert "total_cost" in metadata["cost_analysis"]

    def test_identical_materials_different_units(self):
        """Prueba que materiales con mismo ID pero diferente unidad no se agrupen."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        
        # Mismo ID, diferente unidad
        G.add_node("MAT1", type="INSUMO", description="Material 1", 
                  unit_cost=10.0, unit="kg")
        G.add_node("MAT1_2", type="INSUMO", description="Material 1", 
                  unit_cost=8.0, unit="lb")  # Mismo material, diferente unidad
        
        G.add_edge("ROOT", "MAT1", quantity=2.0)
        G.add_edge("ROOT", "MAT1_2", quantity=5.0)
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        # Deben aparecer como dos requerimientos separados
        assert len(bom.requirements) == 2
        
        # Deben tener unidades diferentes
        units = {req.unit for req in bom.requirements}
        assert "kg" in units
        assert "lb" in units

    def test_edge_case_infinite_values(self):
        """Prueba manejo de valores infinitos."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        G.add_node("INF_COST", type="INSUMO", 
                  unit_cost=float('inf'),  # Costo infinito
                  description="Material Infinito")
        G.add_edge("ROOT", "INF_COST", quantity=1.0)
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G)
        
        # El material con costo infinito debe ser omitido
        assert len(bom.requirements) == 0

    def test_performance_small_graph(self):
        """Prueba de rendimiento con grafo pequeño."""
        import time
        
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        
        # Crear 100 materiales
        for i in range(100):
            G.add_node(f"INS_{i}", type="INSUMO", unit_cost=float(i + 1))
            G.add_edge("ROOT", f"INS_{i}", quantity=float(i + 1))
        
        generator = MatterGenerator()
        
        start_time = time.time()
        bom = generator.materialize_project(G)
        end_time = time.time()
        
        # Debe completarse en menos de 1 segundo
        assert end_time - start_time < 1.0
        
        # Verificar resultados
        assert len(bom.requirements) == 100
        assert bom.metadata["cost_analysis"]["item_count"] == 100

    def test_robustness_random_graph(self):
        """Prueba de robustez con grafo aleatorio (pero DAG)."""
        import random
        
        # Crear DAG aleatorio
        G = nx.gnp_random_graph(50, 0.1, directed=True)
        G = nx.DiGraph([(u, v) for (u, v) in G.edges() if u < v])  # Asegurar que sea DAG
        
        # Asignar tipos y atributos
        for node in G.nodes():
            # Algunos nodos son INSUMO, otros APU
            if random.random() > 0.7:
                G.nodes[node]['type'] = 'INSUMO'
                G.nodes[node]['unit_cost'] = random.uniform(1.0, 1000.0)
                G.nodes[node]['description'] = f"Material {node}"
                G.nodes[node]['unit'] = random.choice(['kg', 'm', 'm2', 'm3'])
            else:
                G.nodes[node]['type'] = 'APU'
                G.nodes[node]['description'] = f"APU {node}"
        
        # Agregar cantidades a las aristas
        for u, v in G.edges():
            G.edges[u, v]['quantity'] = random.uniform(0.1, 10.0)
        
        generator = MatterGenerator()
        
        # No debería lanzar excepciones
        bom = generator.materialize_project(G)
        
        # Verificar resultados básicos
        assert isinstance(bom, BillOfMaterials)
        assert bom.metadata["topological_invariants"]["is_dag"] is True

    def test_custom_max_complexity(self):
        """Prueba configuración personalizada de complejidad máxima."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        
        # Crear grafo de complejidad moderada
        for i in range(50):
            G.add_node(f"INS_{i}", type="INSUMO", unit_cost=10.0)
            G.add_edge("ROOT", f"INS_{i}", quantity=1.0)
        
        # Configurar generador con límite personalizado
        generator = MatterGenerator(max_graph_complexity=100)
        
        # 50 nodos * 50 aristas = 2500 > 100, debe lanzar error
        with pytest.raises(OverflowError, match="complejidad"):
            generator.materialize_project(G)

    def test_material_requirement_ordering(self, complex_graph):
        """Prueba que los materiales se ordenen por costo total descendente."""
        generator = MatterGenerator()
        bom = generator.materialize_project(complex_graph)
        
        # Verificar orden descendente por costo total
        costs = [req.total_cost for req in bom.requirements]
        assert all(costs[i] >= costs[i+1] for i in range(len(costs)-1))
        
        # El material más costoso debe ser primero
        max_cost = max(costs)
        assert bom.requirements[0].total_cost == max_cost

    def test_error_recovery_and_logging(self, sample_graph, caplog):
        """Prueba recuperación de errores y logging."""
        import logging
        
        caplog.set_level(logging.WARNING)
        
        # Modificar grafo para incluir caso problemático
        sample_graph.nodes["INS1"]["unit_cost"] = -50.0  # Costo negativo
        
        generator = MatterGenerator()
        bom = generator.materialize_project(sample_graph)
        
        # Verificar que se registró una advertencia
        assert any("negativo" in record.message.lower() 
                  or "negative" in record.message.lower() 
                  for record in caplog.records)
        
        # El proceso debe continuar y producir resultados
        assert len(bom.requirements) > 0

    def test_deterministic_output(self, sample_graph):
        """Prueba que la salida sea determinista para la misma entrada."""
        generator = MatterGenerator()
        
        # Generar BOM dos veces
        bom1 = generator.materialize_project(sample_graph)
        bom2 = generator.materialize_project(sample_graph)
        
        # Deben ser idénticos
        assert len(bom1.requirements) == len(bom2.requirements)
        
        for req1, req2 in zip(bom1.requirements, bom2.requirements):
            assert req1.id == req2.id
            assert req1.quantity_base == req2.quantity_base
            assert req1.total_cost == req2.total_cost
        
        # Metadata debe ser similar (excepto timestamp)
        for key in bom1.metadata:
            if key != "generation_info":
                assert bom1.metadata[key] == bom2.metadata[key]

    def test_flux_metrics_application(self):
        """Prueba aplicación específica de métricas de flujo."""
        G = nx.DiGraph()
        G.add_node("ROOT", type="ROOT")
        G.add_node("INS", type="INSUMO", unit_cost=100.0)
        G.add_edge("ROOT", "INS", quantity=1.0)
        
        # Métricas de flujo que no deberían activar ajustes
        flux_metrics = {
            "avg_saturation": 0.5,  # < 0.8, no ajuste
            "pyramid_stability": 1.2  # > 1.0, no ajuste
        }
        
        generator = MatterGenerator()
        bom = generator.materialize_project(G, flux_metrics=flux_metrics)
        
        # No debería haber ajuste
        assert bom.requirements[0].waste_factor == 0.0

if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])


### propuesta mejorada de los métodos de la propuesta 2 original

@pytest.fixture
def sample_graph(self):
    """
    Crea un grafo piramidal de prueba (DAG).
    
    Estructura topológica:
    ┌─────────────────────────────────────────────┐
    │  ROOT ──┬── APU1 (×2) ──── INS1 (×5)       │
    │         │                    ↑              │
    │         └── APU2 (×1) ──┬───┘ (×3)         │
    │                         └── INS2 (×10)     │
    └─────────────────────────────────────────────┘
    
    Propagación de cantidades (homomorfismo de pesos):
    - INS1: (2 × 5) + (1 × 3) = 13 unidades
    - INS2: (1 × 10) = 10 unidades
    
    Invariantes topológicos verificables:
    - χ(G) = |V| - |E| = 5 - 4 = 1 (característica de Euler)
    - Número de Betti β₀ = 1 (componente conexa única)
    """
    G = nx.DiGraph()

    # Vértices con atributos tipados
    G.add_node("PROYECTO_TOTAL", type="ROOT", level=0, description="Proyecto")
    G.add_node("APU1", type="APU", level=2, description="Muro Ladrillo")
    G.add_node("APU2", type="APU", level=2, description="Piso Concreto")
    G.add_node("INS1", type="INSUMO", level=3, description="Cemento", 
               unit_cost=100.0, unit="kg", material_category="GENERIC")
    G.add_node("INS2", type="INSUMO", level=3, description="Arena", 
               unit_cost=50.0, unit="m3", material_category="BULKY")

    # Aristas ponderadas (morfismos con peso)
    G.add_edge("PROYECTO_TOTAL", "APU1", quantity=2.0)
    G.add_edge("PROYECTO_TOTAL", "APU2", quantity=1.0)
    G.add_edge("APU1", "INS1", quantity=5.0)
    G.add_edge("APU2", "INS1", quantity=3.0)
    G.add_edge("APU2", "INS2", quantity=10.0)

    return G

@pytest.fixture
def complex_graph(self):
    """
    Grafo complejo con múltiples caminos (multipath DAG).
    
    Estructura para validar agrupación por cociente:
    - MAT1 ∈ [APU_A] ∪ [APU_B] (consolidación requerida)
    - MAT3 ∈ [APU_A] ∪ [APU_C] (consolidación requerida)
    
    Factores por categoría (estructura monoidal):
    ┌────────────┬────────┐
    │ Categoría  │ Factor │
    ├────────────┼────────┤
    │ FRAGILE    │ 1.02   │
    │ HAZARDOUS  │ 1.06   │
    │ PRECISION  │ 1.01   │
    │ PERISHABLE │ 1.04   │
    │ BULKY      │ 1.02   │
    └────────────┴────────┘
    """
    G = nx.DiGraph()
    
    G.add_node("ROOT", type="ROOT", description="Proyecto Complejo")
    
    # Nodos intermedios (APUs)
    for apu_id, desc in [("APU_A", "Estructura Principal"), 
                          ("APU_B", "Acabados"), 
                          ("APU_C", "Instalaciones")]:
        G.add_node(apu_id, type="APU", description=desc)
    
    # Materiales con categorías específicas
    materials = [
        ("MAT1", "Vidrio Templado", 200.0, "m2", "FRAGILE"),
        ("MAT2", "Pintura Epóxica", 80.0, "gal", "HAZARDOUS"),
        ("MAT3", "Tubería PVC", 30.0, "m", "PRECISION"),
        ("MAT4", "Cemento Rápido", 120.0, "kg", "PERISHABLE"),
        ("MAT5", "Arena Fina", 40.0, "m3", "BULKY"),
    ]
    
    for mat_id, desc, cost, unit, category in materials:
        G.add_node(mat_id, type="INSUMO", description=desc,
                   unit_cost=cost, unit=unit, material_category=category)
    
    # Conexiones ROOT → APU (factor 1.0 preserva estructura)
    for apu in ["APU_A", "APU_B", "APU_C"]:
        G.add_edge("ROOT", apu, quantity=1.0)
    
    # Conexiones APU → Material (multipath)
    edges = [
        ("APU_A", "MAT1", 2.5), ("APU_A", "MAT3", 8.0), ("APU_A", "MAT4", 15.0),
        ("APU_B", "MAT1", 1.0), ("APU_B", "MAT2", 3.0),
        ("APU_C", "MAT3", 5.0), ("APU_C", "MAT5", 2.0),
    ]
    
    for src, dst, qty in edges:
        G.add_edge(src, dst, quantity=qty)
    
    return G

@pytest.fixture
def cyclic_graph(self):
    """
    Grafo con ciclo para validar detección topológica.
    
    Estructura cíclica: A → B → C → A (grupo cíclico Z₃)
    
    Invariante violado: No existe ordenamiento topológico.
    Consecuencia: El grafo NO es un DAG válido.
    """
    G = nx.DiGraph()
    
    nodes = [("A", "APU"), ("B", "APU"), ("C", "APU")]
    for node_id, node_type in nodes:
        G.add_node(node_id, type=node_type, description=f"Nodo {node_id}")
    
    G.add_node("INS", type="INSUMO", unit_cost=10.0, description="Insumo Test")
    
    # Ciclo: A → B → C → A
    G.add_edge("A", "B", quantity=1.0)
    G.add_edge("B", "C", quantity=1.0)
    G.add_edge("C", "A", quantity=1.0)  # Arista que cierra el ciclo
    G.add_edge("A", "INS", quantity=5.0)
    
    return G

def test_materialize_project_structure(self, sample_graph):
    """
    Valida estructura del BOM y coherencia de invariantes.
    
    Verificaciones:
    1. Morfismo de agregación: cantidades propagadas correctamente
    2. Functor de costos: C(q, p) = q × p
    3. Invariantes topológicos preservados en metadata
    """
    generator = MatterGenerator()
    bom = generator.materialize_project(sample_graph)

    # Verificar tipo y cardinalidad
    assert isinstance(bom, BillOfMaterials)
    assert len(bom.requirements) == 2

    # Extraer requerimientos por ID
    req_map = {r.id: r for r in bom.requirements}
    cemento, arena = req_map["INS1"], req_map["INS2"]

    # Validar propagación de cantidades
    assert cemento.quantity_base == pytest.approx(13.0)
    assert arena.quantity_base == pytest.approx(10.0)

    # Validar functor de costos: C = q × p
    assert cemento.total_cost == pytest.approx(13.0 * 100.0)
    assert arena.total_cost == pytest.approx(10.0 * 50.0)

    # Coherencia: ∑costs = total (propiedad aditiva)
    computed_sum = sum(r.total_cost for r in bom.requirements)
    assert bom.total_material_cost == pytest.approx(computed_sum)
    assert bom.total_material_cost == pytest.approx(1800.0)

    # Invariantes topológicos
    topo = bom.metadata["topological_invariants"]
    assert topo["is_dag"] is True
    
    # Métricas estructurales
    assert bom.metadata["graph_metrics"]["node_count"] == 5
    assert bom.metadata["cost_analysis"]["item_count"] == 2
    assert "generation_info" in bom.metadata

def test_apply_entropy_factors_high_risk(self, sample_graph):
    """
    Factores de entropía con métricas adversas.
    
    Composición monoidal (multiplicativa):
    ┌─────────────────────────────────────────────┐
    │ Factor = ∏ᵢ fᵢ(condición)                   │
    │                                             │
    │ f₁(sat > 0.8) = 1.05                        │
    │ f₂(stab < 1.0) = 1.03                       │
    │                                             │
    │ Factor_total = 1.05 × 1.03 = 1.0815         │
    │ Waste = Factor - 1 = 0.0815                 │
    └─────────────────────────────────────────────┘
    """
    generator = MatterGenerator()
    flux_metrics = {
        "avg_saturation": 0.9,      # > 0.8 → ×1.05
        "pyramid_stability": 0.5    # < 1.0 → ×1.03
    }

    bom = generator.materialize_project(sample_graph, flux_metrics=flux_metrics)

    # Cálculo exacto del factor compuesto
    expected_factor = 1.05 * 1.03
    expected_waste = expected_factor - 1.0

    for req in bom.requirements:
        assert req.waste_factor == pytest.approx(expected_waste, rel=1e-3)
        expected_total = req.quantity_base * expected_factor
        assert req.quantity_total == pytest.approx(expected_total, rel=1e-3)

def test_apply_entropy_factors_with_risk_profile(self, sample_graph):
    """
    Perfil de riesgo CRITICAL con factores compuestos.
    
    Composición:
    - Factor base (CRITICAL): 1.15
    - Factor específico (BULKY): 1.02
    - Factor total: 1.15 × 1.02 = 1.173
    """
    generator = MatterGenerator()
    risk_profile = {"level": "CRITICAL"}
    
    bom = generator.materialize_project(sample_graph, risk_profile=risk_profile)

    # Factores esperados
    base_factor = 1.15
    bulky_factor = 1.02
    composite_factor = base_factor * bulky_factor
    
    arena = next(r for r in bom.requirements if r.id == "INS2")
    
    assert arena.waste_factor == pytest.approx(composite_factor - 1.0, rel=1e-3)
    assert arena.quantity_total == pytest.approx(
        arena.quantity_base * composite_factor, rel=1e-3
    )

def test_source_tracking(self, sample_graph):
    """Verifica trazabilidad de APUs origen (preimagen del morfismo)."""
    generator = MatterGenerator()
    bom = generator.materialize_project(sample_graph)

    req_map = {r.id: r for r in bom.requirements}
    
    # INS1: preimagen = {APU1, APU2}
    cemento = req_map["INS1"]
    assert set(cemento.source_apus) == {"APU1", "APU2"}
    assert len(cemento.source_apus) == 2

    # INS2: preimagen = {APU2}
    arena = req_map["INS2"]
    assert set(arena.source_apus) == {"APU2"}
    assert "APU1" not in arena.source_apus

def test_cycle_detection(self, cyclic_graph):
    """
    Rechaza grafos cíclicos (violación de propiedad DAG).
    
    Un ciclo implica que no existe ordenamiento topológico,
    lo cual hace imposible la propagación coherente de cantidades.
    """
    generator = MatterGenerator()

    with pytest.raises(ValueError) as exc_info:
        generator.materialize_project(cyclic_graph)
    
    error_msg = str(exc_info.value).lower()
    cycle_terms = ["ciclo", "cycle", "dag", "acíclic", "topolog"]
    assert any(term in error_msg for term in cycle_terms), \
        f"Mensaje de error no informativo: {exc_info.value}"

def test_complex_graph_clustering(self, complex_graph):
    """
    Validación de agrupación semántica (cociente por equivalencia).
    
    Materiales con múltiples caminos deben consolidarse:
    - MAT1: [APU_A → MAT1] ∪ [APU_B → MAT1] = (2.5 + 1.0) = 3.5
    - MAT3: [APU_A → MAT3] ∪ [APU_C → MAT3] = (8.0 + 5.0) = 13.0
    """
    generator = MatterGenerator()
    bom = generator.materialize_project(complex_graph)
    
    req_map = {r.id: r for r in bom.requirements}
    
    # MAT1: consolidación multipath
    mat1 = req_map["MAT1"]
    assert set(mat1.source_apus) == {"APU_A", "APU_B"}
    assert mat1.quantity_base == pytest.approx(2.5 + 1.0)
    
    # MAT3: consolidación multipath
    mat3 = req_map["MAT3"]
    assert set(mat3.source_apus) == {"APU_A", "APU_C"}
    assert mat3.quantity_base == pytest.approx(8.0 + 5.0)

def test_material_specific_factors(self, complex_graph):
    """
    Factores específicos por categoría (acción del monoide de factores).
    
    Sin factores base, solo factores de categoría:
    - FRAGILE: 1.02 → waste = 0.02
    - HAZARDOUS: 1.06 → waste = 0.06
    - PERISHABLE: 1.04 → waste = 0.04
    """
    generator = MatterGenerator()
    bom = generator.materialize_project(complex_graph)
    
    # Mapeo categoría → (descripción, factor esperado)
    expected = {
        "Vidrio Templado": 0.02,    # FRAGILE
        "Pintura Epóxica": 0.06,    # HAZARDOUS
        "Cemento Rápido": 0.04,     # PERISHABLE
    }
    
    for req in bom.requirements:
        if req.description in expected:
            assert req.waste_factor == pytest.approx(
                expected[req.description], rel=1e-3
            ), f"Factor incorrecto para {req.description}"

def test_pareto_analysis_in_metadata(self, complex_graph):
    """
    Análisis de Pareto en metadata (principio 80/20).
    
    El 20% superior de materiales debe representar
    aproximadamente el 80% del costo total.
    """
    generator = MatterGenerator()
    bom = generator.materialize_project(complex_graph)
    
    pareto_info = bom.metadata["cost_analysis"]["pareto_analysis"]
    
    assert "pareto_20_percent" in pareto_info
    assert "pareto_cost_percentage" in pareto_info
    
    # Tolerancia: ≥70% para cumplimiento aproximado
    assert pareto_info["pareto_cost_percentage"] >= 70.0, \
        f"Pareto insuficiente: {pareto_info['pareto_cost_percentage']}%"

def test_overflow_protection(self):
    """
    Protección contra complejidad computacional excesiva.
    
    Complejidad = |V| × |E|
    Para n=200 insumos: (201 nodos) × (200 aristas) = 40,200 > 10,000
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    
    num_insumos = 200
    for i in range(num_insumos):
        G.add_node(f"INS_{i}", type="INSUMO", 
                   unit_cost=1000.0, description=f"Material_{i}")
        G.add_edge("ROOT", f"INS_{i}", quantity=1000.0)
    
    generator = MatterGenerator(max_graph_complexity=10000)
    
    with pytest.raises(OverflowError, match="complejidad|complexity"):
        generator.materialize_project(G)

def test_kahan_summation_precision(self):
    """
    Precisión numérica con suma compensada (Kahan).
    
    Para n términos pequeños, la suma naive acumula error O(nε).
    Kahan mantiene error O(ε) independiente de n.
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    
    num_materials = 1000
    unit_cost = 0.01  # Valor pequeño para evidenciar errores
    
    for i in range(num_materials):
        G.add_node(f"INS_{i}", type="INSUMO", 
                   unit_cost=unit_cost, description=f"M{i}")
        G.add_edge("ROOT", f"INS_{i}", quantity=1.0)
    
    generator = MatterGenerator()
    bom = generator.materialize_project(G)
    
    expected_cost = num_materials * unit_cost  # 10.0 exacto
    assert bom.total_material_cost == pytest.approx(expected_cost, rel=1e-9)

def test_bom_internal_consistency(self, sample_graph):
    """
    Coherencia interna del BOM (invariante de suma).
    
    Propiedad: total_material_cost = Σᵢ requirements[i].total_cost
    """
    generator = MatterGenerator()
    bom = generator.materialize_project(sample_graph)
    
    # Verificar coherencia natural
    computed_total = sum(req.total_cost for req in bom.requirements)
    assert bom.total_material_cost == pytest.approx(computed_total, rel=1e-9)
    
    # Verificar que la validación detecte inconsistencias
    corrupted_bom = generator.materialize_project(sample_graph)
    corrupted_bom.total_material_cost = 9999.0  # Corrupción intencional
    
    with pytest.raises(ValueError, match="[Ii]nconsist"):
        corrupted_bom.validate_consistency()

def test_robustness_random_graph(self):
    """
    Robustez con DAG aleatorio (semilla fija para reproducibilidad).
    
    Garantiza que el generador maneje estructuras no triviales
    sin lanzar excepciones inesperadas.
    """
    seed = 42  # Semilla determinista
    rng = random.Random(seed)
    
    # Crear DAG aleatorio con ordenamiento topológico implícito
    G = nx.gnp_random_graph(50, 0.1, directed=True, seed=seed)
    G = nx.DiGraph([(u, v) for (u, v) in G.edges() if u < v])
    
    # Asignar atributos
    for node in G.nodes():
        if rng.random() > 0.7:
            G.nodes[node].update({
                'type': 'INSUMO',
                'unit_cost': rng.uniform(1.0, 1000.0),
                'description': f"Material_{node}",
                'unit': rng.choice(['kg', 'm', 'm2', 'm3'])
            })
        else:
            G.nodes[node].update({
                'type': 'APU',
                'description': f"APU_{node}"
            })
    
    for u, v in G.edges():
        G.edges[u, v]['quantity'] = rng.uniform(0.1, 10.0)
    
    generator = MatterGenerator()
    bom = generator.materialize_project(G)
    
    assert isinstance(bom, BillOfMaterials)
    assert bom.metadata["topological_invariants"]["is_dag"] is True

def test_custom_max_complexity(self):
    """
    Límite de complejidad configurable.
    
    Para 50 insumos: (51 nodos) × (50 aristas) = 2,550 > 100
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    
    for i in range(50):
        G.add_node(f"INS_{i}", type="INSUMO", 
                   unit_cost=10.0, description=f"M{i}")
        G.add_edge("ROOT", f"INS_{i}", quantity=1.0)
    
    generator = MatterGenerator(max_graph_complexity=100)
    
    with pytest.raises(OverflowError, match="complejidad|complexity"):
        generator.materialize_project(G)

def test_material_requirement_ordering(self, complex_graph):
    """
    Ordenamiento por costo descendente (estructura de orden total).
    
    Propiedad: ∀i < j: costs[i] ≥ costs[j]
    """
    generator = MatterGenerator()
    bom = generator.materialize_project(complex_graph)
    
    costs = [req.total_cost for req in bom.requirements]
    
    # Verificar propiedad de orden
    for i in range(len(costs) - 1):
        assert costs[i] >= costs[i + 1], \
            f"Violación de orden en [{i}]={costs[i]:.2f} < [{i+1}]={costs[i+1]:.2f}"
    
    # El máximo está en la cabeza
    assert bom.requirements[0].total_cost == pytest.approx(max(costs))

def test_error_recovery_and_logging(self, caplog):
    """
    Recuperación ante datos inválidos con logging diagnóstico.
    
    El sistema debe:
    1. Registrar advertencias para valores inválidos
    2. Continuar procesando materiales válidos
    """
    # Grafo aislado (no modificar fixtures)
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    G.add_node("INVALID", type="INSUMO", unit_cost=-50.0, description="Inválido")
    G.add_node("VALID", type="INSUMO", unit_cost=100.0, description="Válido")
    G.add_edge("ROOT", "INVALID", quantity=5.0)
    G.add_edge("ROOT", "VALID", quantity=3.0)
    
    caplog.set_level(logging.WARNING)
    
    generator = MatterGenerator()
    bom = generator.materialize_project(G)
    
    # Verificar logging de advertencia
    warning_terms = ["negativ", "invalid", "inválid", "omit", "skip"]
    warning_found = any(
        any(term in record.message.lower() for term in warning_terms)
        for record in caplog.records
    )
    assert warning_found, "No se registró advertencia para costo negativo"
    
    # Procesamiento continúa con válidos
    assert len(bom.requirements) >= 1
    valid_ids = {r.id for r in bom.requirements}
    assert "VALID" in valid_ids

def test_deterministic_output(self, sample_graph):
    """
    Determinismo: f(x) = f(x) para toda entrada x.
    
    Múltiples ejecuciones con la misma entrada deben
    producir resultados idénticos (excepto timestamps).
    """
    generator = MatterGenerator()
    
    bom1 = generator.materialize_project(sample_graph)
    bom2 = generator.materialize_project(sample_graph)
    
    assert len(bom1.requirements) == len(bom2.requirements)
    
    for r1, r2 in zip(bom1.requirements, bom2.requirements):
        assert r1.id == r2.id
        assert r1.quantity_base == pytest.approx(r2.quantity_base)
        assert r1.waste_factor == pytest.approx(r2.waste_factor)
        assert r1.total_cost == pytest.approx(r2.total_cost)
    
    # Metadata estructural idéntica
    invariant_keys = ["topological_invariants", "graph_metrics", "cost_analysis"]
    for key in invariant_keys:
        assert bom1.metadata[key] == bom2.metadata[key]

def test_flux_metrics_no_adjustment(self):
    """
    Métricas de flujo en rango seguro (sin ajustes).
    
    Condiciones que NO activan factores:
    - avg_saturation < 0.8
    - pyramid_stability ≥ 1.0
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    G.add_node("INS", type="INSUMO", unit_cost=100.0, description="Material")
    G.add_edge("ROOT", "INS", quantity=1.0)
    
    flux_metrics = {
        "avg_saturation": 0.5,      # < 0.8 → sin ajuste
        "pyramid_stability": 1.2    # ≥ 1.0 → sin ajuste
    }
    
    generator = MatterGenerator()
    bom = generator.materialize_project(G, flux_metrics=flux_metrics)
    
    req = bom.requirements[0]
    assert req.waste_factor == pytest.approx(0.0)
    assert req.quantity_total == pytest.approx(req.quantity_base)

def test_performance_small_graph(self):
    """
    Benchmark de rendimiento para grafos moderados.
    
    Requisito: 100 materiales procesados en < 1 segundo.
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    
    for i in range(100):
        G.add_node(f"INS_{i}", type="INSUMO", 
                   unit_cost=float(i + 1), description=f"M{i}")
        G.add_edge("ROOT", f"INS_{i}", quantity=float(i + 1))
    
    generator = MatterGenerator()
    
    start = time.perf_counter()
    bom = generator.materialize_project(G)
    elapsed = time.perf_counter() - start
    
    assert elapsed < 1.0, f"Rendimiento insuficiente: {elapsed:.3f}s"
    assert len(bom.requirements) == 100

def test_identical_materials_different_units(self):
    """
    Materiales con mismo nombre pero diferente unidad son distintos.
    
    La unidad forma parte de la identidad del material
    (no se pueden sumar kg con lb directamente).
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    
    G.add_node("MAT_KG", type="INSUMO", description="Material Base", 
               unit_cost=10.0, unit="kg")
    G.add_node("MAT_LB", type="INSUMO", description="Material Base", 
               unit_cost=8.0, unit="lb")
    
    G.add_edge("ROOT", "MAT_KG", quantity=2.0)
    G.add_edge("ROOT", "MAT_LB", quantity=5.0)
    
    generator = MatterGenerator()
    bom = generator.materialize_project(G)
    
    assert len(bom.requirements) == 2
    units = {req.unit for req in bom.requirements}
    assert units == {"kg", "lb"}

def test_edge_case_infinite_values(self):
    """
    Valores infinitos son rechazados (no pertenecen a ℝ finito).
    """
    G = nx.DiGraph()
    G.add_node("ROOT", type="ROOT")
    G.add_node("INF", type="INSUMO", 
               unit_cost=float('inf'), description="Infinito")
    G.add_edge("ROOT", "INF", quantity=1.0)
    
    generator = MatterGenerator()
    bom = generator.materialize_project(G)
    
    # Material con infinito debe ser omitido
    assert len(bom.requirements) == 0
    assert math.isfinite(bom.total_material_cost)

