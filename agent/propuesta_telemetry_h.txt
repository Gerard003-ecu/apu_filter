#ifndef TELEMETRY_H
#define TELEMETRY_H

/**
 * ARQUITECTURA DE GEMELO DIGITAL (C++ MIRROR V4.6)
 * =================================================
 * Proyección refinada del Espacio Vectorial de Estado definido en Python.
 * Target: ESP32 (Xtensa LX6 / LX7), compilado desde Linux Mint.
 *
 * V4.6 — Refinamiento de V4.5:
 * ---------------------------------------------------------------------------
 * [Seguridad]      PoleContainer::operator[] ahora verifica límites con
 *                  el mismo contrato seguro que at().
 * [Salud]          calculateHealthScore(): control incoherente penalizado
 *                  simétricamente con HEALTH_INCOHERENCE_PENALTY aunque
 *                  is_stable sea true.
 * [Física]         naturalFrequencyApprox(): retorna 0 para polo dominante
 *                  no-negativo (sistema inestable — ωₙ sin sentido físico).
 * [Config]         ENTROPY_NORMALIZATION_FACTOR centralizado en
 *                  TelemetryConfig; eliminada constante mágica 10.0f.
 * [Control]        enforceCoherence(): si no hay polos, lyapunov_exponent
 *                  se usa para derivar is_stable, cerrando el invariante 2.
 * [Topología]      mayer_vietoris_delta acotado por totalBetti() en fromJson.
 * [Rendimiento]    telemetry_strlcpy usa __builtin_strlen en plataformas GCC
 *                  (ESP32/Xtensa) para aprovechar optimización HW/compilador.
 * [Performance]    TelemetryPacket::systemHealth() reutiliza resultado de
 *                  isIntraCoherent() evitando doble cómputo.
 * [Diagnóstico]    fullIntegrityCheck() verifica finitud de lyapunov_exponent
 *                  y que poleCount() sea consistente.
 * [Documentación]  Invariantes actualizados. Constantes mágicas eliminadas.
 *                  Precondiciones explícitas en cada método público.
 */

#include <Arduino.h>
#include <ArduinoJson.h>
#include <cstdint>
#include <limits>
#include <cmath>
#include <array>
#include <algorithm>

// ============================================================================
// COMPATIBILIDAD DE PLATAFORMA
// ============================================================================

/**
 * Copia segura de cadena con garantía de terminación nula.
 *
 * Reemplaza strlcpy (POSIX, no disponible en todas las plataformas
 * Arduino/MSVC). Se define siempre bajo nombre propio para evitar
 * conflictos de redefinición con implementaciones del sistema.
 *
 * Optimización: En plataformas GCC (ESP32/Xtensa, AVR, ARM),
 * __builtin_strlen es evaluado en tiempo de compilación para literales
 * y traducido a instrucción HW para strings en RAM, siendo más eficiente
 * que el loop manual. El loop de copia permanece explícito para control
 * total del comportamiento en plataformas sin libc.
 *
 * @param dst   Buffer destino (no nulo, tamaño ≥ size)
 * @param src   Cadena fuente (no nula, terminada en '\0')
 * @param size  Tamaño total del buffer destino (incluyendo '\0')
 * @return      Longitud de src (permite detectar truncamiento: ret ≥ size)
 */
inline size_t telemetry_strlcpy(char* dst,
                                 const char* src,
                                 size_t size) noexcept
{
    if (size == 0u) { return 0u; }

    // Longitud de src: usa builtin cuando está disponible (GCC/Clang),
    // cae a loop manual en MSVC u otras plataformas.
#if defined(__GNUC__) || defined(__clang__)
    const size_t src_len = __builtin_strlen(src);
#else
    size_t src_len = 0u;
    while (src[src_len] != '\0') { ++src_len; }
#endif

    const size_t copy_len = (src_len < size - 1u) ? src_len : (size - 1u);
    for (size_t i = 0u; i < copy_len; ++i) {
        dst[i] = src[i];
    }
    dst[copy_len] = '\0';
    return src_len;  // igual que strlcpy POSIX: retorna longitud de src
}

// ============================================================================
// UTILIDADES MATEMÁTICAS
// ============================================================================
namespace TelemetryUtils {

    /**
     * Restricción de valor al intervalo cerrado [lo, hi].
     * Implementación constexpr para evaluación en tiempo de compilación.
     *
     * Precondición: lo ≤ hi
     */
    template<typename T>
    [[nodiscard]] constexpr T clamp(T val, T lo, T hi) noexcept {
        return (val < lo) ? lo : ((val > hi) ? hi : val);
    }

    /**
     * Verifica que el valor sea finito (ni ±∞ ni NaN).
     * Robusto frente a representaciones IEEE 754 no estándar.
     */
    [[nodiscard]] inline bool isFinite(float v) noexcept {
        return std::isfinite(v);
    }

    /**
     * Sanitiza valores no finitos reemplazándolos por fallback.
     * Garantiza que el resultado siempre sea un float válido y finito.
     *
     * @param v        Valor a sanitizar
     * @param fallback Valor de reemplazo (debe ser finito)
     */
    [[nodiscard]] inline float sanitize(float v,
                                        float fallback = 0.0f) noexcept
    {
        return isFinite(v) ? v : fallback;
    }

    /**
     * Lectura segura de float desde JSON con sanitización automática.
     * Compatible con ArduinoJson v6 y v7.
     *
     * Si la clave no existe o el valor es no-finito, retorna defaultVal.
     */
    [[nodiscard]] inline float readFloat(const JsonObjectConst& obj,
                                         const char* key,
                                         float defaultVal = 0.0f) noexcept
    {
        const float raw = obj[key] | defaultVal;
        return sanitize(raw, defaultVal);
    }

    /**
     * Lectura segura de entero desde JSON.
     * Si la clave no existe, retorna defaultVal.
     */
    [[nodiscard]] inline int32_t readInt(const JsonObjectConst& obj,
                                         const char* key,
                                         int32_t defaultVal = 0) noexcept
    {
        return obj[key] | defaultVal;
    }

    /**
     * Signo de un valor escalar: retorna −1, 0 o +1.
     * Implementación sin branching para tipos ordenados.
     */
    template<typename T>
    [[nodiscard]] constexpr int sgn(T val) noexcept {
        return static_cast<int>(T(0) < val) - static_cast<int>(val < T(0));
    }

    /**
     * Comparación con tolerancia híbrida para floats IEEE 754.
     *
     * Estrategia: tolerance = max(absTol, relTol · max(|a|, |b|))
     *
     * Maneja correctamente:
     * - Valores cercanos a cero  → domina absTol
     * - Valores de magnitud alta → domina relTol
     *
     * @param a      Primer valor
     * @param b      Segundo valor
     * @param relTol Tolerancia relativa  (default 1e-5)
     * @param absTol Tolerancia absoluta  (default 1e-8)
     */
    [[nodiscard]] inline bool approxEqual(float a, float b,
                                          float relTol = 1e-5f,
                                          float absTol = 1e-8f) noexcept
    {
        const float diff      = std::fabs(a - b);
        const float maxAbs    = std::fmax(std::fabs(a), std::fabs(b));
        const float tolerance = std::fmax(absTol, relTol * maxAbs);
        return diff <= tolerance;
    }

    /**
     * Interpolación lineal: lerp(a, b, t) = a + t·(b − a)
     * Para t ∈ [0, 1]: resultado ∈ [a, b].
     */
    [[nodiscard]] constexpr float lerp(float a, float b, float t) noexcept {
        return a + t * (b - a);
    }

    /**
     * Mapeo suave sigmoidal al intervalo (−1, 1):  x / (|x| + k)
     * Útil para normalizar señales con rango teóricamente ilimitado.
     *
     * @param x Valor de entrada
     * @param k Parámetro de escala (k > 0 controla la pendiente en el origen)
     */
    [[nodiscard]] inline float softNormalize(float x, float k = 1.0f) noexcept {
        if (k <= 0.0f) { k = 1.0f; }
        return x / (std::fabs(x) + k);
    }

    /**
     * Diferencia absoluta entre dos enteros con signo, sin overflow.
     *
     * Evita el uso de std::abs<int> que no está garantizado en todas
     * las implementaciones de Arduino/avr-libc. El resultado es uint32_t
     * para poder representar |INT32_MIN - INT32_MAX| sin overflow.
     *
     * Precondición: ninguna (maneja todo el rango de int32_t).
     */
    [[nodiscard]] inline uint32_t absDiff(int32_t a, int32_t b) noexcept {
        return (a >= b)
            ? static_cast<uint32_t>(a - b)
            : static_cast<uint32_t>(b - a);
    }

} // namespace TelemetryUtils

// ============================================================================
// ENUMERACIONES TIPADAS
// ============================================================================

/**
 * Código de veredicto del sistema.
 * Representa el estado categórico determinado por el oráculo.
 *
 * NOTA: UNKNOWN = 255 es deliberado para detectar corrupción de memoria
 * (cualquier valor de byte distinto de 0, 1, 2 cae en UNKNOWN).
 */
enum class VerdictCode : uint8_t {
    OK       = 0,   ///< Sistema operando nominalmente
    WARN     = 1,   ///< Degradación detectada, requiere atención
    CRITICAL = 2,   ///< Estado crítico, acción inmediata requerida
    UNKNOWN  = 255  ///< Estado no determinado (datos insuficientes)
};

/**
 * Códigos de error del sistema de telemetría.
 * Ordenados por gravedad creciente.
 */
enum class TelemetryError : uint8_t {
    OK                    = 0,  ///< Sin error
    EMPTY_INPUT           = 1,  ///< Entrada JSON vacía
    JSON_PARSE_ERROR      = 2,  ///< Error de sintaxis JSON
    JSON_OVERFLOW         = 3,  ///< Buffer JSON insuficiente (ArduinoJson v6)
    COHERENCE_VIOLATION   = 4,  ///< Violación de invariantes internos
    TOPOLOGICAL_ANOMALY   = 5,  ///< Inconsistencia topológica detectada
    THERMODYNAMIC_ANOMALY = 6   ///< Violación de leyes termodinámicas
};

/**
 * Estado de salud categórico del sistema.
 */
enum class SystemHealth : uint8_t {
    NOMINAL   = 0,   ///< Operación normal
    DEGRADED  = 1,   ///< Capacidad reducida
    CRITICAL  = 2,   ///< Fallo inminente o activo
    UNDEFINED = 255  ///< No determinable
};

// ============================================================================
// CONFIGURACIÓN CENTRALIZADA
// ============================================================================
namespace TelemetryConfig {

    // ─────────────────────────────────────────────────────────────────────────
    // Tamaños de buffer
    // ─────────────────────────────────────────────────────────────────────────
    static constexpr size_t JSON_BUFFER_SIZE  = 4096u;
    static constexpr size_t MAX_POLES         = 20u;
    static constexpr size_t NARRATIVE_MAX_LEN = 64u;
    static constexpr size_t TIMESTAMP_MAX_LEN = 32u;

    // ─────────────────────────────────────────────────────────────────────────
    // Tolerancias numéricas
    // ─────────────────────────────────────────────────────────────────────────

    /// Umbral para considerar Re(polo) ≈ 0 (zona frontera de estabilidad)
    static constexpr float STABILITY_EPS     = 1e-9f;
    /// Tolerancia de conservación energética (5 %)
    static constexpr float ENERGY_TOLERANCE  = 0.05f;
    /// Tolerancia de producción entrópica (10 %)
    static constexpr float ENTROPY_TOLERANCE = 0.10f;
    /// Umbral para considerar λ₂ ≈ 0 (grafo en frontera de conectividad)
    static constexpr float FIEDLER_EPS       = 1e-6f;

    // ─────────────────────────────────────────────────────────────────────────
    // Límites físicos
    // ─────────────────────────────────────────────────────────────────────────
    static constexpr float MIN_TEMPERATURE_K = 0.0f;      ///< Cero absoluto [K]
    static constexpr float MAX_TEMPERATURE_K = 1.0e6f;    ///< Límite práctico [K]
    static constexpr float MIN_INERTIA       = 1.0e-6f;   ///< Inercia mínima válida
    static constexpr float MIN_ENERGY        = 1.0e-12f;  ///< Energía mínima para ratios

    // ─────────────────────────────────────────────────────────────────────────
    // Límites topológicos
    // ─────────────────────────────────────────────────────────────────────────
    static constexpr int32_t MAX_BETTI_NUMBER = 1000;  ///< Cota práctica para βₖ
    static constexpr float   MAX_SPECTRAL_GAP = 2.0f;  ///< Máximo λ₂ normalizado

    // ─────────────────────────────────────────────────────────────────────────
    // Límites de control
    // ─────────────────────────────────────────────────────────────────────────
    static constexpr float MIN_PHASE_MARGIN  = -180.0f; ///< [grados]
    static constexpr float MAX_PHASE_MARGIN  =  180.0f; ///< [grados]
    static constexpr float MIN_DAMPING       =    0.0f; ///< Sin amortiguamiento
    static constexpr float MAX_DAMPING       =   10.0f; ///< Sobreamortiguamiento extremo
    static constexpr float OPTIMAL_DAMPING   =  0.707f; ///< ζ Butterworth (1/√2)

    /// Margen de fase de referencia para normalización [grados]
    static constexpr float PHASE_MARGIN_REFERENCE = 60.0f;

    // ─────────────────────────────────────────────────────────────────────────
    // Pesos para índice de salud (INVARIANTE: deben sumar exactamente 1.0)
    // ─────────────────────────────────────────────────────────────────────────
    static constexpr float HEALTH_WEIGHT_PHYSICS  = 0.25f;
    static constexpr float HEALTH_WEIGHT_TOPOLOGY = 0.20f;
    static constexpr float HEALTH_WEIGHT_CONTROL  = 0.35f;
    static constexpr float HEALTH_WEIGHT_THERMO   = 0.20f;

    // Verificación estática: los pesos deben sumar 1.0
    // (la suma exacta en float puede diferir por epsilon de FP, usamos
    //  un rango conservador; el assert documenta la intención.)
    static_assert(
        HEALTH_WEIGHT_PHYSICS + HEALTH_WEIGHT_TOPOLOGY +
        HEALTH_WEIGHT_CONTROL + HEALTH_WEIGHT_THERMO > 0.99f &&
        HEALTH_WEIGHT_PHYSICS + HEALTH_WEIGHT_TOPOLOGY +
        HEALTH_WEIGHT_CONTROL + HEALTH_WEIGHT_THERMO < 1.01f,
        "Los pesos de salud deben sumar 1.0 (margen ±0.01)"
    );

    // ─────────────────────────────────────────────────────────────────────────
    // Umbrales de clasificación de salud
    // ─────────────────────────────────────────────────────────────────────────
    static constexpr float HEALTH_NOMINAL_THRESHOLD  = 0.70f;
    static constexpr float HEALTH_DEGRADED_THRESHOLD = 0.40f;

    /// Techo del índice de salud cuando el sistema es incoherente
    static constexpr float HEALTH_INCOHERENT_CEILING = 0.50f;

    /**
     * Factor de penalización para estrato que falla coherencia interna.
     * Valor ∈ (0, 1): penaliza sin colapsar completamente el subpuntaje.
     */
    static constexpr float HEALTH_INCOHERENCE_PENALTY = 0.5f;

    /**
     * Factor de normalización de entropía para penalización termodinámica.
     *
     * La penalización entrópica en calculateHealthScore() es:
     *   penalty = clamp(S / ENTROPY_NORMALIZATION_FACTOR, 0, 1)
     *
     * Valor = 10.0 [J/K]: entropía a la que la penalización satura al 100%.
     * Ajustar según el rango de entropía esperado en el sistema modelado.
     */
    static constexpr float ENTROPY_NORMALIZATION_FACTOR = 10.0f;

    /**
     * Piso mínimo de conectividad algebraica en el puntaje topológico.
     *
     * Evita que grafos con λ₂ → 0 (pero coherentes) colapsen el subpuntaje
     * topológico a cero, ya que pyramid_stability puede ser positiva.
     */
    static constexpr float TOPOLOGY_CONNECTIVITY_FLOOR = 0.1f;

    /**
     * Coeficiente de penalización entrópica en la componente termodinámica.
     * 0.5 → alta entropía degrada al 50% pero no anula la salud térmica.
     */
    static constexpr float THERMO_ENTROPY_PENALTY_COEF = 0.5f;

} // namespace TelemetryConfig

// ============================================================================
// CONTENEDOR DE POLOS (Espacio Vectorial Finito-Dimensional ℝⁿ)
// ============================================================================
/**
 * Representa un subespacio del plano complejo restringido a la recta real.
 * Diseñado para análisis de estabilidad BIBO/Lyapunov de sistemas LTI.
 *
 * Propiedades algebraicas implementadas:
 * - Norma L∞  (polo dominante por magnitud)
 * - Norma L²  (norma euclidiana)
 * - Polo dominante (máxima parte real → determina estabilidad asintótica)
 * - Estadísticas descriptivas: centroide, varianza muestral corregida
 *
 * Invariantes mantenidos en todo momento:
 * - ∀ i < size_: data_[i] es finito (garantizado por sanitización en push/set)
 * - size_ ≤ capacity() = MAX_POLES
 * - data_[i] = 0.0f para i ≥ size_ (limpieza en clear())
 *
 * Contratos de acceso:
 * - at(i):         acceso seguro — retorna 0.0f si i ≥ size_
 * - operator[](i): acceso seguro — mismo contrato que at() en V4.6
 *                  (corregido: V4.5 tenía UB para i ≥ size_)
 */
class PoleContainer {
public:
    using ContainerType  = std::array<float, TelemetryConfig::MAX_POLES>;
    using const_iterator = ContainerType::const_iterator;

    PoleContainer() noexcept { clear(); }

    explicit PoleContainer(size_t initial_size) noexcept {
        clear();
        size_ = std::min(initial_size, TelemetryConfig::MAX_POLES);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Gestión del contenedor
    // ─────────────────────────────────────────────────────────────────────────

    /** Resetea a estado vacío. Limpia todos los datos subyacentes. */
    void clear() noexcept {
        data_.fill(0.0f);
        size_ = 0u;
    }

    [[nodiscard]] size_t size()     const noexcept { return size_; }
    [[nodiscard]] size_t capacity() const noexcept { return TelemetryConfig::MAX_POLES; }
    [[nodiscard]] bool   empty()    const noexcept { return size_ == 0u; }
    [[nodiscard]] bool   full()     const noexcept { return size_ >= TelemetryConfig::MAX_POLES; }

    /**
     * Acceso de solo lectura con verificación de límites.
     *
     * @param index Índice del polo solicitado
     * @return data_[index] si index < size(), o 0.0f en caso contrario.
     *
     * Postcondición: el valor retornado es siempre finito.
     */
    [[nodiscard]] float at(size_t index) const noexcept {
        return (index < size_) ? data_[index] : 0.0f;
    }

    /**
     * Acceso directo con verificación de límites.
     *
     * CORRECCIÓN V4.6: en V4.5 este operador accedía a data_[index]
     * sin verificar límites, produciendo UB para index ≥ size_.
     * Ahora delega a at() con el mismo contrato seguro.
     *
     * Nota: no se declara acceso "raw" sin verificación en la interfaz
     * pública para mantener el invariante de seguridad de memoria.
     *
     * @param index Índice del polo solicitado
     * @return data_[index] si index < size(), o 0.0f en caso contrario.
     */
    [[nodiscard]] float operator[](size_t index) const noexcept {
        return at(index);
    }

    /**
     * Actualiza un elemento existente con sanitización automática.
     *
     * Precondición: index < size()
     * @return true si la escritura fue exitosa; false si index ≥ size().
     */
    [[nodiscard]] bool set(size_t index, float value) noexcept {
        if (index >= size_) { return false; }
        data_[index] = TelemetryUtils::sanitize(value);
        return true;
    }

    /**
     * Añade un polo al final del contenedor (con sanitización).
     *
     * @return true si se añadió; false si el contenedor está lleno.
     * Postcondición: el valor almacenado es finito.
     */
    [[nodiscard]] bool push_back(float value) noexcept {
        if (full()) { return false; }
        data_[size_++] = TelemetryUtils::sanitize(value);
        return true;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Operaciones algebraicas sobre ℝⁿ
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Norma L∞: max { |pᵢ| : i < size_ }
     * Magnitud del polo más alejado del origen.
     *
     * @return norma L∞ ≥ 0; 0.0 para contenedor vacío.
     */
    [[nodiscard]] float normLInf() const noexcept {
        float maxAbs = 0.0f;
        for (size_t i = 0u; i < size_; ++i) {
            const float a = std::fabs(data_[i]);
            if (a > maxAbs) { maxAbs = a; }
        }
        return maxAbs;
    }

    /**
     * Norma L²: √(Σ pᵢ²)
     * Norma euclidiana del vector de polos.
     *
     * @return norma L² ≥ 0; 0.0 para contenedor vacío.
     */
    [[nodiscard]] float normL2() const noexcept {
        float sumSq = 0.0f;
        for (size_t i = 0u; i < size_; ++i) {
            sumSq += data_[i] * data_[i];
        }
        return std::sqrt(sumSq);
    }

    /**
     * Polo dominante: max { Re(pᵢ) } = max { pᵢ } (polos reales).
     *
     * Teorema de estabilidad LTI:
     *   Sistema asintóticamente estable ⟺ dominant() < 0
     *
     * @return polo dominante, o quiet_NaN() si el contenedor está vacío.
     */
    [[nodiscard]] float dominant() const noexcept {
        if (empty()) { return std::numeric_limits<float>::quiet_NaN(); }
        float maxRe = data_[0];
        for (size_t i = 1u; i < size_; ++i) {
            if (data_[i] > maxRe) { maxRe = data_[i]; }
        }
        return maxRe;
    }

    /**
     * Polo más estable: min { Re(pᵢ) }
     * Modo con decaimiento más rápido.
     *
     * @return polo más estable, o quiet_NaN() si el contenedor está vacío.
     */
    [[nodiscard]] float mostStable() const noexcept {
        if (empty()) { return std::numeric_limits<float>::quiet_NaN(); }
        float minRe = data_[0];
        for (size_t i = 1u; i < size_; ++i) {
            if (data_[i] < minRe) { minRe = data_[i]; }
        }
        return minRe;
    }

    /**
     * Centroide: (1/n) Σ pᵢ
     * "Centro de masa" del espectro de polos.
     *
     * @return centroide; 0.0 para contenedor vacío.
     */
    [[nodiscard]] float centroid() const noexcept {
        if (empty()) { return 0.0f; }
        float sum = 0.0f;
        for (size_t i = 0u; i < size_; ++i) { sum += data_[i]; }
        return sum / static_cast<float>(size_);
    }

    /**
     * Varianza muestral con corrección de Bessel (divisor n − 1).
     * Estimador insesgado de la varianza poblacional.
     *
     * @return varianza ≥ 0; 0.0 si size_ < 2.
     */
    [[nodiscard]] float variance() const noexcept {
        if (size_ < 2u) { return 0.0f; }
        const float mean = centroid();
        float sumSqDiff  = 0.0f;
        for (size_t i = 0u; i < size_; ++i) {
            const float d = data_[i] - mean;
            sumSqDiff += d * d;
        }
        return sumSqDiff / static_cast<float>(size_ - 1u);
    }

    /**
     * Cuenta polos inestables: |{ pᵢ : pᵢ > eps }|
     *
     * Sistema BIBO estable ⟺ countUnstable() == 0
     *
     * @param eps Umbral de estabilidad (default: STABILITY_EPS)
     */
    [[nodiscard]] size_t countUnstable(
        float eps = TelemetryConfig::STABILITY_EPS) const noexcept
    {
        size_t count = 0u;
        for (size_t i = 0u; i < size_; ++i) {
            if (data_[i] > eps) { ++count; }
        }
        return count;
    }

    /**
     * Verifica estabilidad de todos los polos.
     *
     * Un contenedor vacío se considera estable (no hay modos inestables).
     * @param eps Umbral de estabilidad (default: STABILITY_EPS)
     */
    [[nodiscard]] bool allStable(
        float eps = TelemetryConfig::STABILITY_EPS) const noexcept
    {
        return countUnstable(eps) == 0u;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Iteradores (solo lectura)
    // ─────────────────────────────────────────────────────────────────────────
    [[nodiscard]] const_iterator begin()  const noexcept { return data_.begin(); }
    [[nodiscard]] const_iterator end()    const noexcept { return data_.begin() + size_; }
    [[nodiscard]] const_iterator cbegin() const noexcept { return begin(); }
    [[nodiscard]] const_iterator cend()   const noexcept { return end(); }

    /// Puntero al arreglo subyacente (solo lectura)
    [[nodiscard]] const float* data() const noexcept { return data_.data(); }

private:
    ContainerType data_{};
    size_t        size_{0u};
};

// ============================================================================
// 1. ESTRATO FÍSICO (FluxCondenser)
// ============================================================================
/**
 * Métricas del dominio físico-energético.
 *
 * Fundamentos:
 * - Hamiltoniano: H = T + V  (T: cinética, V: potencial)
 * - Segunda Ley: P_diss ≥ 0  (disipación irreversible)
 * - Energía cinética definida positiva: T ≥ 0
 * - Índice giroscópico: σ_gyr ∈ [0, 2]
 *
 * Invariantes mantenidos en todo momento:
 * 1. kinetic_energy   ≥ 0
 * 2. dissipated_power ≥ 0
 * 3. |ΔH| ≤ ε · max(|H|, 1)   (conservación aproximada)
 * 4. gyroscopic_stability ∈ [0, 2]
 */
struct PhysicsMetrics {
    float saturation{0.0f};           ///< [0, 1]  Saturación magnética/capacitiva
    float pressure{0.0f};             ///< Presión generalizada del sistema
    float kinetic_energy{0.0f};       ///< T [J]:  Energía cinética ≥ 0
    float potential_energy{0.0f};     ///< V [J]:  Energía potencial (puede ser < 0)
    float flyback_voltage{0.0f};      ///< Voltaje de retroceso inductivo
    float dissipated_power{0.0f};     ///< P_diss ≥ 0 (irreversibilidad)
    float gyroscopic_stability{1.0f}; ///< σ_gyr ∈ [0, 2]
    float poynting_flux{0.0f};        ///< Flujo de energía electromagnética
    float hamiltonian_excess{0.0f};   ///< ΔH: desviación del Hamiltoniano conservado

    // ─────────────────────────────────────────────────────────────────────────
    // Métricas derivadas
    // ─────────────────────────────────────────────────────────────────────────

    /** Hamiltoniano total: H = T + V */
    [[nodiscard]] float totalEnergy() const noexcept {
        return kinetic_energy + potential_energy;
    }

    /**
     * Ratio de disipación: P_diss / |H|
     *
     * Fracción de energía total perdida por disipación.
     * No está acotado superiormente (puede ser > 1 para sistemas
     * en régimen transitorio con alta disipación y baja energía total).
     *
     * @return ratio ≥ 0; 0.0 si |H| < MIN_ENERGY.
     */
    [[nodiscard]] float dissipationRatio() const noexcept {
        const float absE = std::fabs(totalEnergy());
        return (absE > TelemetryConfig::MIN_ENERGY)
               ? (dissipated_power / absE)
               : 0.0f;
    }

    /**
     * Eficiencia energética: 1 − min(dissipationRatio(), 1)
     * Acotada a [0, 1] para interpretación porcentual.
     *
     * @return eficiencia ∈ [0, 1]
     */
    [[nodiscard]] float efficiency() const noexcept {
        return TelemetryUtils::clamp(1.0f - dissipationRatio(), 0.0f, 1.0f);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Parseo y validación
    // ─────────────────────────────────────────────────────────────────────────

    /** Parsea y sanitiza métricas desde objeto JSON. */
    void fromJson(const JsonObjectConst& obj) noexcept {
        if (obj.isNull()) { return; }
        using namespace TelemetryUtils;

        saturation = clamp(
            readFloat(obj, "saturation", 0.0f), 0.0f, 1.0f
        );
        pressure             = readFloat(obj, "pressure",             0.0f);
        kinetic_energy       = std::fmax(0.0f,
                               readFloat(obj, "kinetic_energy",       0.0f));
        potential_energy     = readFloat(obj, "potential_energy",     0.0f);
        flyback_voltage      = readFloat(obj, "flyback_voltage",      0.0f);
        dissipated_power     = std::fmax(0.0f,
                               readFloat(obj, "dissipated_power",     0.0f));
        gyroscopic_stability = clamp(
            readFloat(obj, "gyroscopic_stability", 1.0f), 0.0f, 2.0f
        );
        poynting_flux        = readFloat(obj, "poynting_flux",        0.0f);
        hamiltonian_excess   = readFloat(obj, "hamiltonian_excess",   0.0f);
    }

    /**
     * Verifica coherencia de invariantes físicos.
     *
     * Invariantes verificados:
     * 1. T ≥ 0            (energía cinética no negativa)
     * 2. P_diss ≥ 0       (Segunda Ley de la Termodinámica)
     * 3. |ΔH| ≤ ε · max(|H|, 1)  (conservación aproximada del Hamiltoniano)
     * 4. σ_gyr ∈ [0, 2]   (índice giroscópico en rango válido)
     *
     * @param tolerance Factor de tolerancia para Inv. 3 (default: ENERGY_TOLERANCE)
     */
    [[nodiscard]] bool isCoherent(
        float tolerance = TelemetryConfig::ENERGY_TOLERANCE) const noexcept
    {
        if (kinetic_energy   < 0.0f) { return false; }  // Inv. 1
        if (dissipated_power < 0.0f) { return false; }  // Inv. 2

        // Inv. 3: Hamiltoniano aproximadamente conservado
        const float denom = std::fmax(std::fabs(totalEnergy()), 1.0f);
        if (std::fabs(hamiltonian_excess) > tolerance * denom) { return false; }

        // Inv. 4: Estabilidad giroscópica en rango
        if (gyroscopic_stability < 0.0f || gyroscopic_stability > 2.0f) {
            return false;
        }

        return true;
    }
};

// ============================================================================
// 2. ESTRATO TÁCTICO (BusinessTopologicalAnalyzer)
// ============================================================================
/**
 * Métricas topológicas del espacio de estados del negocio.
 *
 * Fundamentos de Topología Algebraica:
 * - βₖ: k-ésimo número de Betti = rango del k-ésimo grupo de homología Hₖ
 *   · β₀: componentes conexas (≥ 1)
 *   · β₁: ciclos independientes / "agujeros" 1D (≥ 0)
 *   · β₂: cavidades 2-dimensionales (≥ 0)
 *
 * Relaciones fundamentales:
 * - χ = β₀ − β₁ + β₂                    (característica de Euler-Poincaré)
 * - Teorema de Fiedler: λ₂(L) > 0 ⟺ grafo conexo (β₀ = 1)
 * - Para Laplaciano normalizado: 0 ≤ λ₂ ≤ 2  (espectro acotado)
 *
 * Invariantes mantenidos:
 * I1. β₀ ≥ 1, β₁ ≥ 0, β₂ ≥ 0
 * I2. β₀ > 1 ⟹ fiedler_value = 0   (enforced en fromJson)
 * I3. spectral_gap ≤ fiedler_value   (enforced en fromJson)
 * I4. spectral_gap ≤ MAX_SPECTRAL_GAP
 * I5. mayer_vietoris_delta ∈ [0, totalBetti()]
 */
struct TopologicalMetrics {
    int32_t beta_0{1};                ///< β₀: componentes conexas (≥ 1)
    int32_t beta_1{0};                ///< β₁: ciclos independientes (≥ 0)
    int32_t beta_2{0};                ///< β₂: cavidades (≥ 0)
    int32_t mayer_vietoris_delta{0};  ///< δ_{MV} ∈ [0, totalBetti()]
    float   fiedler_value{1.0f};      ///< λ₂ del Laplaciano (≥ 0)
    float   spectral_gap{0.0f};       ///< λ₂ − λ₁ = λ₂ (λ₁ = 0 siempre, ≥ 0)
    float   pyramid_stability{1.0f};  ///< Estabilidad estructural ∈ [0, 1]
    float   structural_entropy{0.0f}; ///< Entropía de von Neumann (≥ 0)

    // ─────────────────────────────────────────────────────────────────────────
    // Métricas derivadas
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Característica de Euler-Poincaré: χ = β₀ − β₁ + β₂
     *
     * Invariante topológico para superficies:
     * - Grafos planos:           χ = V − E + F  (fórmula de Euler)
     * - Superficies orientables: χ = 2 − 2g     (g = género)
     */
    [[nodiscard]] int32_t eulerCharacteristic() const noexcept {
        return beta_0 - beta_1 + beta_2;
    }

    /** Suma de invariantes homológicos: β₀ + β₁ + β₂ ≥ 1 */
    [[nodiscard]] int32_t totalBetti() const noexcept {
        return beta_0 + beta_1 + beta_2;
    }

    /**
     * Complejidad ciclomática normalizada: β₁ / β₀
     *
     * Número promedio de ciclos independientes por componente conexa.
     * Métrica de complejidad topológica del grafo.
     *
     * @return β₁/β₀ ≥ 0; 0.0 si β₀ = 0 (caso degenerado, no debería ocurrir).
     */
    [[nodiscard]] float cyclomaticComplexity() const noexcept {
        return (beta_0 > 0)
               ? (static_cast<float>(beta_1) / static_cast<float>(beta_0))
               : 0.0f;
    }

    /**
     * Conectividad algebraica normalizada ∈ [0, 1].
     *
     * Definición: λ₂ / MAX_SPECTRAL_GAP
     *
     * Solo tiene sentido cuando β₀ = 1 (grafo conexo).
     * Por el Teorema de Fiedler, λ₂ = 0 para β₀ > 1.
     *
     * @return conectividad ∈ [0, 1]; 0.0 si el grafo es disconexo.
     */
    [[nodiscard]] float algebraicConnectivity() const noexcept {
        if (beta_0 != 1 || fiedler_value <= 0.0f) { return 0.0f; }
        return TelemetryUtils::clamp(
            fiedler_value / TelemetryConfig::MAX_SPECTRAL_GAP,
            0.0f, 1.0f
        );
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Parseo y validación
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Parsea y sanitiza métricas desde objeto JSON.
     *
     * Postcondición: todos los invariantes topológicos se cumplen.
     */
    void fromJson(const JsonObjectConst& obj) noexcept {
        if (obj.isNull()) { return; }
        using namespace TelemetryUtils;

        beta_0 = clamp(readInt(obj, "beta_0", 1),
                       static_cast<int32_t>(1),
                       TelemetryConfig::MAX_BETTI_NUMBER);
        beta_1 = clamp(readInt(obj, "beta_1", 0),
                       static_cast<int32_t>(0),
                       TelemetryConfig::MAX_BETTI_NUMBER);
        beta_2 = clamp(readInt(obj, "beta_2", 0),
                       static_cast<int32_t>(0),
                       TelemetryConfig::MAX_BETTI_NUMBER);

        // Inv. I5: δ_{MV} ∈ [0, totalBetti()]
        // La corrección de Mayer-Vietoris no puede exceder la suma total
        // de Betti (cota combinatoria estándar de la secuencia exacta larga).
        {
            const int32_t maxDelta = totalBetti();
            mayer_vietoris_delta = clamp(
                readInt(obj, "mayer_vietoris_delta", 0),
                static_cast<int32_t>(0),
                maxDelta
            );
        }

        fiedler_value      = std::fmax(0.0f,
                             readFloat(obj, "fiedler_value",      1.0f));
        spectral_gap       = std::fmax(0.0f,
                             readFloat(obj, "spectral_gap",       0.0f));
        pyramid_stability  = clamp(
                             readFloat(obj, "pyramid_stability",  1.0f), 0.0f, 1.0f);
        structural_entropy = std::fmax(0.0f,
                             readFloat(obj, "structural_entropy", 0.0f));

        // Aplicar invariantes topológico-espectrales
        enforceSpectralCoherence();
    }

    /**
     * Verifica invariantes topológicos fundamentales.
     *
     * Invariantes verificados:
     * I1. β₀ ≥ 1, β₁ ≥ 0, β₂ ≥ 0
     * I2. β₀ > 1 ⟹ λ₂ = 0  (Teorema de Fiedler, grafo disconexo)
     * I3. spectral_gap ≤ fiedler_value + FIEDLER_EPS
     *     (gap = λ₂ − λ₁ = λ₂, ya que λ₁ = 0 siempre)
     * I4. spectral_gap ≤ MAX_SPECTRAL_GAP × 1.1  (margen numérico 10%)
     * I5. S_struct ≤ 3 · log(totalBetti() + 2)   (entropía acotada)
     * I6. mayer_vietoris_delta ∈ [0, totalBetti()]
     */
    [[nodiscard]] bool isCoherent() const noexcept {
        // I1: números de Betti válidos
        if (beta_0 < 1 || beta_1 < 0 || beta_2 < 0) { return false; }

        // I2: grafo disconexo ⟹ λ₂ = 0
        if (beta_0 > 1 && fiedler_value > TelemetryConfig::FIEDLER_EPS) {
            return false;
        }

        // I3: spectral_gap ≤ fiedler_value (λ₁ = 0)
        if (spectral_gap > fiedler_value + TelemetryConfig::FIEDLER_EPS) {
            return false;
        }

        // I4: gap espectral acotado (con 10% de margen numérico)
        if (spectral_gap > TelemetryConfig::MAX_SPECTRAL_GAP * 1.1f) {
            return false;
        }

        // I5: entropía estructural razonable
        const float maxEntropy =
            std::log(static_cast<float>(totalBetti() + 2)) * 3.0f;
        if (structural_entropy > maxEntropy) { return false; }

        // I6: corrección de Mayer-Vietoris acotada
        if (mayer_vietoris_delta < 0 || mayer_vietoris_delta > totalBetti()) {
            return false;
        }

        return true;
    }

private:
    /**
     * Aplica invariantes topológico-espectrales tras el parseo.
     *
     * Reglas aplicadas en orden:
     * R1. β₀ > 1 ⟹ fiedler_value = 0, spectral_gap = 0   (Teorema de Fiedler)
     * R2. spectral_gap acotado superiormente por MAX_SPECTRAL_GAP
     * R3. spectral_gap ≤ fiedler_value  (ya que λ₁ = 0 siempre)
     *
     * Postcondición: isCoherent() retorna true para datos bien formados.
     */
    void enforceSpectralCoherence() noexcept {
        // R1: Grafo disconexo → λ₂ = 0
        if (beta_0 > 1) {
            fiedler_value = 0.0f;
            spectral_gap  = 0.0f;
            return;
        }

        // R2: Gap espectral acotado superiormente
        if (spectral_gap > TelemetryConfig::MAX_SPECTRAL_GAP) {
            spectral_gap = TelemetryConfig::MAX_SPECTRAL_GAP;
        }

        // R3: spectral_gap no puede superar fiedler_value
        //     (gap = λ₂ − λ₁ = λ₂ − 0 = λ₂ = fiedler_value en esta métrica)
        if (spectral_gap > fiedler_value) {
            spectral_gap = fiedler_value;
        }
    }
};

// ============================================================================
// 3. ESTRATO ESTRATÉGICO (LaplaceOracle & FinancialEngine)
// ============================================================================
/**
 * Métricas de teoría de control para análisis de estabilidad.
 *
 * Fundamentos de Control LTI:
 * - Polos: raíces de det(sI − A) = 0
 * - Estabilidad BIBO: todos los polos en el semiplano abierto izquierdo
 * - Para sistemas LTI: λ_max(A) = Re(p_dominante)  [relación exacta]
 *
 * Invariantes mantenidos:
 * C1. is_stable ⟺ poles_real.allStable()   (cuando hay polos disponibles)
 * C2. is_stable  ⟹ lyapunov_exponent < STABILITY_EPS
 *     ¬is_stable ⟹ lyapunov_exponent ≥ −STABILITY_EPS
 * C3. is_stable ∧ GM finito ⟹ gain_margin_db ≥ 0
 * C4. damping_ratio ≥ 0
 *
 * Fuente de verdad:
 * - Si hay polos: polos determinan is_stable y lyapunov_exponent.
 * - Si no hay polos: lyapunov_exponent determina is_stable.
 */
struct ControlMetrics {
    PoleContainer poles_real;      ///< Partes reales de los polos del sistema
    bool  is_stable{true};         ///< Estabilidad BIBO (fuente: polos o declarada)
    float phase_margin_deg{45.0f}; ///< Margen de fase [grados]
    float gain_margin_db{          ///< Margen de ganancia [dB]
        std::numeric_limits<float>::infinity()};
    float damping_ratio{0.707f};   ///< ζ: factor de amortiguamiento ≥ 0
    float nutation_index{0.0f};    ///< Índice de nutación
    float lyapunov_exponent{-1.0f};///< λ_max de Lyapunov (derivado de polos)

    // ─────────────────────────────────────────────────────────────────────────
    // Métricas derivadas
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Polo real dominante: max { Re(pᵢ) }
     *
     * Determina la estabilidad asintótica para sistemas LTI.
     * @return polo dominante; quiet_NaN() si no hay polos.
     */
    [[nodiscard]] float dominantPoleReal() const noexcept {
        return poles_real.dominant();
    }

    /**
     * @return true si todos los polos satisfacen Re(pᵢ) < eps
     * @param  eps Umbral de estabilidad (default: STABILITY_EPS)
     */
    [[nodiscard]] bool polesIndicateStability(
        float eps = TelemetryConfig::STABILITY_EPS) const noexcept
    {
        return poles_real.allStable(eps);
    }

    /**
     * Tiempo de establecimiento aproximado (criterio 2%).
     *
     * Para sistema dominado por polo real p_dom: τ_s ≈ 4 / |Re(p_dom)|
     *
     * @return tiempo en segundos ≥ 0; +∞ si el sistema es inestable o
     *         no hay polos; 0.0 si el contenedor está vacío.
     */
    [[nodiscard]] float settlingTimeApprox() const noexcept {
        if (poles_real.empty()) { return 0.0f; }
        const float dom = dominantPoleReal();
        if (!TelemetryUtils::isFinite(dom) || dom >= 0.0f) {
            return std::numeric_limits<float>::infinity();
        }
        return -4.0f / dom;
    }

    /**
     * Frecuencia natural aproximada ωₙ [rad/s].
     *
     * Para polo dominante real p = −ζωₙ: ωₙ = |p| / ζ
     *
     * CORRECCIÓN V4.6: para sistema inestable (dom ≥ 0), ωₙ no tiene
     * sentido físico en este contexto. Se retorna 0.0 explícitamente.
     *
     * @return ωₙ ≥ 0; 0.0 si no hay polos, ζ ≈ 0, o sistema inestable.
     */
    [[nodiscard]] float naturalFrequencyApprox() const noexcept {
        if (poles_real.empty()) { return 0.0f; }
        if (damping_ratio <= TelemetryConfig::STABILITY_EPS) { return 0.0f; }
        const float dom = dominantPoleReal();
        if (!TelemetryUtils::isFinite(dom)) { return 0.0f; }
        // Sistema inestable: polo dominante ≥ 0 → ωₙ sin sentido físico
        if (dom >= 0.0f) { return 0.0f; }
        return std::fabs(dom) / damping_ratio;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Parseo y validación
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Parsea y sanitiza métricas desde objeto JSON.
     *
     * Postcondición: todos los invariantes C1–C4 se cumplen.
     */
    void fromJson(const JsonObjectConst& obj) noexcept {
        if (obj.isNull()) { return; }
        using namespace TelemetryUtils;

        // Parseo de polos
        poles_real.clear();
        const JsonArrayConst polesArr = obj["poles_real"];
        if (!polesArr.isNull()) {
            for (const JsonVariantConst pv : polesArr) {
                if (!poles_real.push_back(pv.as<float>())) { break; }
            }
        }

        // Parámetros escalares
        is_stable = obj["is_stable"] | true;

        phase_margin_deg = clamp(
            readFloat(obj, "phase_margin_deg",
                      TelemetryConfig::MIN_PHASE_MARGIN + 45.0f),
            TelemetryConfig::MIN_PHASE_MARGIN,
            TelemetryConfig::MAX_PHASE_MARGIN
        );
        damping_ratio = clamp(
            readFloat(obj, "damping_ratio", TelemetryConfig::OPTIMAL_DAMPING),
            TelemetryConfig::MIN_DAMPING,
            TelemetryConfig::MAX_DAMPING
        );
        nutation_index = readFloat(obj, "nutation_index", 0.0f);

        // Margen de ganancia: puede ser infinito en sistemas marginalmente estables
        {
            const JsonVariantConst gmVar = obj["gain_margin_db"];
            gain_margin_db = gmVar.isNull()
                ? std::numeric_limits<float>::infinity()
                : sanitize(gmVar.as<float>(),
                           std::numeric_limits<float>::infinity());
        }

        // Lyapunov: leer primero; será sobreescrito si hay polos
        lyapunov_exponent = readFloat(obj, "lyapunov_exponent", -1.0f);

        // Aplicar invariantes de coherencia (polos son fuente de verdad)
        enforceCoherence();
    }

    /**
     * Verifica coherencia entre parámetros de control.
     *
     * Invariantes verificados:
     * C1. is_stable ⟺ polesIndicateStability()   (cuando hay polos)
     * C2. is_stable  ⟹ lyapunov_exponent ≤ +STABILITY_EPS
     *     ¬is_stable ⟹ lyapunov_exponent ≥ −STABILITY_EPS
     * C3. is_stable ∧ GM finito ⟹ gain_margin_db ≥ 0
     * C4. damping_ratio ≥ 0
     */
    [[nodiscard]] bool isCoherent() const noexcept {
        // C1: coherencia estabilidad ↔ polos
        if (!poles_real.empty()) {
            if (is_stable != polesIndicateStability()) { return false; }
        }

        // C2: coherencia Lyapunov ↔ estabilidad
        // Sistema estable   ⟹ λ_max < 0  (exponente negativo)
        // Sistema inestable ⟹ λ_max ≥ 0  (al menos un modo divergente)
        if ( is_stable && lyapunov_exponent >  TelemetryConfig::STABILITY_EPS) {
            return false;  // Declarado estable pero λ_max > 0
        }
        if (!is_stable && lyapunov_exponent < -TelemetryConfig::STABILITY_EPS) {
            return false;  // Declarado inestable pero λ_max < 0
        }

        // C3: margen de ganancia coherente con estabilidad
        if (is_stable && std::isfinite(gain_margin_db) && gain_margin_db < 0.0f) {
            return false;
        }

        // C4: factor de amortiguamiento no negativo
        if (damping_ratio < 0.0f) { return false; }

        return true;
    }

private:
    /**
     * Deriva estabilidad y exponente de Lyapunov a partir de la fuente
     * de verdad disponible.
     *
     * Jerarquía de fuentes:
     * 1. Polos disponibles:
     *    - is_stable       ← allStable()
     *    - lyapunov_exponent ← dominant()  [relación exacta para LTI]
     *
     * 2. Sin polos (NUEVO V4.6):
     *    - is_stable ← (lyapunov_exponent < STABILITY_EPS)
     *    Cierra el invariante C2 cuando no hay polos en el JSON.
     */
    void enforceCoherence() noexcept {
        if (!poles_real.empty()) {
            // Caso 1: polos disponibles → son la fuente de verdad
            is_stable = polesIndicateStability();
            const float dom = dominantPoleReal();
            if (TelemetryUtils::isFinite(dom)) {
                lyapunov_exponent = dom;
            }
        } else {
            // Caso 2: sin polos → lyapunov_exponent determina is_stable
            // Garantiza el invariante C2 en ausencia de datos de polos.
            is_stable = (lyapunov_exponent < TelemetryConfig::STABILITY_EPS);
        }
    }
};

// ============================================================================
// 4. ESTRATO TERMODINÁMICO (Economía Física)
// ============================================================================
/**
 * Métricas termodinámicas para modelado económico-energético.
 *
 * Analogías Termodinámica ↔ Economía:
 * - Temperatura T → Volatilidad / nivel de actividad del mercado
 * - Entropía S    → Incertidumbre / grado de desorden informacional
 * - Exergía X     → Trabajo útil disponible / capital productivo
 * - Inercia I     → Resistencia al cambio / momentum económico
 *
 * Leyes implementadas:
 * - Segunda Ley: S ≥ 0
 * - Helmholtz:   F = U − TS
 * - Gibbs:       G = U + PV − TS
 *
 * Invariantes mantenidos:
 * T1. system_temperature ≥ 0  (Tercera Ley)
 * T2. entropy ≥ 0             (Segunda Ley)
 * T3. financial_inertia > 0   (definición)
 * T4. exergy ≥ 0              (definición)
 */
struct ThermodynamicMetrics {
    float system_temperature{298.0f}; ///< T [K]   Temperatura absoluta ≥ 0
    float entropy{0.0f};              ///< S [J/K]  Entropía ≥ 0
    float financial_inertia{1.0f};    ///< I        Inercia financiera > 0
    float exergy{1.0f};               ///< X [J]    Exergía disponible ≥ 0

    // ─────────────────────────────────────────────────────────────────────────
    // Métricas derivadas
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Energía libre de Helmholtz: F = U − TS
     *
     * Trabajo máximo extraíble a temperatura constante.
     * @param internal_energy U [J]: energía interna del sistema
     */
    [[nodiscard]] float helmholtzFreeEnergy(float internal_energy) const noexcept {
        return internal_energy - system_temperature * entropy;
    }

    /**
     * Energía libre de Gibbs: G = U + PV − TS
     *
     * Trabajo máximo no-expansivo a T y P constantes.
     * @param internal_energy U [J]
     * @param pressure        P [Pa]
     * @param volume          V [m³]
     */
    [[nodiscard]] float gibbsFreeEnergy(float internal_energy,
                                        float pressure,
                                        float volume) const noexcept {
        return helmholtzFreeEnergy(internal_energy) + pressure * volume;
    }

    /**
     * Ratio de exergía: X / |E_total|
     *
     * Fracción de energía disponible para trabajo útil.
     * @return ratio ≥ 0; 0.0 si |E_total| < MIN_ENERGY.
     */
    [[nodiscard]] float exergyRatio(float total_energy) const noexcept {
        const float absE = std::fabs(total_energy);
        return (absE > TelemetryConfig::MIN_ENERGY) ? (exergy / absE) : 0.0f;
    }

    /**
     * Índice de irreversibilidad normalizado ∈ [0, 1].
     *
     * Definición:
     *   I_irrev = (S·T) / (S·T + X)
     *
     * Interpretación:
     * - S·T: energía "no disponible" (ligada a entropía)
     * - X:   energía disponible (exergía)
     * - El cociente mide la proporción de energía no disponible.
     *
     * Casos límite gestionados:
     * - S·T = 0 ∧ X ≥ 0: sin producción entrópica → I = 0  (proceso reversible)
     * - S·T > 0 ∧ X = 0: energía totalmente no-disponible → I = 1  (irreversible)
     * - S·T = 0 ∧ X = 0: estado degenerado → I = 0  (sin información)
     */
    [[nodiscard]] float irreversibilityIndex() const noexcept {
        const float unavailable = entropy * system_temperature;  // S·T ≥ 0

        // Caso: S·T ≈ 0 → proceso sin producción de entropía
        if (unavailable < TelemetryConfig::MIN_ENERGY) {
            return 0.0f;
        }

        // Caso general: denominador = S·T + X > S·T > 0
        const float denominator = unavailable + std::fmax(exergy, 0.0f);
        return TelemetryUtils::clamp(unavailable / denominator, 0.0f, 1.0f);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Parseo y validación
    // ─────────────────────────────────────────────────────────────────────────

    /** Parsea y sanitiza métricas desde objeto JSON. */
    void fromJson(const JsonObjectConst& obj) noexcept {
        if (obj.isNull()) { return; }
        using namespace TelemetryUtils;

        system_temperature = clamp(
            readFloat(obj, "system_temperature", 298.0f),
            TelemetryConfig::MIN_TEMPERATURE_K,
            TelemetryConfig::MAX_TEMPERATURE_K
        );
        entropy = std::fmax(0.0f, readFloat(obj, "entropy", 0.0f));

        financial_inertia = readFloat(obj, "financial_inertia", 1.0f);
        if (financial_inertia <= 0.0f) {
            financial_inertia = TelemetryConfig::MIN_INERTIA;
        }

        exergy = std::fmax(0.0f, readFloat(obj, "exergy", 1.0f));
    }

    /**
     * Verifica invariantes termodinámicos fundamentales.
     *
     * T1. T ≥ 0   (temperatura absoluta, Tercera Ley)
     * T2. S ≥ 0   (entropía no negativa, Segunda Ley)
     * T3. I > 0   (inercia estrictamente positiva)
     * T4. X ≥ 0   (exergía no negativa)
     */
    [[nodiscard]] bool isCoherent() const noexcept {
        if (system_temperature <  0.0f)  { return false; }  // T1
        if (entropy            <  0.0f)  { return false; }  // T2
        if (financial_inertia  <= 0.0f)  { return false; }  // T3
        if (exergy             <  0.0f)  { return false; }  // T4
        return true;
    }
};

// ============================================================================
// 5. ESTRATO SABIDURÍA (Veredicto Final)
// ============================================================================
/**
 * Síntesis ejecutiva del estado del sistema.
 * Encapsula el "juicio" del oráculo sobre la situación global.
 */
struct WisdomMetrics {
    VerdictCode verdict_code{VerdictCode::UNKNOWN};
    char narrative_short[TelemetryConfig::NARRATIVE_MAX_LEN + 1u]{};

    WisdomMetrics() noexcept {
        setNarrative("ESPERANDO DATOS...");
    }

    /** Escribe la narrativa corta con protección de desbordamiento. */
    void setNarrative(const char* text) noexcept {
        if (text != nullptr) {
            telemetry_strlcpy(narrative_short, text, sizeof(narrative_short));
        } else {
            narrative_short[0] = '\0';
        }
    }

    /**
     * Parsea el veredicto y la narrativa desde objeto JSON.
     *
     * El campo "verdict_code" acepta enteros 0, 1, 2; cualquier otro
     * valor (incluyendo negativos o > 2) resulta en VerdictCode::UNKNOWN.
     */
    void fromJson(const JsonObjectConst& obj) noexcept {
        if (obj.isNull()) { return; }

        const int raw_code =
            obj["verdict_code"] | static_cast<int>(VerdictCode::UNKNOWN);
        switch (raw_code) {
            case 0:  verdict_code = VerdictCode::OK;       break;
            case 1:  verdict_code = VerdictCode::WARN;     break;
            case 2:  verdict_code = VerdictCode::CRITICAL; break;
            default: verdict_code = VerdictCode::UNKNOWN;  break;
        }

        const char* narr = obj["narrative_short"];
        setNarrative((narr != nullptr && narr[0] != '\0') ? narr : "SISTEMA NOMINAL");
    }

    [[nodiscard]] int  verdictAsInt()  const noexcept {
        return static_cast<int>(verdict_code);
    }
    [[nodiscard]] bool isOK()       const noexcept {
        return verdict_code == VerdictCode::OK;
    }
    [[nodiscard]] bool isCritical() const noexcept {
        return verdict_code == VerdictCode::CRITICAL;
    }
    [[nodiscard]] bool isUnknown()  const noexcept {
        return verdict_code == VerdictCode::UNKNOWN;
    }

    [[nodiscard]] const char* verdictString() const noexcept {
        switch (verdict_code) {
            case VerdictCode::OK:       return "OK";
            case VerdictCode::WARN:     return "WARN";
            case VerdictCode::CRITICAL: return "CRITICAL";
            default:                    return "UNKNOWN";
        }
    }
};

// ============================================================================
// PAQUETE DE TELEMETRÍA GLOBAL
// ============================================================================
/**
 * Contenedor maestro que integra los cinco estratos del gemelo digital.
 *
 * Responsabilidades:
 * - Parseo de JSON hacia estructuras tipadas con validación semántica
 * - Validación de coherencia intra-estrato e inter-estrato
 * - Cálculo de métricas agregadas (healthIndex, systemHealth, etc.)
 * - Emisión de códigos de error semánticos con prioridad definida
 *
 * Invariante global:
 * - last_error == OK ⟺ el último fromJson() produjo un paquete coherente
 */
struct TelemetryPacket {
    PhysicsMetrics       physics;
    TopologicalMetrics   topology;
    ControlMetrics       control;
    ThermodynamicMetrics thermodynamics;
    WisdomMetrics        wisdom;
    char                 timestamp[TelemetryConfig::TIMESTAMP_MAX_LEN + 1u]{};

    TelemetryError  last_error{TelemetryError::OK};
    uint32_t        parse_count{0u};

    TelemetryPacket() noexcept {
        timestamp[0] = '\0';
    }

    // =========================================================================
    // PARSEO
    // =========================================================================

    /**
     * Parsea un string JSON y puebla todos los estratos.
     *
     * Orden de detección de errores (primer error detectado se retorna):
     * 1. EMPTY_INPUT           → jsonString vacío
     * 2. JSON_PARSE_ERROR      → sintaxis JSON inválida
     * 3. JSON_OVERFLOW         → buffer insuficiente (solo ArduinoJson v6)
     * 4. TOPOLOGICAL_ANOMALY   → topología incoherente post-parseo
     * 5. THERMODYNAMIC_ANOMALY → termodinámica incoherente post-parseo
     * 6. COHERENCE_VIOLATION   → física o control incoherentes post-parseo
     *
     * @param jsonString String JSON a parsear (puede contener campos parciales)
     * @return TelemetryError resultante
     */
    [[nodiscard]] TelemetryError fromJson(const String& jsonString) noexcept {
        ++parse_count;

        if (jsonString.length() == 0u) {
            last_error = TelemetryError::EMPTY_INPUT;
            return last_error;
        }

        // Compatibilidad ArduinoJson v6 / v7
#if ARDUINOJSON_VERSION_MAJOR >= 7
        JsonDocument doc;
#else
        StaticJsonDocument<TelemetryConfig::JSON_BUFFER_SIZE> doc;
#endif

        const DeserializationError jsonErr = deserializeJson(doc, jsonString);
        if (jsonErr) {
            last_error = TelemetryError::JSON_PARSE_ERROR;
            return last_error;
        }

#if ARDUINOJSON_VERSION_MAJOR < 7
        if (doc.overflowed()) {
            last_error = TelemetryError::JSON_OVERFLOW;
            return last_error;
        }
#endif

        // Parseo de cada estrato
        physics       .fromJson(doc["physics"]       .as<JsonObjectConst>());
        topology      .fromJson(doc["topology"]       .as<JsonObjectConst>());
        control       .fromJson(doc["control"]        .as<JsonObjectConst>());
        thermodynamics.fromJson(doc["thermodynamics"] .as<JsonObjectConst>());
        wisdom        .fromJson(doc["wisdom"]         .as<JsonObjectConst>());

        // Timestamp
        const char* ts = doc["timestamp"];
        if (ts != nullptr) {
            telemetry_strlcpy(timestamp, ts, sizeof(timestamp));
        } else {
            timestamp[0] = '\0';
        }

        // ─────────────────────────────────────────────────────────────────────
        // Validación semántica post-parseo con códigos específicos
        // ─────────────────────────────────────────────────────────────────────
        if (!topology.isCoherent()) {
            last_error = TelemetryError::TOPOLOGICAL_ANOMALY;
            return last_error;
        }
        if (!thermodynamics.isCoherent()) {
            last_error = TelemetryError::THERMODYNAMIC_ANOMALY;
            return last_error;
        }
        if (!physics.isCoherent() || !control.isCoherent()) {
            last_error = TelemetryError::COHERENCE_VIOLATION;
            return last_error;
        }

        last_error = TelemetryError::OK;
        return last_error;
    }

    // =========================================================================
    // VALIDACIONES DE COHERENCIA
    // =========================================================================

    /** Coherencia intra-estrato: cada módulo es internamente consistente. */
    [[nodiscard]] bool isIntraCoherent() const noexcept {
        return physics.isCoherent()
            && topology.isCoherent()
            && control.isCoherent()
            && thermodynamics.isCoherent();
    }

    /**
     * Coherencia inter-estrato: relaciones cruzadas entre módulos.
     *
     * Las verificaciones inter son informativas; una violación inter
     * no es necesariamente un error catastrófico. El healthIndex() las
     * incorpora implícitamente via los subpuntajes de cada estrato.
     *
     * Relaciones monitoreadas (no forzadas como error):
     * - Control ↔ Física: inestabilidad con alta σ_gyr es inusual pero posible
     * - Termodinámica ↔ Física: correlación disipación-entropía requiere contexto temporal
     * - Topología ↔ Control: componentes desconexas pueden ser individualmente estables
     */
    [[nodiscard]] bool isInterCoherent() const noexcept {
        return true;
    }

    /** Coherencia global: intra + inter. */
    [[nodiscard]] bool isCoherent() const noexcept {
        return isIntraCoherent() && isInterCoherent();
    }

    // =========================================================================
    // MÉTRICAS AGREGADAS
    // =========================================================================

    /**
     * Índice de salud global del sistema ∈ [0, 1].
     *
     * Combina puntajes de los cuatro estratos físicos con pesos configurables.
     * Si el sistema es incoherente, el resultado se limita a
     * HEALTH_INCOHERENT_CEILING como penalización estructural.
     *
     * @param intraCoherent Resultado pre-calculado de isIntraCoherent()
     *                      (evita doble cómputo cuando se llama desde systemHealth())
     */
    [[nodiscard]] float healthIndex() const noexcept {
        const bool coherent = isIntraCoherent();
        return healthIndexImpl(coherent);
    }

    /**
     * Estado de salud categórico basado en healthIndex().
     *
     * OPTIMIZACIÓN V4.6: calcula isIntraCoherent() una sola vez y
     * lo pasa a healthIndexImpl() para evitar el doble cómputo que
     * existía en V4.5 (systemHealth() → healthIndex() → isIntraCoherent()
     * siendo llamado dos veces desde systemHealth()).
     */
    [[nodiscard]] SystemHealth systemHealth() const noexcept {
        const bool intraOk = isIntraCoherent();

        // Si no es coherente ni intra ni inter, es CRITICAL directamente.
        if (!intraOk || !isInterCoherent()) { return SystemHealth::CRITICAL; }

        const float hi = healthIndexImpl(/*intraCoherent=*/true);
        if (hi >= TelemetryConfig::HEALTH_NOMINAL_THRESHOLD)  {
            return SystemHealth::NOMINAL;
        }
        if (hi >= TelemetryConfig::HEALTH_DEGRADED_THRESHOLD) {
            return SystemHealth::DEGRADED;
        }
        return SystemHealth::CRITICAL;
    }

    /** Veredicto computado desde métricas (puede diferir del reportado). */
    [[nodiscard]] VerdictCode computedVerdict() const noexcept {
        switch (systemHealth()) {
            case SystemHealth::NOMINAL:  return VerdictCode::OK;
            case SystemHealth::DEGRADED: return VerdictCode::WARN;
            case SystemHealth::CRITICAL: return VerdictCode::CRITICAL;
            default:                     return VerdictCode::UNKNOWN;
        }
    }

    /**
     * Verifica si el veredicto reportado es coherente con las métricas.
     *
     * Política de aceptación:
     * - UNKNOWN reportado: coherente solo si el sistema es coherente.
     * - Diferencia de nivel ≤ 1: aceptable (OK↔WARN o WARN↔CRITICAL).
     * - Diferencia de nivel > 1: mismatch grave (OK reportado, CRITICAL medido).
     *
     * Usa TelemetryUtils::absDiff para portabilidad en Arduino/avr-libc.
     */
    [[nodiscard]] bool isVerdictCoherent() const noexcept {
        const VerdictCode computed = computedVerdict();
        const VerdictCode reported = wisdom.verdict_code;

        if (reported == VerdictCode::UNKNOWN) {
            return isCoherent();
        }
        if (computed == VerdictCode::UNKNOWN) {
            return false;
        }

        const uint32_t diff = TelemetryUtils::absDiff(
            static_cast<int32_t>(computed),
            static_cast<int32_t>(reported)
        );
        return diff <= 1u;
    }

    // =========================================================================
    // UTILIDADES
    // =========================================================================

    [[nodiscard]] float totalSystemEnergy() const noexcept {
        return physics.totalEnergy();
    }

    [[nodiscard]] float helmholtzEnergy() const noexcept {
        return thermodynamics.helmholtzFreeEnergy(physics.totalEnergy());
    }

    [[nodiscard]] size_t poleCount() const noexcept {
        return control.poles_real.size();
    }

    [[nodiscard]] const char* statusString() const noexcept {
        switch (systemHealth()) {
            case SystemHealth::NOMINAL:  return "NOMINAL";
            case SystemHealth::DEGRADED: return "DEGRADED";
            case SystemHealth::CRITICAL: return "CRITICAL";
            default:                     return "UNDEFINED";
        }
    }

private:
    /**
     * Implementación interna del índice de salud.
     *
     * Recibe el resultado pre-calculado de isIntraCoherent() para evitar
     * doble cómputo en la ruta systemHealth() → healthIndexImpl().
     *
     * @param intraCoherent Resultado de isIntraCoherent()
     * @return score ∈ [0, 1]
     */
    [[nodiscard]] float healthIndexImpl(bool intraCoherent) const noexcept {
        const float score   = calculateHealthScore();
        const float ceiling = intraCoherent
            ? 1.0f
            : TelemetryConfig::HEALTH_INCOHERENT_CEILING;
        return std::fmin(score, ceiling);
    }

    /**
     * Calcula el puntaje de salud ponderado ∈ [0, 1].
     *
     * Cada componente se computa de forma independiente y se penaliza
     * si su estrato no es coherente (factor HEALTH_INCOHERENCE_PENALTY).
     *
     * Componentes y fórmulas:
     * ┌─────────────┬──────────────────────────────────────────────────────┐
     * │ Física      │ gyro_norm × efficiency()                             │
     * │             │ gyro_norm = clamp(σ_gyr / 2, 0, 1)                  │
     * ├─────────────┼──────────────────────────────────────────────────────┤
     * │ Topología   │ pyramid_stability × max(algebraicConnectivity, 0.1) │
     * │             │ Piso 0.1 evita colapso para grafos con λ₂ → 0       │
     * ├─────────────┼──────────────────────────────────────────────────────┤
     * │ Control     │ pmNorm × dampFactor   (si is_stable)                 │
     * │             │ pmNorm  = clamp(PM / PM_REF, 0, 1)                   │
     * │             │ dampFactor = max(0, 1 − |ζ − ζ*|)                   │
     * │             │ 0 si !is_stable (inestabilidad es fallo total)       │
     * │             │ NUEVO: penaliza también si !isCoherent()              │
     * ├─────────────┼──────────────────────────────────────────────────────┤
     * │ Termodinámica│ exergy_norm × (1 − 0.5 × entropy_penalty)          │
     * │             │ exergy_norm    = clamp(X, 0, 1)                      │
     * │             │ entropy_penalty = clamp(S / E_NORM, 0, 1)           │
     * │             │ E_NORM = ENTROPY_NORMALIZATION_FACTOR (config)       │
     * └─────────────┴──────────────────────────────────────────────────────┘
     *
     * Los pesos suman 1.0 (verificado por static_assert en TelemetryConfig).
     */
    [[nodiscard]] float calculateHealthScore() const noexcept {
        using namespace TelemetryConfig;
        using namespace TelemetryUtils;

        float totalScore = 0.0f;

        // ─────────────────────────────────────────────────────────────────────
        // Componente física
        // ─────────────────────────────────────────────────────────────────────
        {
            const float coherenceFactor =
                physics.isCoherent() ? 1.0f : HEALTH_INCOHERENCE_PENALTY;
            float phys = coherenceFactor;
            phys *= clamp(physics.gyroscopic_stability / 2.0f, 0.0f, 1.0f);
            phys *= physics.efficiency();
            totalScore += HEALTH_WEIGHT_PHYSICS * phys;
        }

        // ─────────────────────────────────────────────────────────────────────
        // Componente topológica
        // Piso en algebraicConnectivity evita colapso total para grafos
        // con baja conectividad pero estructuralmente coherentes.
        // ─────────────────────────────────────────────────────────────────────
        {
            const float coherenceFactor =
                topology.isCoherent() ? 1.0f : HEALTH_INCOHERENCE_PENALTY;
            float topo = coherenceFactor;
            topo *= clamp(topology.pyramid_stability, 0.0f, 1.0f);
            topo *= std::fmax(topology.algebraicConnectivity(),
                              TOPOLOGY_CONNECTIVITY_FLOOR);
            totalScore += HEALTH_WEIGHT_TOPOLOGY * topo;
        }

        // ─────────────────────────────────────────────────────────────────────
        // Componente de control
        //
        // CORRECCIÓN V4.6: se aplica coherenceFactor también cuando
        // is_stable = true pero isCoherent() falla (e.g., lyapunov > 0
        // con is_stable declarado). En V4.5 este caso no era penalizado.
        //
        // Lógica:
        // - is_stable = false             → subpuntaje = 0 (inestabilidad total)
        // - is_stable = true, incoherente → penalizado × HEALTH_INCOHERENCE_PENALTY
        // - is_stable = true, coherente   → puntaje completo
        // ─────────────────────────────────────────────────────────────────────
        {
            if (control.is_stable) {
                const float coherenceFactor =
                    control.isCoherent() ? 1.0f : HEALTH_INCOHERENCE_PENALTY;

                const float pmNorm =
                    clamp(control.phase_margin_deg / PHASE_MARGIN_REFERENCE,
                          0.0f, 1.0f);
                const float dampDelta =
                    std::fabs(control.damping_ratio - OPTIMAL_DAMPING);
                const float dampFactor = std::fmax(0.0f, 1.0f - dampDelta);

                totalScore += HEALTH_WEIGHT_CONTROL *
                              coherenceFactor * pmNorm * dampFactor;
            }
            // is_stable = false → contribución = 0 (no suma)
        }

        // ─────────────────────────────────────────────────────────────────────
        // Componente termodinámica
        // Exergía normalizada a [0, 1] (valores > 1 J saturan a 1).
        // Penalización entrópica usa ENTROPY_NORMALIZATION_FACTOR de config.
        // ─────────────────────────────────────────────────────────────────────
        {
            const float coherenceFactor =
                thermodynamics.isCoherent() ? 1.0f : HEALTH_INCOHERENCE_PENALTY;
            float thermo = coherenceFactor;
            thermo *= clamp(thermodynamics.exergy, 0.0f, 1.0f);
            const float entropyPenalty =
                clamp(thermodynamics.entropy / ENTROPY_NORMALIZATION_FACTOR,
                      0.0f, 1.0f);
            thermo *= (1.0f - THERMO_ENTROPY_PENALTY_COEF * entropyPenalty);
            totalScore += HEALTH_WEIGHT_THERMO * thermo;
        }

        // Pesos suman 1.0 → totalScore ∈ [0, 1] por construcción.
        // clamp defensivo como guard contra errores de punto flotante acumulados.
        return clamp(totalScore, 0.0f, 1.0f);
    }
};

// ============================================================================
// FUNCIONES DE DIAGNÓSTICO
// ============================================================================
namespace TelemetryDiagnostics {

    /**
     * Imprime un resumen de estado en el stream indicado.
     *
     * @param packet Paquete de telemetría a reportar
     * @param out    Stream de salida (Serial u otro Print&)
     */
    inline void printSummary(const TelemetryPacket& packet, Print& out) {
        out.print(F("=== TELEMETRY SUMMARY ===\n"));

        out.print(F("Timestamp:      "));
        out.println(packet.timestamp[0] ? packet.timestamp : "(none)");

        out.print(F("Health Index:   "));
        out.println(packet.healthIndex(), 3);

        out.print(F("System Status:  "));
        out.println(packet.statusString());

        out.print(F("Verdict:        "));
        out.print(packet.wisdom.verdictString());
        out.print(F(" — "));
        out.println(packet.wisdom.narrative_short);

        out.print(F("Coherent:       "));
        out.println(packet.isCoherent() ? F("YES") : F("NO"));

        out.print(F("Total Energy:   "));
        out.println(packet.totalSystemEnergy(), 4);

        out.print(F("Control Stable: "));
        out.println(packet.control.is_stable ? F("YES") : F("NO"));

        out.print(F("Lyapunov:       "));
        out.println(packet.control.lyapunov_exponent, 6);

        out.print(F("Euler Char:     "));
        out.println(packet.topology.eulerCharacteristic());

        out.print(F("Poles:          "));
        out.println(static_cast<int>(packet.poleCount()));
    }

    /** Imprime un reporte detallado de coherencia por estrato. */
    inline void printCoherenceReport(const TelemetryPacket& packet, Print& out) {
        out.println(F("=== COHERENCE REPORT ==="));
        out.print(F("Physics:        "));
        out.println(packet.physics.isCoherent()        ? F("OK") : F("FAIL"));
        out.print(F("Topology:       "));
        out.println(packet.topology.isCoherent()       ? F("OK") : F("FAIL"));
        out.print(F("Control:        "));
        out.println(packet.control.isCoherent()        ? F("OK") : F("FAIL"));
        out.print(F("Thermodynamics: "));
        out.println(packet.thermodynamics.isCoherent() ? F("OK") : F("FAIL"));
        out.print(F("Verdict Match:  "));
        out.println(packet.isVerdictCoherent()         ? F("OK") : F("MISMATCH"));
    }

    /**
     * Verificación de integridad estructural completa.
     *
     * Verifica:
     * 1. Coherencia global (intra + inter)
     * 2. healthIndex() es finito y ∈ [0, 1]
     * 3. totalSystemEnergy() es finito
     * 4. lyapunov_exponent es finito
     * 5. poleCount() ≤ MAX_POLES
     *
     * @return true si todas las verificaciones pasan.
     */
    [[nodiscard]] inline bool fullIntegrityCheck(const TelemetryPacket& packet) {
        // Check 1: coherencia global
        if (!packet.isCoherent()) { return false; }

        // Check 2: índice de salud válido
        const float hi = packet.healthIndex();
        if (!TelemetryUtils::isFinite(hi)) { return false; }
        if (hi < 0.0f || hi > 1.0f)        { return false; }

        // Check 3: energía total finita
        if (!TelemetryUtils::isFinite(packet.totalSystemEnergy())) { return false; }

        // Check 4: exponente de Lyapunov finito
        if (!TelemetryUtils::isFinite(packet.control.lyapunov_exponent)) {
            return false;
        }

        // Check 5: número de polos en rango válido
        if (packet.poleCount() > TelemetryConfig::MAX_POLES) { return false; }

        return true;
    }

    /** Retorna representación textual de un código de error. */
    [[nodiscard]] inline const char* errorString(TelemetryError error) noexcept {
        switch (error) {
            case TelemetryError::OK:                    return "OK";
            case TelemetryError::EMPTY_INPUT:           return "EMPTY_INPUT";
            case TelemetryError::JSON_PARSE_ERROR:      return "JSON_PARSE_ERROR";
            case TelemetryError::JSON_OVERFLOW:         return "JSON_OVERFLOW";
            case TelemetryError::COHERENCE_VIOLATION:   return "COHERENCE_VIOLATION";
            case TelemetryError::TOPOLOGICAL_ANOMALY:   return "TOPOLOGICAL_ANOMALY";
            case TelemetryError::THERMODYNAMIC_ANOMALY: return "THERMODYNAMIC_ANOMALY";
            default:                                    return "UNKNOWN_ERROR";
        }
    }

} // namespace TelemetryDiagnostics

#endif // TELEMETRY_H