# ============================================================================
# M√âTODOS REFINADOS - TelemetryData
# ============================================================================

@classmethod
def from_dict(cls, data: Dict[str, Any]) -> Optional["TelemetryData"]:
    """
    Factory method con extracci√≥n funcional y proyecci√≥n al espacio de m√©tricas.
    
    Implementa un functor desde el espacio de datos crudos hacia el espacio
    normalizado [0,1]¬≤, preservando la estructura mediante defaults seguros.
    """
    if not isinstance(data, dict):
        logger.warning(f"[TELEMETRY] Morfismo inv√°lido: {type(data).__name__} ‚àâ Dict")
        return None

    # Definir el espacio de b√∫squeda como lista de proyecciones ordenadas por prioridad
    metric_paths: Dict[str, Tuple[str, ...]] = {
        "flyback": ("flux_condenser.max_flyback_voltage", "flyback_voltage", "voltage"),
        "saturation": ("flux_condenser.avg_saturation", "saturation", "sat"),
    }
    
    def extract_metric(source: Dict[str, Any], paths: Tuple[str, ...]) -> Optional[float]:
        """Proyecci√≥n con fallback a trav√©s de caminos alternativos."""
        metrics_ns = source.get("metrics", source)
        search_space = metrics_ns if isinstance(metrics_ns, dict) else source
        
        for path in paths:
            if (value := search_space.get(path)) is not None:
                try:
                    return float(value)
                except (TypeError, ValueError):
                    continue
        return None

    flyback = extract_metric(data, metric_paths["flyback"])
    saturation = extract_metric(data, metric_paths["saturation"])
    
    # Proyecci√≥n al punto base (0,0) del espacio si no hay datos
    is_idle = flyback is None or saturation is None
    if is_idle:
        logger.debug("[TELEMETRY] Proyectando al origen: estado IDLE (0.0, 0.0)")
    
    flyback = flyback if flyback is not None else 0.0
    saturation = saturation if saturation is not None else 0.0

    # Advertencias para valores fuera del compacto [0,1]
    for name, val in [("flyback_voltage", flyback), ("saturation", saturation)]:
        if not (0.0 <= val <= 1.0):
            logger.warning(f"[TELEMETRY] {name}={val:.4f} ‚àâ [0,1]")

    return cls(flyback_voltage=flyback, saturation=saturation, raw_data=data)


# ============================================================================
# M√âTODOS REFINADOS - AutonomousAgent.observe
# ============================================================================

def observe(self) -> Optional[TelemetryData]:
    """
    OBSERVE - Primera fase del ciclo OODA.
    
    Implementa la observaci√≥n como un morfismo O: Infraestructura ‚Üí Telemetr√≠a
    con manejo de errores que preserva la coherencia topol√≥gica del sistema.
    """
    request_id = f"obs_{uuid.uuid4().hex[:8]}_{int(time.time())}"
    
    # Definir el espacio de errores como mapeo a handlers uniformes
    error_handlers: Dict[type, Tuple[str, str]] = {
        requests.exceptions.Timeout: ("TIMEOUT", f"despu√©s de {self.request_timeout}s"),
        requests.exceptions.ConnectionError: ("CONNECTION_ERROR", "conexi√≥n rechazada"),
        requests.exceptions.RequestException: ("REQUEST_ERROR", "error de request"),
    }

    try:
        response = self._session.get(
            self.telemetry_endpoint, timeout=self.request_timeout
        )

        if not response.ok:
            self._handle_observation_failure(request_id, f"HTTP_{response.status_code}")
            logger.warning(f"[OBSERVE] HTTP {response.status_code}")
            return None

        try:
            raw_data = response.json()
        except ValueError as e:
            self._handle_observation_failure(request_id, "INVALID_JSON")
            logger.warning(f"[OBSERVE] JSON inv√°lido: {e}")
            return None

        if (telemetry := TelemetryData.from_dict(raw_data)) is None:
            self._handle_observation_failure(request_id, "INVALID_TELEMETRY")
            return None

        self._handle_observation_success(request_id, telemetry)
        return telemetry

    except tuple(error_handlers.keys()) as e:
        error_type, msg = error_handlers.get(type(e), ("UNKNOWN", str(e)))
        logger.warning(f"[OBSERVE] {error_type}: {msg}")
        self._handle_observation_failure(request_id, error_type)
        return None


def _handle_observation_result(
    self, request_id: str, telemetry: Optional[TelemetryData], failure_type: Optional[str]
) -> None:
    """
    Unifica el manejo de resultados de observaci√≥n preservando invariantes.
    
    Act√∫a como un functor que mapea el resultado al espacio de m√©tricas
    y actualiza la topolog√≠a de manera coherente.
    """
    if telemetry is not None:
        # Morfismo de √©xito: actualizar espacio de estados
        self._metrics.record_success()
        self.topology.record_request(request_id)
        
        # Inferir conectividad desde telemetr√≠a
        raw = telemetry.raw_data
        active_connections = [("Agent", "Core")]
        
        # Extensi√≥n del grafo seg√∫n estado reportado
        if raw.get("redis_connected", True):
            active_connections.append(("Core", "Redis"))
        if raw.get("filesystem_accessible", True):
            active_connections.append(("Core", "Filesystem"))
        
        self.topology.update_connectivity(
            active_connections, validate_nodes=True, auto_add_nodes=False
        )
        self.topology.clear_request_history()
        
        logger.debug(
            f"[OBSERVE] ‚úì v={telemetry.flyback_voltage:.3f}, s={telemetry.saturation:.3f}"
        )
    else:
        # Morfismo de fallo: degradar espacio topol√≥gico
        self._metrics.record_failure()
        self.topology.record_request(f"FAIL_{failure_type}")
        
        if self._metrics.consecutive_failures >= self.MAX_CONSECUTIVE_FAILURES:
            logger.warning(f"[TOPO] Degradaci√≥n: {self._metrics.consecutive_failures} fallos")
            self.topology.remove_edge("Agent", "Core")


def _handle_observation_success(self, request_id: str, telemetry: TelemetryData) -> None:
    """Wrapper para compatibilidad - delega al m√©todo unificado."""
    self._handle_observation_result(request_id, telemetry, None)


def _handle_observation_failure(self, request_id: str, failure_type: str) -> None:
    """Wrapper para compatibilidad - delega al m√©todo unificado."""
    self._handle_observation_result(request_id, None, failure_type)


# ============================================================================
# M√âTODOS REFINADOS - AutonomousAgent.orient
# ============================================================================

def orient(self, telemetry: Optional[TelemetryData]) -> SystemStatus:
    """
    ORIENT - Segunda fase del ciclo OODA (Motor Topol√≥gico).
    
    Implementa el morfismo de orientaci√≥n O: T √ó H ‚Üí S donde:
    - T = espacio de telemetr√≠a
    - H = espacio de homolog√≠a persistente  
    - S = espacio de estados del sistema
    
    La composici√≥n preserva la estructura algebraica del diagn√≥stico.
    """
    # Calcular invariantes topol√≥gicos (Œ≤‚ÇÄ suficiente para conectividad)
    topo_health = self.topology.get_topological_health(calculate_b1=False)

    # Proyectar m√©tricas al espacio de persistencia
    analyses = {
        "voltage": self._analyze_metric_persistence(
            "flyback_voltage",
            telemetry.flyback_voltage if telemetry else None,
            self.thresholds.flyback_voltage_warning,
        ),
        "saturation": self._analyze_metric_persistence(
            "saturation",
            telemetry.saturation if telemetry else None,
            self.thresholds.saturation_warning,
        ),
    }

    # Evaluar estado mediante composici√≥n de diagn√≥sticos
    status, summary = self._evaluate_system_state(
        telemetry, topo_health, analyses["voltage"], analyses["saturation"]
    )

    # Construir y almacenar diagn√≥stico como elemento del fibrado
    self._last_diagnosis = TopologicalDiagnosis(
        health=topo_health,
        voltage_persistence=analyses["voltage"],
        saturation_persistence=analyses["saturation"],
        summary=summary,
        recommended_status=status,
    )

    if status != SystemStatus.NOMINAL:
        logger.info(f"[ORIENT] {self._last_diagnosis.to_log_dict()}")

    return status


def _evaluate_system_state(
    self,
    telemetry: Optional[TelemetryData],
    topo_health: TopologicalHealth,
    voltage_analysis: PersistenceAnalysisResult,
    saturation_analysis: PersistenceAnalysisResult,
) -> Tuple[SystemStatus, str]:
    """
    Eval√∫a el estado del sistema mediante una cadena de evaluadores ordenados.
    
    Implementa un ret√≠culo de decisiones donde cada evaluador es un morfismo
    parcial que puede retornar un estado o delegar al siguiente en la jerarqu√≠a.
    
    La jerarqu√≠a forma un orden parcial (poset) por criticidad:
    FRAGMENTACI√ìN > CR√çTICO > SATURADO > INESTABLE > UNKNOWN > NOMINAL
    """
    # Definir evaluadores como tuplas (condici√≥n, estado, generador_de_resumen)
    # Cada evaluador es un morfismo parcial E: (T, H, P) ‚Üí S ‚à™ {‚ä•}
    
    evaluators: list[tuple[callable, SystemStatus, callable]] = [
        # 1. Fragmentaci√≥n topol√≥gica (Œ≤‚ÇÄ > 1)
        (
            lambda: not topo_health.betti.is_connected,
            SystemStatus.DISCONNECTED,
            lambda: (
                f"Fragmentaci√≥n Topol√≥gica: Œ≤‚ÇÄ={topo_health.betti.b0}. "
                f"Nodos: [{', '.join(topo_health.disconnected_nodes) or '‚àÖ'}]"
            ),
        ),
        # 2. Sin telemetr√≠a
        (
            lambda: telemetry is None,
            SystemStatus.UNKNOWN,
            lambda: (
                f"Sin telemetr√≠a ({self._metrics.consecutive_failures} fallos)"
                if self._metrics.consecutive_failures > 0
                else "Esperando telemetr√≠a"
            ),
        ),
        # 3. Voltaje cr√≠tico instant√°neo (safety net)
        (
            lambda: telemetry and telemetry.flyback_voltage > self.thresholds.flyback_voltage_critical,
            SystemStatus.CRITICO,
            lambda: f"Voltaje cr√≠tico: {telemetry.flyback_voltage:.3f} > {self.thresholds.flyback_voltage_critical}",
        ),
        # 4. Saturaci√≥n cr√≠tica instant√°nea (safety net)
        (
            lambda: telemetry and telemetry.saturation > self.thresholds.saturation_critical,
            SystemStatus.CRITICO,
            lambda: f"Saturaci√≥n cr√≠tica: {telemetry.saturation:.3f} > {self.thresholds.saturation_critical}",
        ),
        # 5. Salud topol√≥gica cr√≠tica
        (
            lambda: topo_health.level == HealthLevel.CRITICAL,
            SystemStatus.CRITICO,
            lambda: f"Salud topol√≥gica cr√≠tica: score={topo_health.health_score:.2f}",
        ),
        # 6. Saturaci√≥n persistente CRITICAL
        (
            lambda: saturation_analysis.state == MetricState.CRITICAL,
            SystemStatus.SATURADO,
            lambda: f"Saturaci√≥n persistente: {saturation_analysis.metadata.get('active_duration', '?')} muestras",
        ),
        # 7. Saturaci√≥n con caracter√≠stica estructural (FEATURE)
        (
            lambda: saturation_analysis.state == MetricState.FEATURE,
            SystemStatus.SATURADO,
            lambda: (
                f"Patr√≥n estructural saturaci√≥n: {saturation_analysis.feature_count} feature(s), "
                f"œÄ={saturation_analysis.total_persistence:.1f}"
            ),
        ),
        # 8. Voltaje persistente CRITICAL
        (
            lambda: voltage_analysis.state == MetricState.CRITICAL,
            SystemStatus.INESTABLE,
            lambda: f"Inestabilidad voltaje: {voltage_analysis.metadata.get('active_duration', '?')} muestras",
        ),
        # 9. Voltaje con caracter√≠stica estructural
        (
            lambda: voltage_analysis.state == MetricState.FEATURE,
            SystemStatus.INESTABLE,
            lambda: f"Patr√≥n estructural voltaje: Œª_max={voltage_analysis.max_lifespan:.1f}",
        ),
        # 10. Loops de reintentos significativos
        (
            lambda: (
                topo_health.request_loops
                and topo_health.request_loops[0].count >= 5
                and topo_health.request_loops[0].request_id.startswith("FAIL_")
            ),
            SystemStatus.INESTABLE,
            lambda: f"Patr√≥n reintentos: '{topo_health.request_loops[0].request_id}' √ó{topo_health.request_loops[0].count}",
        ),
        # 11. Salud degradada
        (
            lambda: topo_health.level == HealthLevel.UNHEALTHY,
            SystemStatus.INESTABLE,
            lambda: f"Salud degradada: score={topo_health.health_score:.2f}",
        ),
    ]

    # Recorrer la cadena de evaluadores (primer match gana)
    for condition, status, summary_fn in evaluators:
        try:
            if condition():
                summary = summary_fn()
                log_level = logging.CRITICAL if status == SystemStatus.CRITICO else logging.WARNING
                logger.log(log_level, f"[EVAL] {summary}")
                return status, summary
        except Exception:
            continue  # Evaluador fall√≥, continuar con siguiente

    # Log de ruido filtrado (inmunidad a falsos positivos)
    for name, analysis in [("voltaje", voltage_analysis), ("saturaci√≥n", saturation_analysis)]:
        if analysis.state == MetricState.NOISE:
            logger.debug(f"[PERSIST] Ruido {name} filtrado: {analysis.noise_count} excursiones")

    # Estado nominal (punto fijo del sistema)
    return (
        SystemStatus.NOMINAL,
        f"Sistema nominal: Œ≤‚ÇÄ={topo_health.betti.b0}, h={topo_health.health_score:.2f}",
    )


# ============================================================================
# M√âTODOS REFINADOS - AutonomousAgent.decide
# ============================================================================

def decide(self, status: SystemStatus) -> AgentDecision:
    """
    DECIDE - Tercera fase del ciclo OODA.
    
    Implementa el morfismo de decisi√≥n D: S √ó C ‚Üí A donde:
    - S = espacio de estados
    - C = contexto topol√≥gico (diagn√≥stico previo)
    - A = espacio de acciones
    
    La decisi√≥n es una funci√≥n que preserva la estructura del problema.
    """
    # Matriz de decisi√≥n base (morfismo S ‚Üí A)
    decision_matrix: Dict[SystemStatus, AgentDecision] = {
        SystemStatus.NOMINAL: AgentDecision.HEARTBEAT,
        SystemStatus.INESTABLE: AgentDecision.EJECUTAR_LIMPIEZA,
        SystemStatus.SATURADO: AgentDecision.AJUSTAR_VELOCIDAD,
        SystemStatus.CRITICO: AgentDecision.ALERTA_CRITICA,
        SystemStatus.DISCONNECTED: AgentDecision.RECONNECT,
        SystemStatus.UNKNOWN: AgentDecision.WAIT,
    }

    decision = decision_matrix.get(status, AgentDecision.WAIT)

    # Refinamiento contextual: modular decisi√≥n seg√∫n diagn√≥stico topol√≥gico
    if self._last_diagnosis and decision == AgentDecision.HEARTBEAT:
        # Analizar campo vectorial de errores en el historial
        error_loops = [
            loop for loop in self._last_diagnosis.health.request_loops
            if loop.request_id.startswith("FAIL_")
        ]
        
        if error_loops:
            total_errors = sum(loop.count for loop in error_loops)
            logger.debug(
                f"[DECIDE] Nominal con {len(error_loops)} patrones de error "
                f"(Œ£={total_errors} eventos)"
            )
            # Potencial escalamiento futuro: considerar WAIT si errores recientes

    self._metrics.record_decision(decision)
    self._last_status = status

    return decision


# ============================================================================
# M√âTODOS REFINADOS - AutonomousAgent.act
# ============================================================================

def act(self, decision: AgentDecision) -> bool:
    """
    ACT - Cuarta fase del ciclo OODA.
    
    Implementa el morfismo de acci√≥n A: D √ó Œ£ ‚Üí Œ© donde:
    - D = espacio de decisiones
    - Œ£ = estado del diagn√≥stico
    - Œ© = espacio de efectos (side effects sobre infraestructura)
    
    Incluye debounce como operador de suavizado temporal.
    """
    if self._should_debounce(decision):
        logger.debug(f"[ACT] Suprimido por debounce: {decision.name}")
        return False

    diagnosis_msg = self._build_diagnosis_message()

    # Tabla de handlers como morfismos parciales
    action_handlers: Dict[AgentDecision, callable] = {
        AgentDecision.HEARTBEAT: lambda: self._emit_heartbeat(),
        AgentDecision.EJECUTAR_LIMPIEZA: lambda: self._execute_cleanup(diagnosis_msg),
        AgentDecision.AJUSTAR_VELOCIDAD: lambda: self._apply_backpressure(diagnosis_msg),
        AgentDecision.ALERTA_CRITICA: lambda: self._raise_critical_alert(diagnosis_msg),
        AgentDecision.RECONNECT: lambda: self._attempt_reconnection(diagnosis_msg),
        AgentDecision.WAIT: lambda: logger.info("[BRAIN] ‚è≥ Esperando telemetr√≠a..."),
    }

    handler = action_handlers.get(decision, action_handlers[AgentDecision.WAIT])
    handler()

    # Actualizar estado temporal para debounce
    self._last_decision = decision
    self._last_decision_time = datetime.now()

    return True


def _emit_heartbeat(self) -> None:
    """Emite se√±al de sistema nominal con indicador de salud."""
    health_score = self._last_diagnosis.health.health_score if self._last_diagnosis else 1.0
    indicator = "‚úÖ" if health_score >= 0.9 else "üü¢" if health_score >= 0.7 else "üü°"
    logger.info(f"[BRAIN] {indicator} NOMINAL - h={health_score:.2f}")


def _execute_cleanup(self, diagnosis_msg: str) -> None:
    """Proyecta vector de limpieza al estrato f√≠sico."""
    logger.warning(f"[BRAIN] ‚ö†Ô∏è INESTABILIDAD - {diagnosis_msg}")
    
    success = self._project_intent(
        vector="clean",
        stratum="PHYSICS",
        payload={"mode": "EMERGENCY", "reason": diagnosis_msg, "scope": "flux_condenser"},
    )
    
    event = "instability_resolved" if success else "instability_correction_failed"
    self._notify_external_system(event, {"method": "clean"})


def _apply_backpressure(self, diagnosis_msg: str) -> None:
    """Aplica backpressure reduciendo tasa de entrada."""
    logger.warning(f"[BRAIN] ‚ö†Ô∏è SATURACI√ìN - {diagnosis_msg}")
    
    success = self._project_intent(
        vector="configure",
        stratum="PHYSICS",
        payload={
            "target": "flux_condenser",
            "parameter": "input_rate",
            "action": "decrease",
            "factor": 0.5,  # Factor de reducci√≥n (homotecia)
        },
    )
    
    event = "saturation_mitigated" if success else "saturation_correction_failed"
    self._notify_external_system(event, {"method": "throttle"})


def _raise_critical_alert(self, diagnosis_msg: str) -> None:
    """Emite alerta cr√≠tica con contexto topol√≥gico completo."""
    logger.critical(f"[BRAIN] üö® CR√çTICO - {diagnosis_msg}")
    logger.critical("[BRAIN] ‚Üí Intervenci√≥n inmediata requerida")
    
    context = {"diagnosis": diagnosis_msg}
    if self._last_diagnosis:
        context.update({
            "health_score": self._last_diagnosis.health.health_score,
            "betti_b0": self._last_diagnosis.health.betti.b0,
            "is_connected": self._last_diagnosis.is_structurally_healthy,
        })
    
    self._notify_external_system("critical_alert", context)


def _attempt_reconnection(self, diagnosis_msg: str) -> None:
    """Intenta reconexi√≥n reinicializando topolog√≠a esperada."""
    logger.warning(f"[BRAIN] üîÑ DESCONEXI√ìN - {diagnosis_msg}")
    logger.warning("[BRAIN] ‚Üí Reinicializando topolog√≠a...")
    self._initialize_expected_topology()


def _build_diagnosis_message(self) -> str:
    """
    Construye mensaje de diagn√≥stico como proyecci√≥n del fibrado topol√≥gico.
    
    Serializa los invariantes relevantes del diagn√≥stico actual.
    """
    if not self._last_diagnosis:
        return "Sin diagn√≥stico"

    diag = self._last_diagnosis
    components = [diag.summary]

    # A√±adir invariantes topol√≥gicos si son informativos
    betti = diag.health.betti
    if not betti.is_ideal:
        components.append(f"Œ≤‚ÇÄ={betti.b0}")
    
    if diag.health.health_score < 0.9:
        components.append(f"h={diag.health.health_score:.2f}")

    return " | ".join(components)


# ============================================================================
# M√âTODOS REFINADOS - AutonomousAgent.get_metrics
# ============================================================================

def get_metrics(self) -> Dict[str, Any]:
    """
    Retorna m√©tricas completas como proyecci√≥n al espacio de observabilidad.
    
    Construye un diccionario estructurado que representa el estado completo
    del agente en el espacio de m√©tricas M = B √ó T √ó P √ó D donde:
    - B = m√©tricas base del agente
    - T = invariantes topol√≥gicos
    - P = estad√≠sticas de persistencia
    - D = √∫ltimo diagn√≥stico
    """
    # Base: m√©tricas del agente
    metrics = self._metrics.to_dict()
    metrics.update({
        "core_api_url": self.core_api_url,
        "check_interval": self.check_interval,
        "is_running": self._running,
        "last_status": self._last_status.name if self._last_status else None,
    })

    # Topolog√≠a: invariantes de la estructura
    topo_health = self.topology.get_topological_health(calculate_b1=False)
    metrics["topology"] = {
        "betti": {"b0": topo_health.betti.b0, "b1": topo_health.betti.b1},
        "connectivity": {
            "is_connected": topo_health.betti.is_connected,
            "is_ideal": topo_health.betti.is_ideal,
            "euler_char": topo_health.betti.euler_characteristic,
        },
        "health": {
            "score": round(topo_health.health_score, 3),
            "level": topo_health.level.name,
        },
        "issues": {
            "disconnected_nodes": list(topo_health.disconnected_nodes),
            "missing_edges": [list(e) for e in topo_health.missing_edges],
            "retry_loops": len(topo_health.request_loops),
        },
    }

    # Persistencia: estad√≠sticas de series temporales
    persistence_data = {}
    for metric_name in ("flyback_voltage", "saturation"):
        if (stats := self.persistence.get_statistics(metric_name)):
            persistence_data[metric_name] = {
                k: round(v, 4) if isinstance(v, float) else v
                for k, v in stats.items()
                if k in ("count", "min", "max", "mean", "std")
            }
    
    if persistence_data:
        metrics["persistence"] = persistence_data

    # Diagn√≥stico: √∫ltimo an√°lisis
    if self._last_diagnosis:
        metrics["last_diagnosis"] = {
            "summary": self._last_diagnosis.summary,
            "status": self._last_diagnosis.recommended_status.name,
            "metric_states": {
                "voltage": self._last_diagnosis.voltage_persistence.state.name,
                "saturation": self._last_diagnosis.saturation_persistence.state.name,
            },
        }

    return metrics


def get_topological_summary(self) -> Dict[str, Any]:
    """
    Retorna resumen topol√≥gico para dashboards.
    
    Proyecta el estado del sistema al espacio de visualizaci√≥n
    preservando la interpretaci√≥n sem√°ntica de los invariantes.
    """
    health = self.topology.get_topological_health()

    return {
        "timestamp": datetime.now().isoformat(),
        "betti": {
            "values": {"b0": health.betti.b0, "b1": health.betti.b1},
            "interpretation": (
                "Sistema conectado" if health.betti.is_connected
                else f"Sistema fragmentado en {health.betti.b0} componentes"
            ),
        },
        "health": {
            "score": round(health.health_score, 3),
            "level": health.level.name,
            "is_healthy": health.is_healthy,
        },
        "issues": {
            "disconnected": list(health.disconnected_nodes),
            "missing": [f"{u}‚Üî{v}" for u, v in health.missing_edges],
            "diagnostics": health.diagnostics,
        },
        "patterns": [
            {"id": loop.request_id, "frequency": loop.count}
            for loop in health.request_loops[:5]
        ],
    }


# ============================================================================
# M√âTODOS REFINADOS - AutonomousAgent._project_intent
# ============================================================================

def _project_intent(self, vector: str, stratum: str, payload: Dict[str, Any]) -> bool:
    """
    Proyecta intenci√≥n sobre la MIC como morfismo I: V √ó S √ó P ‚Üí {‚ä§, ‚ä•}.
    
    Args:
        vector: Nombre del vector (herramienta) - elemento del espacio de acciones
        stratum: Nivel de gobernanza - fibra del haz de control
        payload: Datos espec√≠ficos - secci√≥n local del haz
    
    Returns:
        True si la proyecci√≥n fue exitosa (imagen en ‚ä§)
    """
    intent = {
        "vector": vector,
        "stratum": stratum,
        "payload": payload,
        "context": {
            "agent_id": "apu_agent_sidecar",
            "timestamp": datetime.now().isoformat(),
            "force_physics_override": True,
            "topology_health": (
                self._last_diagnosis.health.health_score 
                if self._last_diagnosis else None
            ),
        },
    }

    url = f"{self.core_api_url}/api/tools/{vector}"
    logger.info(f"[INTENT] Proyectando '{vector}' ‚Üí estrato '{stratum}'")

    try:
        response = self._session.post(url, json=intent, timeout=self.request_timeout)
        
        if response.ok:
            logger.info(f"[INTENT] ‚úÖ {vector} ejecutado exitosamente")
            return True
        
        logger.error(f"[INTENT] ‚ùå HTTP {response.status_code}: {response.text[:100]}")
        return False

    except requests.exceptions.RequestException as e:
        logger.error(f"[INTENT] Error de proyecci√≥n: {type(e).__name__}")
        return False