### 1. Nuevo Dataclass para MÃ©tricas TopolÃ³gicas

@dataclass(frozen=True)
class TopologicalMetrics:
    """
    Invariantes topolÃ³gicos del complejo simplicial 1-dimensional.
    
    Para un grafo G = (V, E) interpretado como 1-complejo:
    - Î²â‚€: dim(Hâ‚€) = componentes conexas
    - Î²â‚: dim(Hâ‚) = ciclos independientes  
    - Ï‡: caracterÃ­stica de Euler = Î²â‚€ - Î²â‚ = |V| - |E|
    """
    beta_0: int
    beta_1: int
    euler_characteristic: int
    
    @property
    def is_connected(self) -> bool:
        """Retorna True si el espacio es conexo (Î²â‚€ = 1)."""
        return self.beta_0 == 1
    
    @property
    def is_simply_connected(self) -> bool:
        """Retorna True si el espacio es simplemente conexo (Î²â‚€ = 1, Î²â‚ = 0)."""
        return self.beta_0 == 1 and self.beta_1 == 0


### 2. Clase BudgetGraphBuilder Refinada

class BudgetGraphBuilder:
    """
    Construye el Grafo del Presupuesto como un complejo simplicial 1-dimensional.
    
    El grafo resultante es bipartito: APU â†’ INSUMO, donde cada arista
    representa un 1-simplex en la topologÃ­a del negocio.
    """

    @staticmethod
    def _sanitize_code(value: Any) -> str:
        """
        Normaliza un cÃ³digo eliminando espacios y manejando valores nulos.
        
        Args:
            value: Valor a sanitizar (puede ser None, NaN, o cualquier tipo).
            
        Returns:
            String sanitizado o cadena vacÃ­a si el valor es invÃ¡lido.
        """
        if value is None or (isinstance(value, float) and pd.isna(value)):
            return ""
        return str(value).strip()

    @staticmethod
    def _safe_float(value: Any, default: float = 0.0) -> float:
        """
        ConversiÃ³n segura a float con manejo robusto de casos edge.
        
        Args:
            value: Valor a convertir.
            default: Valor por defecto si la conversiÃ³n falla.
            
        Returns:
            Valor numÃ©rico flotante.
        """
        if value is None or (isinstance(value, float) and pd.isna(value)):
            return default
        try:
            result = float(value)
            return result if not pd.isna(result) else default
        except (ValueError, TypeError):
            return default

    def _create_apu_attributes(
        self,
        row: pd.Series,
        source: str,
        idx: int,
        inferred: bool = False
    ) -> Dict[str, Any]:
        """
        Genera atributos estandarizados para un nodo APU.
        
        Args:
            row: Fila del DataFrame con datos del APU.
            source: Identificador del DataFrame origen.
            idx: Ãndice original de la fila.
            inferred: True si el APU fue inferido desde apus_detail_df.
            
        Returns:
            Diccionario de atributos para el nodo.
        """
        attrs = {
            "type": "APU",
            "source": source,
            "original_index": idx,
            "inferred": inferred
        }
        
        if not inferred:
            attrs["description"] = str(row.get(ColumnNames.DESCRIPCION_APU, ""))
            attrs["quantity"] = self._safe_float(row.get(ColumnNames.CANTIDAD_PRESUPUESTO))
        
        return attrs

    def _create_insumo_attributes(
        self,
        row: pd.Series,
        insumo_desc: str,
        source: str,
        idx: int
    ) -> Dict[str, Any]:
        """
        Genera atributos estandarizados para un nodo INSUMO.
        
        Args:
            row: Fila del DataFrame con datos del insumo.
            insumo_desc: DescripciÃ³n del insumo (usada como ID).
            source: Identificador del DataFrame origen.
            idx: Ãndice original de la fila.
            
        Returns:
            Diccionario de atributos para el nodo.
        """
        return {
            "type": "INSUMO",
            "description": insumo_desc,
            "tipo_insumo": str(row.get(ColumnNames.TIPO_INSUMO, "")),
            "unit_cost": self._safe_float(row.get(ColumnNames.COSTO_INSUMO_EN_APU)),
            "source": source,
            "original_index": idx
        }

    def _upsert_edge(
        self,
        G: nx.DiGraph,
        apu_code: str,
        insumo_id: str,
        unit_cost: float,
        quantity: float,
        idx: int
    ) -> bool:
        """
        Inserta o actualiza una arista APU â†’ Insumo con semÃ¡ntica de agregaciÃ³n.
        
        Si la arista no existe, la crea. Si existe, agrega las cantidades
        y recalcula el costo total (comportamiento de multiset).
        
        Args:
            G: Grafo dirigido.
            apu_code: CÃ³digo del APU (nodo origen).
            insumo_id: ID del insumo (nodo destino).
            unit_cost: Costo unitario del insumo.
            quantity: Cantidad utilizada.
            idx: Ãndice original para trazabilidad.
            
        Returns:
            True si se creÃ³ una nueva arista, False si se actualizÃ³ una existente.
        """
        total_cost = unit_cost * quantity

        if not G.has_edge(apu_code, insumo_id):
            G.add_edge(
                apu_code,
                insumo_id,
                unit_cost=unit_cost,
                quantity=quantity,
                total_cost=total_cost,
                occurrence_count=1,
                original_indices=[idx]
            )
            return True
        
        # AgregaciÃ³n: sumar cantidades y costos, mantener historial
        edge_data = G[apu_code][insumo_id]
        edge_data['quantity'] = edge_data.get('quantity', 0.0) + quantity
        edge_data['total_cost'] = edge_data.get('total_cost', 0.0) + total_cost
        edge_data['occurrence_count'] = edge_data.get('occurrence_count', 0) + 1
        edge_data.setdefault('original_indices', []).append(idx)
        return False

    def _process_presupuesto_nodes(
        self,
        G: nx.DiGraph,
        presupuesto_df: Optional[pd.DataFrame]
    ) -> Set[str]:
        """
        Procesa nodos APU desde el DataFrame de presupuesto (fuente primaria).
        
        Args:
            G: Grafo donde agregar los nodos.
            presupuesto_df: DataFrame con las actividades del presupuesto.
            
        Returns:
            Conjunto de cÃ³digos APU agregados.
        """
        apu_codes: Set[str] = set()

        if presupuesto_df is None or presupuesto_df.empty:
            logger.debug("DataFrame presupuesto_df vacÃ­o o nulo")
            return apu_codes

        for idx, row in presupuesto_df.iterrows():
            apu_code = self._sanitize_code(row.get(ColumnNames.CODIGO_APU))
            
            if not apu_code or apu_code in apu_codes:
                continue

            attrs = self._create_apu_attributes(row, "presupuesto_df", idx, inferred=False)
            G.add_node(apu_code, **attrs)
            apu_codes.add(apu_code)

        logger.debug(f"Fase 1 completada: {len(apu_codes)} nodos APU primarios")
        return apu_codes

    def _process_detail_relationships(
        self,
        G: nx.DiGraph,
        apus_detail_df: Optional[pd.DataFrame]
    ) -> Dict[str, int]:
        """
        Procesa el detalle de APUs: insumos, APUs inferidos y aristas.
        
        Args:
            G: Grafo donde agregar nodos y aristas.
            apus_detail_df: DataFrame con el detalle de insumos por APU.
            
        Returns:
            Diccionario con mÃ©tricas del procesamiento.
        """
        metrics = {"inferred_apus": 0, "insumos_added": 0, "edges_created": 0, "edges_updated": 0}

        if apus_detail_df is None or apus_detail_df.empty:
            logger.debug("DataFrame apus_detail_df vacÃ­o o nulo")
            return metrics

        for idx, row in apus_detail_df.iterrows():
            apu_code = self._sanitize_code(row.get(ColumnNames.CODIGO_APU))
            insumo_desc = self._sanitize_code(row.get(ColumnNames.DESCRIPCION_INSUMO))

            # ValidaciÃ³n: ambos campos son requeridos para crear la relaciÃ³n
            if not apu_code or not insumo_desc:
                continue

            # Inferir APU si no existe en el grafo
            if apu_code not in G:
                attrs = self._create_apu_attributes(row, "apus_detail_df", idx, inferred=True)
                G.add_node(apu_code, **attrs)
                metrics["inferred_apus"] += 1

            # Agregar insumo si no existe
            if insumo_desc not in G:
                attrs = self._create_insumo_attributes(row, insumo_desc, "apus_detail_df", idx)
                G.add_node(insumo_desc, **attrs)
                metrics["insumos_added"] += 1

            # Crear o actualizar arista
            unit_cost = self._safe_float(row.get(ColumnNames.COSTO_INSUMO_EN_APU))
            quantity = self._safe_float(row.get(ColumnNames.CANTIDAD_APU))
            
            is_new_edge = self._upsert_edge(G, apu_code, insumo_desc, unit_cost, quantity, idx)
            
            if is_new_edge:
                metrics["edges_created"] += 1
            else:
                metrics["edges_updated"] += 1

        logger.debug(
            f"Fase 2 completada: {metrics['inferred_apus']} APUs inferidos, "
            f"{metrics['insumos_added']} insumos, "
            f"{metrics['edges_created']} aristas nuevas, "
            f"{metrics['edges_updated']} aristas actualizadas"
        )
        return metrics

    def _compute_graph_statistics(self, G: nx.DiGraph) -> Dict[str, int]:
        """
        Calcula estadÃ­sticas bÃ¡sicas del grafo construido.
        
        Returns:
            Diccionario con conteos por tipo de nodo.
        """
        stats = {"apu_count": 0, "insumo_count": 0, "inferred_count": 0}
        
        for _, data in G.nodes(data=True):
            node_type = data.get("type")
            if node_type == "APU":
                stats["apu_count"] += 1
                if data.get("inferred", False):
                    stats["inferred_count"] += 1
            elif node_type == "INSUMO":
                stats["insumo_count"] += 1
                
        return stats

    def build(
        self,
        presupuesto_df: pd.DataFrame,
        apus_detail_df: pd.DataFrame
    ) -> nx.DiGraph:
        """
        Construye un grafo dirigido bipartito representando la topologÃ­a del presupuesto.
        
        Estructura del grafo:
        - Nodos tipo APU: Actividades (fuentes en el grafo bipartito).
        - Nodos tipo INSUMO: Recursos (sumideros en el grafo bipartito).
        - Aristas dirigidas: APU â†’ Insumo con peso = (quantity, unit_cost, total_cost).
        
        InterpretaciÃ³n topolÃ³gica:
        - El grafo es un complejo simplicial de dimensiÃ³n 1.
        - Cada componente conexa representa un sub-presupuesto independiente.
        - Los ciclos (si existen) indican dependencias circulares anÃ³malas.
        
        Args:
            presupuesto_df: DataFrame con cÃ³digos y descripciones de APUs.
            apus_detail_df: DataFrame con la composiciÃ³n de cada APU (insumos).
            
        Returns:
            nx.DiGraph: Grafo de topologÃ­a de negocio construido.
        """
        G = nx.DiGraph(name="BudgetTopology")
        logger.info("Iniciando construcciÃ³n del Budget Graph...")

        # Fase 1: Nodos APU desde fuente primaria
        self._process_presupuesto_nodes(G, presupuesto_df)

        # Fase 2: Relaciones APU-Insumo desde detalle
        self._process_detail_relationships(G, apus_detail_df)

        # Fase 3: Logging de resumen
        stats = self._compute_graph_statistics(G)
        logger.info(
            f"Budget Graph construido: {G.number_of_nodes()} nodos "
            f"({stats['apu_count']} APUs [{stats['inferred_count']} inferidos], "
            f"{stats['insumo_count']} insumos), {G.number_of_edges()} aristas"
        )

        return G


### 3. Clase BusinessTopologicalAnalyzer Refinada

class BusinessTopologicalAnalyzer:
    """
    Analizador topolÃ³gico del grafo de negocio basado en homologÃ­a simplicial.
    
    Interpreta el grafo como un complejo simplicial K de dimensiÃ³n 1 y calcula:
    - Grupos de homologÃ­a Hâ‚€(K) y Hâ‚(K)
    - NÃºmeros de Betti Î²â‚€ = dim(Hâ‚€), Î²â‚ = dim(Hâ‚)
    - CaracterÃ­stica de Euler Ï‡ = Î²â‚€ - Î²â‚
    """

    DEFAULT_MAX_CYCLES: int = 100

    def __init__(
        self,
        telemetry: Optional[TelemetryContext] = None,
        max_cycles: int = DEFAULT_MAX_CYCLES
    ):
        """
        Inicializa el analizador topolÃ³gico.
        
        Args:
            telemetry: Contexto de telemetrÃ­a para registro de mÃ©tricas.
            max_cycles: LÃ­mite mÃ¡ximo de ciclos a detectar (para grafos grandes).
        """
        self.telemetry = telemetry
        self.max_cycles = max_cycles

    def calculate_betti_numbers(self, graph: nx.DiGraph) -> TopologicalMetrics:
        """
        Calcula los nÃºmeros de Betti del complejo simplicial 1-dimensional.
        
        Fundamento matemÃ¡tico:
        Para un 1-complejo K (grafo) con |V| vÃ©rtices y |E| aristas:
        
        1. Hâ‚€(K) â‰… â„¤^Î²â‚€ donde Î²â‚€ = nÃºmero de componentes conexas
        2. Hâ‚(K) â‰… â„¤^Î²â‚ donde Î²â‚ = dim(ker(âˆ‚â‚)) - dim(im(âˆ‚â‚‚))
        
        Para grafos (sin 2-simplices), âˆ‚â‚‚ = 0, entonces:
        Î²â‚ = dim(ker(âˆ‚â‚)) = |E| - rank(âˆ‚â‚)
        
        Por el teorema rango-nulidad y la fÃ³rmula de Euler:
        Ï‡ = |V| - |E| = Î²â‚€ - Î²â‚
        âˆ´ Î²â‚ = Î²â‚€ + |E| - |V|
        
        Nota: Para grafos dirigidos, utilizamos el grafo no dirigido subyacente
        ya que la homologÃ­a es un invariante del espacio topolÃ³gico, no de la
        orientaciÃ³n de las aristas.
        
        Args:
            graph: Grafo dirigido a analizar.
            
        Returns:
            TopologicalMetrics con Î²â‚€, Î²â‚ y Ï‡.
        """
        if graph.number_of_nodes() == 0:
            return TopologicalMetrics(beta_0=0, beta_1=0, euler_characteristic=0)

        # ProyecciÃ³n al grafo no dirigido subyacente
        undirected = graph.to_undirected()

        V = undirected.number_of_nodes()
        E = undirected.number_of_edges()

        # Î²â‚€: DimensiÃ³n de Hâ‚€ = componentes conexas
        beta_0 = nx.number_connected_components(undirected)

        # Ï‡: CaracterÃ­stica de Euler del 1-complejo
        euler_char = V - E

        # Î²â‚ = Î²â‚€ - Ï‡ (garantizamos no negatividad por propiedades de homologÃ­a)
        beta_1 = max(0, beta_0 - euler_char)

        return TopologicalMetrics(
            beta_0=beta_0,
            beta_1=beta_1,
            euler_characteristic=euler_char
        )

    def _detect_cycles(self, graph: nx.DiGraph) -> Tuple[List[str], bool]:
        """
        Detecta ciclos simples en el grafo dirigido.
        
        Un ciclo en el contexto de presupuesto indica una dependencia circular
        donde APU_a â†’ Insumo_x â†’ ... â†’ APU_a, lo cual es una anomalÃ­a estructural.
        
        Args:
            graph: Grafo dirigido a analizar.
            
        Returns:
            Tupla (lista de ciclos formateados, flag indicando si se truncÃ³).
        """
        cycles: List[str] = []
        truncated = False

        try:
            for count, cycle in enumerate(nx.simple_cycles(graph)):
                if count >= self.max_cycles:
                    truncated = True
                    logger.warning(
                        f"DetecciÃ³n de ciclos truncada en {self.max_cycles}. "
                        f"Considere incrementar max_cycles para anÃ¡lisis exhaustivo."
                    )
                    break
                # RepresentaciÃ³n cerrada del ciclo: A â†’ B â†’ C â†’ A
                cycle_repr = " â†’ ".join(cycle + [cycle[0]])
                cycles.append(cycle_repr)
                
        except Exception as e:
            logger.error(f"Error en detecciÃ³n de ciclos: {e}", exc_info=True)

        return cycles, truncated

    def _classify_anomalous_nodes(
        self,
        graph: nx.DiGraph
    ) -> Dict[str, List[Dict[str, Any]]]:
        """
        Clasifica nodos con patrones de conectividad anÃ³malos.
        
        AnomalÃ­as detectadas:
        1. Nodos aislados (deg = 0): Elementos completamente desconectados.
        2. APUs vacÃ­os (out_deg = 0): Actividades sin insumos asignados.
        3. Insumos huÃ©rfanos (in_deg = 0): Recursos no utilizados por ningÃºn APU.
        
        Args:
            graph: Grafo dirigido a analizar.
            
        Returns:
            Diccionario con listas de nodos anÃ³malos clasificados.
        """
        classification = {
            "isolated_nodes": [],
            "empty_apus": [],
            "orphan_insumos": []
        }

        isolates = set(nx.isolates(graph))

        for node, data in graph.nodes(data=True):
            node_type = data.get("type")
            in_deg = graph.in_degree(node)
            out_deg = graph.out_degree(node)

            node_info = {
                "id": node,
                "description": data.get("description", ""),
                "tipo_insumo": data.get("tipo_insumo", ""),
                "inferred": data.get("inferred", False),
                "in_degree": in_deg,
                "out_degree": out_deg
            }

            if node in isolates:
                classification["isolated_nodes"].append(node_info)
            elif node_type == "APU" and out_deg == 0:
                classification["empty_apus"].append(node_info)
            elif node_type == "INSUMO" and in_deg == 0:
                classification["orphan_insumos"].append(node_info)

        return classification

    def _identify_critical_resources(
        self,
        graph: nx.DiGraph,
        top_n: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Identifica los recursos mÃ¡s demandados (mayor in-degree).
        
        Los recursos con alto in-degree son crÃ­ticos porque:
        - Su disponibilidad afecta mÃºltiples APUs.
        - Cambios en su costo tienen impacto amplificado.
        
        Args:
            graph: Grafo dirigido a analizar.
            top_n: NÃºmero de recursos crÃ­ticos a retornar.
            
        Returns:
            Lista de diccionarios con informaciÃ³n de recursos crÃ­ticos.
        """
        insumo_degrees = []
        
        for node, data in graph.nodes(data=True):
            if data.get("type") == "INSUMO":
                in_deg = graph.in_degree(node)
                if in_deg > 0:
                    insumo_degrees.append({
                        "id": node,
                        "description": data.get("description", node),
                        "in_degree": in_deg,
                        "tipo_insumo": data.get("tipo_insumo", "")
                    })

        # Ordenar por grado descendente
        insumo_degrees.sort(key=lambda x: x["in_degree"], reverse=True)
        return insumo_degrees[:top_n]

    def _compute_connectivity_analysis(
        self,
        graph: nx.DiGraph
    ) -> Dict[str, Any]:
        """
        Analiza la estructura de conectividad del grafo.
        
        Returns:
            Diccionario con mÃ©tricas de conectividad.
        """
        wcc = list(nx.weakly_connected_components(graph))
        scc = list(nx.strongly_connected_components(graph))
        
        # SCCs no triviales (potenciales ciclos de dependencia)
        non_trivial_scc = [list(c) for c in scc if len(c) > 1]

        return {
            "weakly_connected_components": [list(c) for c in wcc],
            "strongly_connected_components": [list(c) for c in scc],
            "non_trivial_scc": non_trivial_scc,
            "num_wcc": len(wcc),
            "num_non_trivial_scc": len(non_trivial_scc),
            "is_weakly_connected": len(wcc) == 1,
            "is_dag": nx.is_directed_acyclic_graph(graph)
        }

    def _build_graph_summary(self, graph: nx.DiGraph) -> Dict[str, Any]:
        """
        Genera resumen estadÃ­stico del grafo.
        
        Returns:
            Diccionario con estadÃ­sticas descriptivas.
        """
        apu_nodes = []
        insumo_nodes = []
        inferred_count = 0

        for node, data in graph.nodes(data=True):
            if data.get("type") == "APU":
                apu_nodes.append(node)
                if data.get("inferred"):
                    inferred_count += 1
            elif data.get("type") == "INSUMO":
                insumo_nodes.append(node)

        n_apus = len(apu_nodes)
        n_edges = graph.number_of_edges()

        return {
            "total_nodes": graph.number_of_nodes(),
            "total_edges": n_edges,
            "apu_count": n_apus,
            "insumo_count": len(insumo_nodes),
            "inferred_apu_count": inferred_count,
            "density": nx.density(graph),
            "avg_insumos_per_apu": n_edges / n_apus if n_apus > 0 else 0.0
        }

    def _interpret_topology(self, metrics: TopologicalMetrics) -> Dict[str, str]:
        """
        Genera interpretaciÃ³n semÃ¡ntica de los invariantes topolÃ³gicos.
        
        Args:
            metrics: MÃ©tricas topolÃ³gicas calculadas.
            
        Returns:
            Diccionario con interpretaciones por mÃ©trica.
        """
        interpretations = {}

        # InterpretaciÃ³n de Î²â‚€
        if metrics.beta_0 == 0:
            interpretations["beta_0"] = "Grafo vacÃ­o"
        elif metrics.beta_0 == 1:
            interpretations["beta_0"] = "Presupuesto conectado (estructura coherente)"
        else:
            interpretations["beta_0"] = (
                f"{metrics.beta_0} componentes aisladas (posibles sub-presupuestos "
                f"independientes o datos incompletos)"
            )

        # InterpretaciÃ³n de Î²â‚
        if metrics.beta_1 == 0:
            interpretations["beta_1"] = "Sin ciclos (estructura acÃ­clica ideal)"
        else:
            interpretations["beta_1"] = (
                f"{metrics.beta_1} ciclo(s) independiente(s) detectado(s) "
                f"(posibles dependencias circulares)"
            )

        # InterpretaciÃ³n de Ï‡
        interpretations["euler"] = (
            f"Ï‡ = {metrics.euler_characteristic} "
            f"(|V| - |E| = {metrics.beta_0} - {metrics.beta_1})"
        )

        return interpretations

    def _emit_telemetry(self, metrics: Dict[str, Any]) -> None:
        """Emite mÃ©tricas al sistema de telemetrÃ­a si estÃ¡ disponible."""
        if not self.telemetry:
            return

        telemetry_keys = [
            "business.betti_b0", "business.betti_b1", "business.euler_characteristic",
            "business.cycles_count", "business.wcc_count", "business.non_trivial_scc_count",
            "business.isolated_count", "business.orphan_insumos_count",
            "business.empty_apus_count", "business.density", "business.is_dag"
        ]

        for key in telemetry_keys:
            if key in metrics and isinstance(metrics[key], (int, float)):
                self.telemetry.record_metric("business_topology", key, metrics[key])

    def analyze_structural_integrity(self, graph: nx.DiGraph) -> Dict[str, Any]:
        """
        Ejecuta anÃ¡lisis exhaustivo de integridad estructural del grafo.
        
        El anÃ¡lisis incluye:
        1. Invariantes homolÃ³gicos (nÃºmeros de Betti).
        2. DetecciÃ³n de ciclos (anomalÃ­as de dependencia).
        3. AnÃ¡lisis de conectividad (fragmentaciÃ³n).
        4. ClasificaciÃ³n de nodos anÃ³malos.
        5. IdentificaciÃ³n de recursos crÃ­ticos.
        
        SemÃ¡ntica topolÃ³gica:
        - Î²â‚€ = 1: Presupuesto integrado (ideal).
        - Î²â‚€ > 1: FragmentaciÃ³n (sub-presupuestos aislados).
        - Î²â‚ > 0: Ciclos de dependencia (anomalÃ­a grave).
        - is_dag = False: Presencia de ciclos dirigidos.
        
        Args:
            graph: Grafo de presupuesto a analizar.
            
        Returns:
            Diccionario con mÃ©tricas planas y detalles estructurados.
        """
        # 1. Invariantes topolÃ³gicos
        topo = self.calculate_betti_numbers(graph)
        interpretations = self._interpret_topology(topo)

        # 2. DetecciÃ³n de ciclos
        cycles, cycles_truncated = self._detect_cycles(graph)

        # 3. Conectividad
        connectivity = self._compute_connectivity_analysis(graph)

        # 4. Nodos anÃ³malos
        anomalies = self._classify_anomalous_nodes(graph)

        # 5. Recursos crÃ­ticos
        critical = self._identify_critical_resources(graph)

        # 6. Resumen del grafo
        summary = self._build_graph_summary(graph)
        summary["is_dag"] = connectivity["is_dag"]

        # MÃ©tricas planas (para telemetrÃ­a y acceso rÃ¡pido)
        flat_metrics = {
            "business.betti_b0": topo.beta_0,
            "business.betti_b1": topo.beta_1,
            "business.euler_characteristic": topo.euler_characteristic,
            "business.cycles_count": len(cycles),
            "business.cycles_truncated": cycles_truncated,
            "business.wcc_count": connectivity["num_wcc"],
            "business.non_trivial_scc_count": connectivity["num_non_trivial_scc"],
            "business.isolated_count": len(anomalies["isolated_nodes"]),
            "business.orphan_insumos_count": len(anomalies["orphan_insumos"]),
            "business.empty_apus_count": len(anomalies["empty_apus"]),
            "business.density": summary["density"],
            "business.is_dag": int(connectivity["is_dag"]),
            "business.is_connected": int(topo.is_connected),
            "business.is_simply_connected": int(topo.is_simply_connected)
        }

        # Detalles estructurados
        details = {
            "topology": {
                "betti_numbers": {
                    "beta_0": topo.beta_0,
                    "beta_1": topo.beta_1,
                    "euler_characteristic": topo.euler_characteristic
                },
                "interpretation": interpretations,
                "formula": "Ï‡ = |V| - |E| = Î²â‚€ - Î²â‚"
            },
            "cycles": {
                "circular_dependencies": cycles,
                "count": len(cycles),
                "truncated": cycles_truncated,
                "max_limit": self.max_cycles
            },
            "connectivity": {
                "weakly_connected_components": connectivity["weakly_connected_components"][:10],
                "non_trivial_strongly_connected": connectivity["non_trivial_scc"],
                "is_weakly_connected": connectivity["is_weakly_connected"],
                "is_dag": connectivity["is_dag"]
            },
            "anomalies": {
                "isolated_nodes": anomalies["isolated_nodes"],
                "empty_apus": anomalies["empty_apus"],
                "orphan_insumos": anomalies["orphan_insumos"]
            },
            "critical_resources": critical,
            "graph_summary": summary
        }

        result = {**flat_metrics, "details": details}

        # TelemetrÃ­a
        self._emit_telemetry(flat_metrics)

        return result

    def get_audit_report(self, analysis_result: Dict[str, Any]) -> List[str]:
        """
        Genera reporte de auditorÃ­a estructurado y legible.
        
        El reporte sigue la estructura:
        1. Encabezado con invariantes topolÃ³gicos.
        2. Alertas crÃ­ticas (ciclos).
        3. Advertencias (anomalÃ­as).
        4. InformaciÃ³n general.
        5. ConclusiÃ³n con severidad.
        
        Args:
            analysis_result: Resultado de analyze_structural_integrity.
            
        Returns:
            Lista de lÃ­neas del reporte.
        """
        lines: List[str] = []
        details = analysis_result.get("details", {})

        lines.extend(self._render_header(details))
        lines.extend(self._render_critical_section(details))
        lines.extend(self._render_warnings_section(details))
        lines.extend(self._render_info_section(details))
        lines.extend(self._render_conclusion(analysis_result))

        return lines

    def _render_header(self, details: Dict[str, Any]) -> List[str]:
        """Renderiza la secciÃ³n de encabezado del reporte."""
        lines = [
            "â•”" + "â•" * 58 + "â•—",
            "â•‘" + "  ANÃLISIS TOPOLÃ“GICO DEL PRESUPUESTO".center(58) + "â•‘",
            "â•š" + "â•" * 58 + "â•",
            ""
        ]

        topo = details.get("topology", {})
        betti = topo.get("betti_numbers", {})
        interp = topo.get("interpretation", {})

        lines.append("â”Œâ”€ INVARIANTES HOMOLÃ“GICOS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        lines.append(f"â”‚  Î²â‚€ (Hâ‚€ - Componentes):     {str(betti.get('beta_0', 0)).ljust(25)} â”‚")
        lines.append(f"â”‚  Î²â‚ (Hâ‚ - Ciclos):          {str(betti.get('beta_1', 0)).ljust(25)} â”‚")
        lines.append(f"â”‚  Ï‡  (Euler):                {str(betti.get('euler_characteristic', 0)).ljust(25)} â”‚")
        lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

        # Interpretaciones
        lines.append("")
        lines.append("ğŸ“ InterpretaciÃ³n:")
        for key in ["beta_0", "beta_1"]:
            if key in interp:
                lines.append(f"   â€¢ {interp[key]}")

        # Estado DAG
        connectivity = details.get("connectivity", {})
        if connectivity.get("is_dag", True):
            lines.append("")
            lines.append("âœ… Estructura: DAG vÃ¡lido (grafo acÃ­clico dirigido)")
        else:
            lines.append("")
            lines.append("âš ï¸  Estructura: Contiene ciclos dirigidos")

        return lines

    def _render_critical_section(self, details: Dict[str, Any]) -> List[str]:
        """Renderiza alertas crÃ­ticas (ciclos)."""
        lines = []
        cycles_info = details.get("cycles", {})
        cycles = cycles_info.get("circular_dependencies", [])

        if not cycles:
            return lines

        lines.extend([
            "",
            "â”Œâ”€ âŒ ALERTAS CRÃTICAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        ])
        lines.append(f"â”‚  Dependencias circulares detectadas: {len(cycles):<17} â”‚")
        lines.append("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")

        for i, cycle in enumerate(cycles[:5], 1):
            # Truncar ciclos largos para visualizaciÃ³n
            display = cycle if len(cycle) <= 50 else cycle[:47] + "..."
            lines.append(f"â”‚  {i}. {display.ljust(52)} â”‚")

        if len(cycles) > 5:
            lines.append(f"â”‚  ... y {len(cycles) - 5} ciclo(s) adicional(es){' ' * 28}â”‚")

        if cycles_info.get("truncated"):
            lines.append("â”‚  âš¡ BÃºsqueda truncada por lÃ­mite configurado          â”‚")

        lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        lines.append("   â†’ AcciÃ³n: Corregir dependencias para evitar errores de cÃ¡lculo")

        return lines

    def _render_warnings_section(self, details: Dict[str, Any]) -> List[str]:
        """Renderiza secciÃ³n de advertencias."""
        lines = []
        anomalies = details.get("anomalies", {})

        isolated = anomalies.get("isolated_nodes", [])
        empty = anomalies.get("empty_apus", [])
        orphan = anomalies.get("orphan_insumos", [])

        total_warnings = len(isolated) + len(empty) + len(orphan)
        if total_warnings == 0:
            return lines

        lines.extend([
            "",
            "â”Œâ”€ âš ï¸  ADVERTENCIAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        ])

        if empty:
            lines.append(f"â”‚  APUs sin insumos: {len(empty):<36} â”‚")
            for item in empty[:3]:
                desc = item.get('id', '')[:45]
                inferred = " (inf)" if item.get('inferred') else ""
                lines.append(f"â”‚    â€¢ {desc}{inferred.ljust(50 - len(desc))} â”‚")

        if orphan:
            lines.append(f"â”‚  Insumos no utilizados: {len(orphan):<31} â”‚")
            for item in orphan[:3]:
                desc = item.get('description', item.get('id', ''))[:48]
                lines.append(f"â”‚    â€¢ {desc.ljust(50)} â”‚")

        if isolated:
            lines.append(f"â”‚  Nodos aislados: {len(isolated):<38} â”‚")

        lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

        return lines

    def _render_info_section(self, details: Dict[str, Any]) -> List[str]:
        """Renderiza secciÃ³n informativa."""
        lines = []
        summary = details.get("graph_summary", {})
        critical = details.get("critical_resources", [])

        lines.extend([
            "",
            "â”Œâ”€ â„¹ï¸  INFORMACIÃ“N â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        ])

        lines.append(f"â”‚  Nodos: {summary.get('total_nodes', 0)} "
                    f"({summary.get('apu_count', 0)} APUs, "
                    f"{summary.get('insumo_count', 0)} Insumos)".ljust(55) + "â”‚")
        lines.append(f"â”‚  Aristas: {summary.get('total_edges', 0):<45} â”‚")
        lines.append(f"â”‚  Densidad: {summary.get('density', 0):.6f}".ljust(55) + " â”‚")
        lines.append(f"â”‚  Promedio insumos/APU: {summary.get('avg_insumos_per_apu', 0):.2f}".ljust(55) + " â”‚")

        if critical:
            lines.append("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
            lines.append("â”‚  Recursos mÃ¡s demandados (crÃ­ticos):                   â”‚")
            for item in critical[:3]:
                desc = item.get('description', item.get('id', ''))[:35]
                deg = item.get('in_degree', 0)
                lines.append(f"â”‚    â€¢ {desc} (grado: {deg})".ljust(55) + " â”‚")

        lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")

        return lines

    def _render_conclusion(self, analysis_result: Dict[str, Any]) -> List[str]:
        """Renderiza conclusiÃ³n del reporte con severidad."""
        lines = []
        details = analysis_result.get("details", {})

        cycles = len(details.get("cycles", {}).get("circular_dependencies", []))
        anomalies = details.get("anomalies", {})
        empty = len(anomalies.get("empty_apus", []))
        orphan = len(anomalies.get("orphan_insumos", []))
        isolated = len(anomalies.get("isolated_nodes", []))

        lines.append("")
        lines.append("â•”" + "â•" * 58 + "â•—")

        if cycles > 0:
            severity = "CRÃTICO"
            symbol = "âŒ"
            message = "Requiere correcciÃ³n inmediata de ciclos"
        elif empty + orphan + isolated > 0:
            severity = "ADVERTENCIA"
            symbol = "âš ï¸"
            message = "Revisar anomalÃ­as detectadas"
        else:
            severity = "OK"
            symbol = "âœ…"
            message = "TopologÃ­a estructuralmente sÃ³lida"

        lines.append(f"â•‘  {symbol} RESULTADO: {severity}".ljust(58) + " â•‘")
        lines.append(f"â•‘     {message}".ljust(59) + "â•‘")
        lines.append("â•š" + "â•" * 58 + "â•")

        # Resumen numÃ©rico
        lines.append("")
        lines.append(f"ğŸ“Š Resumen: {cycles} ciclos | {orphan + isolated} recursos huÃ©rfanos | {empty} APUs vacÃ­os")

        return lines
