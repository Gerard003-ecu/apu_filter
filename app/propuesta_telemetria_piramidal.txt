Actualmente, telemetry.py captura eventos lineales. Al aplicar la lógica piramidal (DIKW) y los estratos definidos en schemas.py, podemos hacer que la telemetría valide la causalidad topológica: ¿Es válido este error financiero (Estrategia) o es solo un eco de un fallo en la carga de datos (Física)?
Aquí tienes la extensión técnica para telemetry.py y su integración conceptual.
1. Concepto: La Telemetría como Fibrado Topológico
Basado en la definición de estratos en schemas.py y la lógica de filtración vectorial de tools_interface.py, la telemetría debe dejar de ser una lista plana para convertirse en una estructura jerárquica donde cada Span (intervalo de ejecución) pertenece a un Estrato.
La jerarquía a implementar es:
1. PHYSICS (Nivel 3): Estabilidad del flujo, I/O, FluxCondenser.
2. TACTICS (Nivel 2): Estructura del grafo, APUStructure, cálculos de costos.
3. STRATEGY (Nivel 1): Análisis financiero, Monte Carlo, RiskChallenger.
4. WISDOM (Nivel 0): Decisión final, Gobernanza, Agente.

--------------------------------------------------------------------------------
2. Modificación de telemetry.py
Debemos enriquecer TelemetrySpan y TelemetryContext para soportar esta dimensión extra.
A. Importación de Esquemas
Primero, necesitamos importar la definición oficial de los estratos.

# En app/telemetry.py
from app.schemas import Stratum  # [1] Referencia a la definición Enum

B. Enriquecimiento del TelemetrySpan
El TelemetrySpan actual es agnóstico del negocio. Lo modificamos para que sea un contenedor tipado topológicamente.

@dataclass
class TelemetrySpan:
    """
    Representa un nodo en la jerarquía de ejecución (Pirámide de Observabilidad).
    Ahora incluye consciencia de su ubicación en la topología del negocio.
    """
    name: str
    level: int
    # Nuevo campo: El estrato al que pertenece este span
    stratum: Stratum = field(default=Stratum.PHYSICS) 
    start_time: float = field(default_factory=time.perf_counter)
    end_time: Optional[float] = None
    children: List["TelemetrySpan"] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)
    # ... resto de campos ...

C. Extensión del TelemetryContext para Salud Estratificada
El contexto debe ser capaz de reportar la salud no solo globalmente, sino por capa. Si la capa Physics está enferma, la capa Strategy es irrelevante.

@dataclass
class TelemetryContext:
    # ... campos existentes [5] ...
    
    # Nuevo: Rastreo de salud por estrato
    _strata_health: Dict[Stratum, TelemetryHealth] = field(default_factory=dict)

    def __post_init__(self) -> None:
        # ... validaciones existentes [6] ...
        # Inicializar salud por estrato
        for s in Stratum:
            self._strata_health[s] = TelemetryHealth()

    def start_step(
        self, 
        step_name: str, 
        metadata: Optional[Dict[str, Any]] = None,
        stratum: Stratum = Stratum.PHYSICS  # Nuevo argumento con default seguro
    ) -> bool:
        """
        Inicia un paso asignándolo explícitamente a un estrato de la pirámide.
        """
        # ... validación de nombre [7] ...
        
        # Crear span con consciencia de estrato
        self._active_steps[step_name] = ActiveStepInfo(
            start_time=time.perf_counter(),
            metadata=metadata,
            stratum=stratum  # Guardamos el estrato en el paso activo
        )
        
        # Iniciar el span jerárquico
        # Nota: Esto requiere adaptar el contextmanager 'span' también
        logger.info(f"[{self.request_id}] Starting step: {step_name} [{stratum.name}]")
        return True

    def record_error(
        self,
        step_name: str,
        error_message: str,
        # ... otros args ...
        severity: str = "ERROR",
    ) -> Dict[str, Any]:
        """
        Registra un error y degrada la salud del estrato correspondiente.
        """
        # ... lógica de registro existente [8] ...
        
        # Lógica Topológica:
        # Identificar el estrato del paso activo
        active_info = self._active_steps.get(step_name)
        current_stratum = active_info.stratum if active_info else Stratum.PHYSICS
        
        # Degradar la salud específica de ese estrato
        self._strata_health[current_stratum].add_error(error_message)
        
        # Regla de Propagación: Un error en PHYSICS contamina TACTICS y STRATEGY
        # (La inestabilidad sube por la pirámide)
        if severity == "CRITICAL":
            self._propagate_failure_upwards(current_stratum)
            
        return error_data

    def _propagate_failure_upwards(self, failed_stratum: Stratum) -> None:
        """
        Implementa la lógica de 'Colapso Piramidal'.
        Si la base falla, los niveles superiores se marcan como inestables.
        Ref: LENGUAJE_CONSEJO.md (Pirámide Invertida)
        """
        for s in Stratum:
            # En Stratum IntEnum: WISDOM(0) < STRATEGY(1) < TACTICS(2) < PHYSICS(3)
            # Si failed_stratum es 3 (PHYSICS), afecta a 2, 1, 0.
            if s.value < failed_stratum.value:
                self._strata_health[s].add_warning(
                    f"Inestabilidad heredada del estrato inferior {failed_stratum.name}"
                )

3. Integración con el Reporte de Negocio
El método get_business_report ahora puede generar un diagnóstico estructural basado en la pirámide, alineándose con el BusinessTopologicalAnalyzer.

    def get_pyramidal_report(self) -> Dict[str, Any]:
        """
        Genera un reporte organizado por la jerarquía DIKW.
        Utilizado por el SemanticTranslator para la narrativa.
        """
        return {
            "physics_layer": {
                "status": "HEALTHY" if self._strata_health[Stratum.PHYSICS].is_healthy else "CRITICAL",
                "metrics": self._filter_metrics_by_prefix("flux_condenser"),
                "issues": self._strata_health[Stratum.PHYSICS].errors
            },
            "tactics_layer": {
                "status": "HEALTHY" if self._strata_health[Stratum.TACTICS].is_healthy else "WARNING",
                "metrics": self._filter_metrics_by_prefix("topology"), # Beta numbers
                "issues": self._strata_health[Stratum.TACTICS].errors
            },
            "strategy_layer": {
                "status": "HEALTHY" if self._strata_health[Stratum.STRATEGY].is_healthy else "UNKNOWN",
                "metrics": self._filter_metrics_by_prefix("financial"), # WACC, NPV
                "issues": self._strata_health[Stratum.STRATEGY].errors
            }
        }

4. Beneficios de la Extensión
Esta refactorización conecta los puntos ciegos entre la infraestructura y el negocio:
1. Diagnóstico Causal: Si el BusinessAgent (Estrategia) falla al calcular el ROI, la telemetría puede indicar inmediatamente: "Fallo en Estrategia debido a colapso en Física (Saturación de Ingesta)". Esto evita culpar al modelo financiero por problemas de I/O.
2. Alineación con la MIC: Dado que la LinearInteractionMatrix valida jerarquías (_validate_hierarchy), la telemetría ahora proporciona la evidencia forense de por qué una proyección de intención fue rechazada (e.g., "Intento de Estrategia sin validar Física").
3. Observabilidad de la Pirámide Invertida: Podemos visualizar en tiempo real si el sistema está gastando más tiempo de cómputo en Physics (luchando con datos sucios) que en Wisdom (generando valor), una métrica clave de eficiencia exergética mencionada en PRODUCT_VISION.md.
Para aplicar esto, es requerido actualizar app.py para pasar el stratum correcto al llamar a telemetry.start_step en cada endpoint o vector de herramienta.