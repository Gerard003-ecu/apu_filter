import logging
import math
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, NamedTuple, Optional

import pandas as pd

from .apu_processor import APUProcessor
from .report_parser_crudo import ReportParserCrudo

logger = logging.getLogger(__name__)

# ... (ParsedData, Excepciones se mantienen igual) ...
class ParsedData(NamedTuple):
    raw_records: List[Dict[str, Any]]
    parse_cache: Dict[str, Any]

class DataFluxCondenserError(Exception): pass
class InvalidInputError(DataFluxCondenserError): pass
class ProcessingError(DataFluxCondenserError): pass

@dataclass(frozen=True)
class CondenserConfig:
    min_records_threshold: int = 1
    enable_strict_validation: bool = True
    log_level: str = "INFO"
    # --- Configuraci√≥n F√≠sica RLC ---
    system_capacitance: float = 5000.0  # Faradios (Capacidad de carga)
    base_resistance: float = 10.0       # Ohmios (Fricci√≥n est√°tica)
    system_inductance: float = 2.0      # Henrios (Inercia de calidad)
    # --- Configuraci√≥n PID ---
    pid_setpoint: float = 0.30
    pid_kp: float = 2000.0
    pid_ki: float = 100.0
    min_batch_size: int = 50
    max_batch_size: int = 5000

# --- MOTOR DE F√çSICA AVANZADO (ENERG√çA) ---
class FluxPhysicsEngine:
    """
    Simula el comportamiento f√≠sico RLC bas√°ndose en la ENERG√çA.
    
    Unifica Capacitancia e Inductancia bajo funciones escalares de Energ√≠a (Julios).
    - Energ√≠a Potencial (Ec): Presi√≥n acumulada por el volumen de datos.
    - Energ√≠a Cin√©tica (El): Inercia de la calidad del flujo.
    - Energ√≠a Disipada (Er): Calor generado por la fricci√≥n de datos sucios.
    """
    def __init__(self, capacitance: float, resistance: float, inductance: float):
        self.C = capacitance  # Faradios
        self.R = resistance   # Ohmios base
        self.L = inductance   # Henrios
        
    def calculate_metrics(self, total_records: int, cache_hits: int) -> Dict[str, float]:
        """
        Calcula m√©tricas vectoriales y escalares (energ√≠a) del flujo.
        """
        if total_records == 0:
            return {
                "saturation": 0.0, "complexity": 0.0, "flyback_voltage": 0.0,
                "potential_energy": 0.0, "kinetic_energy": 0.0, "dissipated_power": 0.0
            }

        # --- VARIABLES DE ESTADO ---
        # Corriente (I): Calidad del flujo (0.0 a 1.0)
        current_I = cache_hits / total_records
        
        # Complejidad: Inversa a la corriente
        complexity = 1.0 - current_I
        
        # Resistencia Din√°mica (R_dyn)
        dynamic_R = self.R * (1 + complexity * 5)

        # Saturaci√≥n (V): Ecuaci√≥n de carga del condensador
        tau_c = dynamic_R * self.C
        # Asumimos t = total_records (tiempo l√≥gico)
        saturation_V = 1.0 - math.exp(-float(total_records) / tau_c)

        # --- C√ÅLCULOS DE ENERG√çA (ESCALARES) ---
        
        # 1. Energ√≠a Potencial (Ec = 1/2 * C * V^2)
        # Representa la carga de trabajo acumulada/presi√≥n
        potential_energy = 0.5 * self.C * (saturation_V ** 2)

        # 2. Energ√≠a Cin√©tica/Magn√©tica (El = 1/2 * L * I^2)
        # Representa el momento o inercia de la calidad.
        # Un flujo de alta calidad (I=1) tiene alta inercia y es dif√≠cil de desestabilizar.
        kinetic_energy = 0.5 * self.L * (current_I ** 2)

        # 3. Potencia Disipada (P = I_ruido^2 * R)
        # Usamos la "corriente de ruido" (1 - I) para calcular cu√°nto calor genera el error
        noise_current = 1.0 - current_I
        dissipated_power = (noise_current ** 2) * dynamic_R

        # --- C√ÅLCULO DE FLYBACK (Tensi√≥n Inductiva) ---
        # V_L = L * (di/dt) -> Cambio en la calidad
        # Aproximaci√≥n: delta_i respecto al ideal (1.0) sobre log(t)
        delta_i = 1.0 - current_I
        dt = math.log1p(total_records)
        flyback_voltage = self.L * (delta_i / dt) if dt > 0 else 0.0

        return {
            "saturation": saturation_V,
            "complexity": complexity,
            "flyback_voltage": flyback_voltage,
            # M√©tricas Energ√©ticas
            "potential_energy": potential_energy,
            "kinetic_energy": kinetic_energy,
            "dissipated_power": dissipated_power
        }

    def get_system_diagnosis(self, metrics: Dict[str, float]) -> str:
        ec = metrics["potential_energy"]
        el = metrics["kinetic_energy"]
        
        # Diagn√≥stico basado en Balance Energ√©tico
        # Queremos alta cin√©tica (buen flujo) y potencial controlada (carga manejable)
        
        if el < 0.1: # Corriente (calidad) muy baja
            return "üî¥ SISTEMA ESTANCADO (Baja Inercia)"
        
        energy_ratio = ec / el if el > 0 else float('inf')
        
        if energy_ratio > 1000: # Mucha presi√≥n, poca inercia
            return "üü† SOBRECARGA DE PRESI√ìN (Riesgo de ruptura)"
        elif metrics["flyback_voltage"] > 0.5:
            return "‚ö° PICO INDUCTIVO DETECTADO"
        else:
            return "üü¢ EQUILIBRIO ENERG√âTICO (Estable)"

# ... (PIController, DataFluxCondenser.__init__ se mantienen) ...

# --- ACTUALIZACI√ìN EN STABILIZE ---

    def stabilize(self, file_path: str) -> pd.DataFrame:
        # ... (inicio igual) ...
            
            # --- BUCLE DE CONTROL PID ---
            while current_index < total_records:
                # ... (cortar batch y procesar igual) ...
                
                # 3. Medir el estado del sistema (Sensor)
                metrics = self.physics.calculate_metrics(len(batch_records), len(batch_cache))
                
                # 4. Acci√≥n de Control (PID)
                new_batch_size = self.controller.compute(metrics["saturation"])
                
                # DIODO DE RUEDA LIBRE (Protecci√≥n basada en Energ√≠a Disipada)
                # Si se est√° disipando demasiada energ√≠a (calor/errores), forzamos freno
                if metrics["dissipated_power"] > 50.0: # Umbral arbitrario de "calor"
                    self.logger.warning(f"üî• [SOBRECALENTAMIENTO] Disipaci√≥n alta ({metrics['dissipated_power']:.1f}W). Frenando forzosamente.")
                    new_batch_size = int(new_batch_size * 0.5)

                # Telemetr√≠a Energ√©tica (NUEVO LOG)
                self.logger.info(
                    f"üîÑ [PID] Batch: {len(batch_records)} | "
                    f"Sat(V): {metrics['saturation']:.2f} | "
                    f"Ec: {metrics['potential_energy']:.0f}J | "
                    f"El: {metrics['kinetic_energy']:.2f}J | "
                    f"‚Üí Next: {new_batch_size}"
                )
                
                # ... (resto del bucle igual) ...

            # ... (finalizaci√≥n igual) ...