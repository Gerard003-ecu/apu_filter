# -*- coding: utf-8 -*-
"""
M√≥dulo de Traducci√≥n Sem√°ntica.

Este m√≥dulo act√∫a como un puente ling√º√≠stico entre las m√©tricas t√©cnicas
(topolog√≠a, finanzas) y el lenguaje de negocio estrat√©gico. Transforma
datos duros en narrativas accionables para gerentes de proyectos.
"""

import logging
import random
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Callable

from agent.business_topology import TopologicalMetrics

logger = logging.getLogger(__name__)


class FinancialVerdict(Enum):
    """Enumeraci√≥n de veredictos financieros para tipado seguro."""
    ACCEPT = "ACEPTAR"
    REJECT = "RECHAZAR"
    REVIEW = "REVISAR"


@dataclass(frozen=True)
class StabilityThresholds:
    """
    Umbrales para interpretaci√≥n del √≠ndice de estabilidad piramidal (Œ®).
    
    Fundamentaci√≥n topol√≥gica:
    - Œ® < critical: Pir√°mide invertida (m√°s APUs compuestos que insumos base)
    - critical ‚â§ Œ® < solid: Estructura equilibrada
    - Œ® ‚â• solid: Base diversificada y resiliente
    """
    critical: float = 1.0
    solid: float = 10.0


@dataclass(frozen=True)
class TopologicalThresholds:
    """
    Umbrales para interpretaci√≥n de n√∫meros de Betti.
    
    Fundamentaci√≥n:
    - Œ≤‚ÇÄ: Componentes conexos (fragmentaci√≥n si > 1)
    - Œ≤‚ÇÅ: Ciclos independientes (dependencias circulares si > 0)
    """
    connected_components_optimal: int = 1
    cycles_optimal: int = 0


class SemanticTranslator:
    """
    Traductor sem√°ntico que convierte m√©tricas t√©cnicas en narrativa estrat√©gica.
    
    Attributes:
        stability_thresholds: Configuraci√≥n de umbrales de estabilidad.
        topo_thresholds: Configuraci√≥n de umbrales topol√≥gicos.
        market_provider: Funci√≥n inyectable para obtener contexto de mercado.
    """

    def __init__(
        self,
        stability_thresholds: Optional[StabilityThresholds] = None,
        topo_thresholds: Optional[TopologicalThresholds] = None,
        market_provider: Optional[Callable[[], str]] = None,
        random_seed: Optional[int] = None
    ):
        """
        Inicializa el traductor con configuraci√≥n opcional.
        
        Args:
            stability_thresholds: Umbrales personalizados de estabilidad.
            topo_thresholds: Umbrales personalizados topol√≥gicos.
            market_provider: Funci√≥n que provee contexto de mercado (para testing/extensibilidad).
            random_seed: Semilla para reproducibilidad en selecci√≥n de tendencias.
        """
        self.stability_thresholds = stability_thresholds or StabilityThresholds()
        self.topo_thresholds = topo_thresholds or TopologicalThresholds()
        self._market_provider = market_provider
        
        if random_seed is not None:
            self._rng = random.Random(random_seed)
        else:
            self._rng = random.Random()

    def translate_topology(
        self, 
        metrics: TopologicalMetrics, 
        stability: float = 0.0
    ) -> str:
        """
        Traduce m√©tricas topol√≥gicas (n√∫meros de Betti, estabilidad) a lenguaje de negocio.

        La traducci√≥n se fundamenta en la teor√≠a de homolog√≠a:
        - Œ≤‚ÇÄ (componentes conexos) ‚Üí Fragmentaci√≥n de recursos
        - Œ≤‚ÇÅ (ciclos/agujeros) ‚Üí Dependencias circulares
        - Œ® (estabilidad piramidal) ‚Üí Robustez de cadena de suministro

        Args:
            metrics: M√©tricas de Betti (Œ≤‚ÇÄ, Œ≤‚ÇÅ).
            stability: M√©trica de estabilidad piramidal (Œ® ‚â• 0).

        Returns:
            Narrativa sobre la salud estructural del proyecto.

        Raises:
            ValueError: Si las m√©tricas son topol√≥gicamente inv√°lidas.
        """
        self._validate_topological_metrics(metrics, stability)
        
        narrative_parts: List[str] = []

        # 1. Œ≤‚ÇÅ (Primer n√∫mero de Betti: ciclos) ‚Üí Bloqueos Log√≠sticos
        narrative_parts.append(self._translate_cycles(metrics.beta_1))

        # 2. Œ≤‚ÇÄ (N√∫mero de Betti cero: componentes conexos) ‚Üí Coherencia del Alcance
        narrative_parts.append(self._translate_connectivity(metrics.beta_0))

        # 3. Œ® (Estabilidad piramidal) ‚Üí Robustez de la Cadena de Suministro
        narrative_parts.append(self._translate_stability(stability))

        return "\n".join(narrative_parts)

    def _validate_topological_metrics(
        self, 
        metrics: TopologicalMetrics, 
        stability: float
    ) -> None:
        """
        Valida la coherencia matem√°tica de las m√©tricas topol√≥gicas.
        
        Args:
            metrics: M√©tricas de Betti a validar.
            stability: √çndice de estabilidad a validar.
            
        Raises:
            ValueError: Si alguna m√©trica viola invariantes topol√≥gicos.
        """
        if not isinstance(metrics, TopologicalMetrics):
            raise ValueError(
                f"Se esperaba TopologicalMetrics, se recibi√≥ {type(metrics).__name__}"
            )
        
        if metrics.beta_0 < 0:
            raise ValueError(
                f"Œ≤‚ÇÄ debe ser no-negativo (recibido: {metrics.beta_0}). "
                "Los n√∫meros de Betti son invariantes topol√≥gicos ‚â• 0."
            )
        
        if metrics.beta_1 < 0:
            raise ValueError(
                f"Œ≤‚ÇÅ debe ser no-negativo (recibido: {metrics.beta_1}). "
                "Los n√∫meros de Betti son invariantes topol√≥gicos ‚â• 0."
            )
        
        if stability < 0:
            raise ValueError(
                f"Estabilidad Œ® debe ser no-negativa (recibido: {stability:.4f}). "
                "Un √≠ndice negativo indica error en el c√°lculo piramidal."
            )

    def _translate_cycles(self, beta_1: int) -> str:
        """
        Traduce Œ≤‚ÇÅ (ciclos independientes) a narrativa de bloqueos log√≠sticos.
        
        En topolog√≠a algebraica, Œ≤‚ÇÅ cuenta los "agujeros" 1-dimensionales,
        que en el contexto de dependencias representan ciclos cerrados
        sin punto de entrada/salida √∫nico.
        """
        if beta_1 > self.topo_thresholds.cycles_optimal:
            severity = "cr√≠ticos" if beta_1 > 2 else "detectados"
            return (
                f"üö® **Bloqueos Log√≠sticos Detectados**: Se han identificado "
                f"{beta_1} dependencia{'s' if beta_1 > 1 else ''} circular{'es' if beta_1 > 1 else ''} "
                f"en la estructura de costos. Esto representa riesgos {severity} "
                "de sobrecostos por retrabajos administrativos."
            )
        return (
            "‚úÖ **Flujo Log√≠stico Optimizado**: No se detectan dependencias "
            "circulares. La estructura de costos es directa y auditable."
        )

    def _translate_connectivity(self, beta_0: int) -> str:
        """
        Traduce Œ≤‚ÇÄ (componentes conexos) a narrativa de coherencia del alcance.
        
        En topolog√≠a algebraica, Œ≤‚ÇÄ cuenta las "piezas" desconectadas del espacio.
        Œ≤‚ÇÄ = 1 indica un proyecto cohesivo; Œ≤‚ÇÄ > 1 indica fragmentaci√≥n;
        Œ≤‚ÇÄ = 0 indicar√≠a un presupuesto vac√≠o (caso degenerado).
        """
        optimal = self.topo_thresholds.connected_components_optimal
        
        if beta_0 == 0:
            logger.warning("Œ≤‚ÇÄ = 0 detectado: el espacio topol√≥gico est√° vac√≠o.")
            return (
                "‚ö†Ô∏è **Estructura Vac√≠a**: El an√°lisis topol√≥gico indica ausencia "
                "de componentes. Verificar que el presupuesto contenga datos v√°lidos."
            )
        
        if beta_0 > optimal:
            fragmentation_level = "severa" if beta_0 > 3 else "moderada"
            return (
                f"‚ö†Ô∏è **Fragmentaci√≥n de Recursos ({fragmentation_level.title()})**: "
                f"El presupuesto muestra {beta_0} islas de informaci√≥n desconectadas. "
                "Esto sugiere que hay insumos o APUs sin trazabilidad clara "
                "hacia el proyecto central."
            )
        
        return (
            "üîó **Cohesi√≥n del Proyecto**: La totalidad del alcance est√° "
            "conectada en una estructura unificada (Œ≤‚ÇÄ = 1)."
        )

    def _translate_stability(self, stability: float) -> str:
        """
        Traduce el √≠ndice de estabilidad piramidal (Œ®) a narrativa de robustez.
        
        El √≠ndice Œ® mide la proporci√≥n entre insumos elementales (base)
        y actividades compuestas (APUs). Una pir√°mide sana tiene base ancha.
        """
        thresholds = self.stability_thresholds
        
        if stability < thresholds.critical:
            return (
                f"üìâ **Robustez de Cadena de Suministro (Cr√≠tica)**: "
                f"El √≠ndice de estabilidad es bajo (Œ® = {stability:.2f}). "
                "La base de insumos es insuficiente para soportar la complejidad "
                "de los APUs definidos (Pir√°mide Invertida). "
                f"Umbral m√≠nimo recomendado: Œ® ‚â• {thresholds.critical:.1f}."
            )
        
        if stability >= thresholds.solid:
            return (
                f"üõ°Ô∏è **Robustez de Cadena de Suministro (S√≥lida)**: "
                f"El √≠ndice de estabilidad es alto (Œ® = {stability:.2f}), "
                "indicando una base de recursos diversificada y resiliente "
                "ante interrupciones en la cadena de suministro."
            )
        
        return (
            f"‚öñÔ∏è **Robustez de Cadena de Suministro (Equilibrada)**: "
            f"El √≠ndice de estabilidad (Œ® = {stability:.2f}) muestra una "
            "relaci√≥n saludable entre insumos elementales y actividades compuestas. "
            f"Rango actual: [{thresholds.critical:.1f}, {thresholds.solid:.1f})."
        )

    def translate_financial(self, metrics: Dict[str, Any]) -> str:
        """
        Traduce m√©tricas financieras (VaR, WACC, ROI) a lenguaje de inversi√≥n estrat√©gica.

        Args:
            metrics: Diccionario de m√©tricas del FinancialEngine.
                Estructura esperada:
                {
                    "wacc": float,
                    "var": float,
                    "contingency": {"recommended": float, ...},
                    "performance": {"recommendation": str, "profitability_index": float, ...}
                }

        Returns:
            Narrativa sobre la viabilidad econ√≥mica y riesgos financieros.

        Raises:
            ValueError: Si la estructura de m√©tricas es inv√°lida.
        """
        validated = self._validate_financial_metrics(metrics)
        
        narrative_parts: List[str] = []

        # 1. WACC ‚Üí Costo de Oportunidad del Capital
        narrative_parts.append(self._translate_wacc(validated["wacc"]))

        # 2. VaR y Contingencia ‚Üí Exposici√≥n al Riesgo
        narrative_parts.append(
            self._translate_risk_exposure(validated["contingency_recommended"])
        )

        # 3. Recomendaci√≥n ‚Üí Veredicto de Viabilidad
        narrative_parts.append(
            self._translate_verdict(
                validated["recommendation"],
                validated["profitability_index"]
            )
        )

        return "\n".join(narrative_parts)

    def _validate_financial_metrics(self, metrics: Dict[str, Any]) -> Dict[str, Any]:
        """
        Valida y extrae m√©tricas financieras con valores por defecto seguros.
        
        Returns:
            Diccionario normalizado con claves garantizadas.
            
        Raises:
            ValueError: Si m√©tricas cr√≠ticas est√°n ausentes o son inv√°lidas.
        """
        if not isinstance(metrics, dict):
            raise ValueError(
                f"Se esperaba dict de m√©tricas, se recibi√≥ {type(metrics).__name__}"
            )
        
        wacc = metrics.get("wacc")
        if wacc is None:
            logger.warning("WACC no especificado, usando valor por defecto 0.0")
            wacc = 0.0
        elif not isinstance(wacc, (int, float)):
            raise ValueError(f"WACC debe ser num√©rico, recibido: {type(wacc).__name__}")
        
        contingency = metrics.get("contingency", {})
        if not isinstance(contingency, dict):
            contingency = {}
        contingency_recommended = contingency.get("recommended", 0.0)
        
        performance = metrics.get("performance", {})
        if not isinstance(performance, dict):
            performance = {}
        
        recommendation_raw = performance.get("recommendation", "REVISAR")
        try:
            recommendation = FinancialVerdict(recommendation_raw)
        except ValueError:
            logger.warning(
                f"Recomendaci√≥n '{recommendation_raw}' no reconocida, usando REVISAR"
            )
            recommendation = FinancialVerdict.REVIEW
        
        profitability_index = performance.get("profitability_index", 0.0)
        if not isinstance(profitability_index, (int, float)):
            profitability_index = 0.0
        
        return {
            "wacc": float(wacc),
            "contingency_recommended": float(contingency_recommended),
            "recommendation": recommendation,
            "profitability_index": float(profitability_index)
        }

    def _translate_wacc(self, wacc: float) -> str:
        """Traduce WACC a narrativa de costo de oportunidad."""
        wacc_assessment = ""
        if wacc > 0.15:
            wacc_assessment = " (elevado para el sector)"
        elif wacc < 0.05:
            wacc_assessment = " (competitivo)"
        
        return (
            f"üí∞ **Costo de Oportunidad del Capital (WACC)**: {wacc:.2%}{wacc_assessment}. "
            "Este es el rendimiento m√≠nimo que el proyecto debe generar para "
            "satisfacer a los inversores y acreedores."
        )

    def _translate_risk_exposure(self, contingency_recommended: float) -> str:
        """Traduce contingencia/VaR a narrativa de exposici√≥n al riesgo."""
        if contingency_recommended <= 0:
            return (
                "üìä **Exposici√≥n al Riesgo Financiero**: No se ha calculado "
                "contingencia. Revisar par√°metros de VaR y volatilidad."
            )
        
        return (
            f"üìä **Exposici√≥n al Riesgo Financiero**: Se estima una contingencia "
            f"sugerida de ${contingency_recommended:,.2f} (basada en VaR y "
            "volatilidad de mercado) para blindar el margen del proyecto."
        )

    def _translate_verdict(
        self, 
        recommendation: FinancialVerdict, 
        profitability_index: float
    ) -> str:
        """Traduce la recomendaci√≥n financiera a veredicto ejecutivo."""
        verdicts = {
            FinancialVerdict.ACCEPT: (
                f"üöÄ **Veredicto de Viabilidad**: El proyecto es FINANCIERAMENTE "
                f"VIABLE (√çndice de Rentabilidad: {profitability_index:.2f}). "
                "Se recomienda proceder, manteniendo vigilancia sobre la "
                "contingencia sugerida."
            ),
            FinancialVerdict.REJECT: (
                f"üõë **Veredicto de Viabilidad**: El proyecto presenta RIESGOS "
                f"CR√çTICOS (√çndice de Rentabilidad: {profitability_index:.2f}). "
                "Se recomienda reestructurar los costos o buscar eficiencias "
                "operativas antes de aprobar."
            ),
            FinancialVerdict.REVIEW: (
                "üîç **Veredicto de Viabilidad**: Se requiere una revisi√≥n manual "
                "profunda debido a inconsistencias en los flujos o inversi√≥n inicial."
            )
        }
        return verdicts.get(recommendation, verdicts[FinancialVerdict.REVIEW])

    def _get_market_context(self) -> str:
        """
        Obtiene inteligencia de mercado externa.
        
        Si se inyect√≥ un proveedor personalizado, lo utiliza.
        De lo contrario, simula con tendencias predefinidas.
        
        Returns:
            Narrativa de contexto de mercado.
        """
        if self._market_provider is not None:
            try:
                context = self._market_provider()
                return f"üåç **Contexto de Mercado**: {context}"
            except Exception as e:
                logger.error(f"Error obteniendo contexto de mercado: {e}")
                return "üåç **Contexto de Mercado**: No disponible temporalmente."
        
        tendencias = [
            "üìà Inflaci√≥n en materiales de acero (+2.5% m/m). "
            "Se sugiere stockeo anticipado.",
            
            "üìâ Tipo de cambio favorable para importaciones. "
            "Oportunidad de negociar con proveedores extranjeros.",
            
            "‚ö†Ô∏è Escasez de mano de obra calificada en la regi√≥n. "
            "Considerar ajustar rendimientos en APUs.",
            
            "‚öñÔ∏è Estabilidad en precios del cemento y agregados. "
            "Momento oportuno para contratos a largo plazo.",
            
            "üå™Ô∏è Alta volatilidad energ√©tica proyectada para el pr√≥ximo trimestre. "
            "Evaluar cl√°usulas de ajuste en contratos."
        ]
        
        selected_trend = self._rng.choice(tendencias)
        return f"üåç **Contexto de Mercado**: {selected_trend}"

    def compose_strategic_narrative(
        self,
        topo_metrics: TopologicalMetrics,
        fin_metrics: Dict[str, Any],
        stability: float = 0.0
    ) -> str:
        """
        Compone el reporte ejecutivo final combinando todas las dimensiones.

        Orquesta la traducci√≥n de m√©tricas topol√≥gicas, financieras y de mercado
        en un documento unificado para la toma de decisiones estrat√©gicas.

        Args:
            topo_metrics: M√©tricas estructurales (n√∫meros de Betti).
            fin_metrics: M√©tricas financieras (WACC, VaR, etc.).
            stability: Estabilidad piramidal (Œ®).

        Returns:
            Texto Markdown consolidado listo para el reporte ejecutivo.

        Raises:
            ValueError: Si las m√©tricas son inv√°lidas.
        """
        errors: List[str] = []
        
        # Traducci√≥n con manejo de errores granular
        try:
            topo_narrative = self.translate_topology(topo_metrics, stability)
        except ValueError as e:
            logger.error(f"Error en traducci√≥n topol√≥gica: {e}")
            errors.append(f"‚ö†Ô∏è Error en an√°lisis estructural: {e}")
            topo_narrative = "‚ùå No se pudo generar el an√°lisis estructural."
        
        try:
            fin_narrative = self.translate_financial(fin_metrics)
        except ValueError as e:
            logger.error(f"Error en traducci√≥n financiera: {e}")
            errors.append(f"‚ö†Ô∏è Error en an√°lisis financiero: {e}")
            fin_narrative = "‚ùå No se pudo generar el an√°lisis financiero."
        
        market_narrative = self._get_market_context()
        
        # Consejo final solo si ambas traducciones fueron exitosas
        if not errors:
            final_advice = self._generate_final_advice(topo_metrics, fin_metrics)
        else:
            final_advice = (
                "‚ö†Ô∏è **AN√ÅLISIS INCOMPLETO**: Se detectaron errores en el procesamiento. "
                f"Detalles: {'; '.join(errors)}"
            )

        sections = [
            "## üèóÔ∏è INFORME DE INTELIGENCIA ESTRAT√âGICA\n",
            "### 1. Salud Estructural y Operativa",
            topo_narrative,
            "",
            "### 2. An√°lisis de Viabilidad Econ√≥mica",
            fin_narrative,
            "",
            "### 3. Inteligencia de Mercado",
            market_narrative,
            "",
            "### üí° Recomendaci√≥n Estrat√©gica",
            final_advice
        ]
        
        return "\n".join(sections)

    def _generate_final_advice(
        self,
        topo_metrics: TopologicalMetrics,
        fin_metrics: Dict[str, Any]
    ) -> str:
        """
        Genera una recomendaci√≥n estrat√©gica de cierre basada en la matriz de decisi√≥n.
        
        La l√≥gica sigue una tabla de verdad bidimensional:
        
        |              | Œ≤‚ÇÅ > 0 (Ciclos)      | Œ≤‚ÇÅ = 0 (Sin ciclos)  |
        |--------------|----------------------|----------------------|
        | RECHAZAR     | Inviable total       | Revisar finanzas     |
        | REVISAR      | Cautela + auditar    | Evaluaci√≥n pendiente |
        | ACEPTAR      | Cautela + corregir   | Luz verde            |
        
        Args:
            topo_metrics: M√©tricas topol√≥gicas validadas.
            fin_metrics: M√©tricas financieras.
            
        Returns:
            Frase de cierre contundente y accionable.
        """
        beta_1 = topo_metrics.beta_1
        has_cycles = beta_1 > self.topo_thresholds.cycles_optimal
        
        performance = fin_metrics.get("performance", {})
        recommendation_raw = performance.get("recommendation", "REVISAR")
        
        try:
            recommendation = FinancialVerdict(recommendation_raw)
        except ValueError:
            recommendation = FinancialVerdict.REVIEW

        # Matriz de decisi√≥n expl√≠cita
        decision_matrix = {
            (True, FinancialVerdict.REJECT): (
                "‚ùå **ACCI√ìN INMEDIATA REQUERIDA**: El proyecto es inviable "
                "t√©cnica y financieramente. Detener procesos de contrataci√≥n "
                f"y auditar las {beta_1} dependencia(s) circular(es) detectada(s)."
            ),
            (True, FinancialVerdict.ACCEPT): (
                "‚ö†Ô∏è **PROCEDER CON CAUTELA**: La viabilidad financiera es positiva, "
                f"pero los {beta_1} ciclo(s) detectado(s) en el presupuesto deben "
                "corregirse antes de la ejecuci√≥n para evitar litigios contractuales."
            ),
            (True, FinancialVerdict.REVIEW): (
                f"‚ö†Ô∏è **AUDITOR√çA REQUERIDA**: Se detectaron {beta_1} ciclo(s) "
                "estructural(es) y la evaluaci√≥n financiera est√° pendiente. "
                "Priorizar correcci√≥n topol√≥gica antes de an√°lisis econ√≥mico."
            ),
            (False, FinancialVerdict.REJECT): (
                "üìâ **REVISI√ìN FINANCIERA**: La estructura t√©cnica es s√≥lida "
                "(sin ciclos), pero los n√∫meros no cierran. Revisar alcance "
                "o buscar fuentes de financiamiento m√°s competitivas."
            ),
            (False, FinancialVerdict.ACCEPT): (
                "‚úÖ **LUZ VERDE**: El proyecto demuestra coherencia t√©cnica "
                "(Œ≤‚ÇÅ = 0) y solidez financiera. Proceder a la siguiente fase "
                "de planificaci√≥n con confianza."
            ),
            (False, FinancialVerdict.REVIEW): (
                "üîç **EVALUACI√ìN INCOMPLETA**: La estructura es t√©cnicamente "
                "s√≥lida, pero no hay suficiente certeza financiera para dar "
                "luz verde. Auditar inversi√≥n inicial y proyecci√≥n de flujos."
            )
        }

        return decision_matrix.get(
            (has_cycles, recommendation),
            decision_matrix[(False, FinancialVerdict.REVIEW)]
        )