1. data_validator.txt: Validación de Integridad Piramidal
Actualmente, el validador revisa filas aisladas. Vamos a implementar la clase PyramidalValidator para asegurar que la "cimentación" (insumos) soporte la "estructura" (APUs).
Concepto: Validar la Estabilidad Estructural (Ψ) y detectar "APUs flotantes" (Nivel 2 sin soporte de Nivel 3).

# Agregar en data_validator.py

@dataclass
class PyramidalMetrics:
    """Métricas de estabilidad vertical de la pirámide de datos."""
    base_width: int  # Cantidad de Insumos únicos (Nivel 3)
    structure_load: int  # Cantidad de APUs (Nivel 2)
    pyramid_stability_index: float  # Psi = Insumos / APUs
    floating_nodes: List[str]  # APUs sin insumos (Riesgo de Colapso)

class PyramidalValidator:
    """
    Validador de integridad jerárquica.
    Asegura que la carga táctica (APUs) esté soportada por una base logística (Insumos) suficiente.
    Fuente: topologia.md (Sección 3.2 Estabilidad Estructural) [3]
    """
    
    def validate_structure(self, apus_df: pd.DataFrame, insumos_df: pd.DataFrame) -> PyramidalMetrics:
        # 1. Definir estratos
        level_3_nodes = set(insumos_df['DESCRIPCION_INSUMO_NORM'].unique())
        level_2_nodes = set(apus_df['CODIGO_APU'].unique())
        
        # 2. Calcular Psi (Ψ) - Índice de Estabilidad
        # Una pirámide estable debe tener una base amplia.
        # Si Psi < 1.0, es una "Pirámide Invertida" (Riesgo Alto).
        n_insumos = len(level_3_nodes)
        n_apus = len(level_2_nodes)
        
        psi = n_insumos / n_apus if n_apus > 0 else 0.0
        
        # 3. Detectar Nodos Flotantes (APUs sin conexión a la base)
        # Esto requiere analizar el dataframe de relaciones (detalle)
        # Aquí simulamos la lógica suponiendo que apus_df tiene el detalle desglosado
        valid_connections = apus_df[apus_df['DESCRIPCION_INSUMO_NORM'].isin(level_3_nodes)]
        connected_apus = set(valid_connections['CODIGO_APU'].unique())
        floating_apus = list(level_2_nodes - connected_apus)
        
        return PyramidalMetrics(
            base_width=n_insumos,
            structure_load=n_apus,
            pyramid_stability_index=psi,
            floating_nodes=floating_apus
        )


--------------------------------------------------------------------------------
2. data_loader.txt: Ingesta Estratificada
El cargador actual trata todos los archivos igual. Vamos a implementar HierarchyAwareLoader para etiquetar los datos con su Nivel Topológico desde el momento de la ingesta, facilitando el trabajo del Arquitecto (Topology Analyzer).
Concepto: Normalización de la entropía externa asignando niveles jerárquicos explícitos
.

# Modificar en data_loader.py

class HierarchyLevel(Enum):
    """
    Estratos de la Pirámide de Negocio.
    Fuente: topologia.md (Niveles de la Pirámide) [1]
    """
    ROOT = 0      # Proyecto Total (Ápice)
    STRATEGY = 1  # Capítulos (Pilares)
    TACTIC = 2    # APUs (Actividades)
    LOGISTICS = 3 # Insumos (Recursos Atómicos)

@dataclass
class HierarchicalData:
    """Contenedor de datos consciente de su posición topológica."""
    payload: pd.DataFrame
    level: HierarchyLevel
    lineage_hash: str

def load_data_with_hierarchy(
    path: str, 
    level: HierarchyLevel,
    **kwargs
) -> LoadResult:
    """
    Carga datos asignando su nivel en la pirámide estructural.
    """
    # 1. Carga estándar (existente)
    result = load_data(path, **kwargs)
    
    if result.status == LoadStatus.SUCCESS:
        # 2. Inyección de Metadatos Topológicos
        # Esto permite que el 'BusinessAgent' sepa qué estrato está manipulando
        result.file_metadata.hierarchy_level = level.name
        result.file_metadata.is_foundation = (level == HierarchyLevel.LOGISTICS)
        
    return result


--------------------------------------------------------------------------------
3. apu_classifier.txt: Taxonomía Basada en Soporte
Actualmente clasifica por costos. Vamos a mejorarlo para clasificar por Topología de Soporte. Un APU no es solo "Material" o "Mano de Obra" por su precio, sino por cómo se conecta con el Nivel 3 (Insumos).
Concepto: Clasificación basada en la densidad de conexiones hacia la base de la pirámide
.

# Extensión en apu_classifier.py

class StructuralClassifier(APUClassifier):
    """
    Clasificador que considera la topología de soporte del APU.
    """
    
    def classify_by_structure(self, insumos_del_apu: List[Dict]) -> str:
        """
        Clasifica el APU basándose en la naturaleza de su cimentación (Nivel 3).
        """
        # Contar tipos de nodos hoja conectados
        support_types = [i.get('TIPO_INSUMO') for i in insumos_del_apu]
        
        has_mo = 'MANO_DE_OBRA' in support_types
        has_mat = 'MATERIAL' in support_types
        
        # Regla Topológica: 
        # Si tiene soporte de Materiales pero NO de Mano de Obra, es un Suministro Puro.
        # Esto es vital para detectar 'Islas' donde se compra material pero no se instala.
        if has_mat and not has_mo:
            return "SUMINISTRO_PURO" # Nodo hoja en el grafo de ejecución
            
        # Regla Topológica:
        # Si tiene soporte de Mano de Obra pero NO de Materiales, es Servicio Puro.
        if has_mo and not has_mat:
            return "SERVICIO_PURO"
            
        return "CONSTRUCCION_MIXTA" # Nodo complejo estándar


--------------------------------------------------------------------------------
4. app.txt: El Nexo (Visibilidad del Estado Piramidal)
El archivo app.py debe exponer el estado de la pirámide al usuario. Vamos a modificar el endpoint de respuesta para incluir el Índice de Estabilidad (Ψ) y las alertas de Colapso.
Concepto: Exponer la "Salud Estructural" en el Nexo Operativo
.

# Modificar en app.py dentro de la función 'upload_files' o 'get_estimate'

def _inject_pyramidal_health(response_data: dict, session_data: dict):
    """
    Inyecta el diagnóstico de estabilidad piramidal en la respuesta API.
    Fuente: LENGUAJE_CONSEJO.md (Termodinámica Estructural) [7]
    """
    try:
        # Calcular métricas rápidas
        n_apus = len(session_data['data'].get('processed_apus', []))
        n_insumos = len(session_data['data'].get('raw_insumos_df', []))
        
        # Cálculo de Psi (Estabilidad)
        # Psi < 1.0 indica "Pirámide Invertida" (Base estrecha, alto riesgo)
        psi = n_insumos / n_apus if n_apus > 0 else 0
        
        stability_status = "SÓLIDA"
        if psi < 1.0:
            stability_status = "CRÍTICA (Pirámide Invertida)"
        elif psi < 3.0:
            stability_status = "FRÁGIL"
            
        # Inyección en el payload de respuesta
        response_data['structural_health'] = {
            'psi_index': round(psi, 2),
            'status': stability_status,
            'base_width': n_insumos,  # Nivel 3
            'apex_load': n_apus,      # Nivel 2
            'message': (
                "Riesgo de Colapso Logístico" if psi < 1.0 else "Estructura Estable"
            )
        }
    except Exception as e:
        current_app.logger.warning(f"No se pudo calcular salud piramidal: {e}")

# Uso en el endpoint:
# _inject_pyramidal_health(response_data, session)

1. Docstring Mejorado: El Legislador Estructural
Primero, actualizamos la cabecera para reflejar que este módulo define la "Constitución" del sistema, estableciendo las leyes que rigen la materia (Insumos) y la estructura (APUs).

"""
Módulo: Data Schemas (El Ontólogo del Dominio)
Rol: El Legislador - Definición de Invariantes y Topología de Tipos.

Este módulo define la "Constitución de los Datos". Establece las estructuras de datos
inmutables que representan los nodos del Grafo de Negocio. Implementa la jerarquía
piramidal (Nivel 0 a Nivel 3) asegurando que cada entidad conozca su estrato
y sus reglas de conexión permitidas.

Jerarquía Topológica (Pirámide de Negocio):
-------------------------------------------
1. Estrato LOGÍSTICO (Nivel 3 - Insumos):
   La base física. Átomos indivisibles con propiedades de masa (costo) y entropía.
   Invariante: No pueden tener hijos, solo padres.

2. Estrato TÁCTICO (Nivel 2 - APUs):
   La estructura de ejecución. Complejos simpliciales formados por la agregación
   de insumos.
   Invariante: Debe tener al menos un insumo conectado (evitar "Nodos Flotantes").

3. Estrato ESTRATÉGICO (Nivel 1 - Capítulos):
   Agrupadores lógicos que definen las fases del proyecto.

Capacidades del Esquema:
------------------------
- Validación de Invariantes: Rechazo inmediato de objetos que violen leyes físicas
  (ej. Mano de Obra sin Rendimiento).
- Tipado Fuerte: Uso de `dataclasses` y `Enums` para garantizar integridad de tipos.
- Serialización Forense: Métodos `to_dict` que preservan la metadata de linaje.

Fuente de Verdad: schemas.py, topologia.md, LENGUAJE_CONSEJO.md [1, 2]
"""


--------------------------------------------------------------------------------
2. Implementación de la Estructura Piramidal
A continuación, el código necesario para inyectar la conciencia topológica en las clases. Creamos una clase base TopologicalNode y un Enum Stratum.

from enum import IntEnum, auto
from dataclasses import dataclass, field
from typing import List, Optional, Dict

# -----------------------------------------------------------------------------
# 1. Definición de Estratos (La Jerarquía de Mando)
# Fuente: topologia.md (Sección 3.1 Niveles de la Pirámide)
# -----------------------------------------------------------------------------

class Stratum(IntEnum):
    """
    Niveles de abstracción en la topología del negocio.
    Define la 'altitud' del nodo en la pirámide de control.
    """
    ROOT = 0      # Proyecto Total (Ω) - La Cúspide
    STRATEGY = 1  # Capítulos - Los Pilares
    TACTIC = 2    # APUs - La Acción
    LOGISTICS = 3 # Insumos - La Materia (Cimentación)

# -----------------------------------------------------------------------------
# 2. Entidad Topológica Base (El Átomo Abstracto)
# -----------------------------------------------------------------------------

@dataclass
class TopologicalNode:
    """
    Clase base para todos los elementos del presupuesto.
    Garantiza que todo objeto tenga una ubicación espacial definida en la pirámide.
    """
    id: str
    stratum: Stratum
    description: str
    
    # Métricas de salud estructural (inyectadas por el TopologicalAnalyzer)
    # Fuente: LENGUAJE_CONSEJO.md (Semántica de los Números de Betti) [3]
    structural_health: float = 1.0  # 1.0 = Sólido, < 1.0 = Fragil
    is_floating: bool = False       # True si no tiene conexiones superiores (Huérfano)
    
    def validate_connectivity(self):
        """
        Verifica invariantes de conectividad básicos.
        Un nodo logístico (L3) no puede contener otros nodos.
        """
        if self.stratum == Stratum.LOGISTICS and hasattr(self, 'children') and self.children:
             raise ValueError(f"Violación de Invariante: Un nodo Logístico ({self.id}) no puede tener hijos.")

# -----------------------------------------------------------------------------
# 3. Refactorización de InsumoProcesado (Nivel 3 - La Base)
# -----------------------------------------------------------------------------

@dataclass
class InsumoProcesado(TopologicalNode):
    """
    Representa un recurso atómico en el Nivel 3 (Logística).
    Es la 'Materia' que forma la base de la pirámide.
    """
    # Campos de datos existentes...
    unidad: str = "UND"
    precio_unitario: float = 0.0
    cantidad: float = 0.0
    # ... otros campos ...

    # Inicialización del Estrato Fijo
    def __post_init__(self):
        # Forzamos el estrato a LOGÍSTICA. Esto es una ley física del sistema.
        self.stratum = Stratum.LOGISTICS
        
        # Validación de Entropía (Datos Sucios)
        # Fuente: LENGUAJE_CONSEJO.md (Entropía de Datos) [4]
        if self.precio_unitario < 0:
            raise ValueError(f"Física Violada: El precio del insumo {self.id} es negativo ({self.precio_unitario}).")
            
    @property
    def total_cost(self) -> float:
        return self.cantidad * self.precio_unitario

# -----------------------------------------------------------------------------
# 4. Nueva Clase: APU (Nivel 2 - Táctica)
# -----------------------------------------------------------------------------

@dataclass
class APUStructure(TopologicalNode):
    """
    Representa una actividad constructiva en el Nivel 2 (Táctica).
    Topológicamente, es un 'Complejo Simplicial' formado por insumos.
    """
    unit: str
    quantity: float
    # Conexiones hacia abajo (La base que lo sostiene)
    resources: List[InsumoProcesado] = field(default_factory=list)
    
    def __post_init__(self):
        self.stratum = Stratum.TACTIC

    @property
    def support_base_width(self) -> int:
        """
        Calcula el ancho de la base de soporte.
        Fuente: topologia.md (Estabilidad Piramidal)
        """
        return len(self.resources)

    @property
    def is_inverted_pyramid(self) -> bool:
        """
        Detecta si este APU específico es una pirámide invertida local.
        Si un APU complejo depende de 1 solo insumo, es un punto único de falla.
        """
        return self.quantity > 1000 and self.support_base_width == 1

    def add_resource(self, resource: InsumoProcesado):
        """Conecta un nodo de Nivel 3 a este nodo de Nivel 2."""
        if resource.stratum != Stratum.LOGISTICS:
            raise TypeError(f"Error Topológico: Un APU solo puede contener Insumos (Nivel 3), se intentó agregar {resource.stratum}")
        self.resources.append(resource)
