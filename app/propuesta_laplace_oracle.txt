import logging
import math
import time
from typing import Any, Dict, List, Optional, Tuple, Union
from dataclasses import dataclass
from enum import Enum, auto

try:
    import numpy as np
except ImportError:
    np = None

import scipy.signal
from scipy.interpolate import interp1d


class ConfigurationError(Exception):
    """Indica un problema con la configuración del sistema."""
    pass


class DampingClass(Enum):
    """Clasificación del amortiguamiento del sistema."""
    NEGATIVE = auto()
    UNDAMPED = auto()
    UNDERDAMPED = auto()
    CRITICALLY_DAMPED = auto()
    OVERDAMPED = auto()


class StabilityStatus(Enum):
    """Estado de estabilidad del sistema."""
    STABLE = auto()
    MARGINALLY_STABLE = auto()
    UNSTABLE = auto()


@dataclass(frozen=True)
class SystemParameters:
    """Parámetros físicos validados del sistema RLC."""
    R: float
    L: float
    C: float
    
    def __post_init__(self):
        if self.L <= 0 or self.C <= 0:
            raise ConfigurationError("L y C deben ser estrictamente positivos")
        if self.R < 0:
            raise ConfigurationError("R no puede ser negativo")


# ============================================================================
# CONSTANTES NUMÉRICAS PARA COHERENCIA
# ============================================================================
class NumericalConstants:
    """Constantes numéricas centralizadas para consistencia."""
    EPSILON_ZERO = 1e-12          # Umbral para comparación con cero
    EPSILON_UNITY = 1e-6          # Umbral para comparación con 1
    EPSILON_STABILITY = 1e-9      # Umbral para análisis de estabilidad
    MIN_INDUCTANCE = 1e-12        # Inductancia mínima física (pH)
    MIN_CAPACITANCE = 1e-15       # Capacitancia mínima física (fF)
    MAX_FREQUENCY_RAD = 1e12      # Frecuencia máxima razonable (THz)
    DEFAULT_SETTLING_TOLERANCE = 0.02  # 2% para tiempo de asentamiento
    NYQUIST_SAFETY_FACTOR = 10    # Factor de seguridad sobre Nyquist


# ============================================================================
# ORÁCULO DE LAPLACE - DOMINIO DE LA FRECUENCIA (REFINADO)
# ============================================================================
class LaplaceOracle:
    """
    Analizador de estabilidad en el dominio de Laplace con capacidades extendidas.
    
    Sistema RLC de segundo orden en forma canónica:
    
        H(s) = ωₙ² / (s² + 2ζωₙs + ωₙ²)
        
    Derivación desde parámetros físicos:
        
        Ecuación diferencial: L·C·(d²v/dt²) + R·C·(dv/dt) + v = u(t)
        
        Transformada de Laplace (condiciones iniciales nulas):
            (L·C·s² + R·C·s + 1)·V(s) = U(s)
            
        Función de transferencia:
            H(s) = V(s)/U(s) = 1/(L·C·s² + R·C·s + 1)
            
        Identificación de parámetros canónicos:
            ωₙ² = 1/(L·C)  →  ωₙ = 1/√(L·C)   [frecuencia natural]
            2·ζ·ωₙ = R·C/(L·C) = R/L
            ζ = R/(2·L)·√(L·C) = (R/2)·√(C/L)  [factor de amortiguamiento]
            
        Factor de calidad:
            Q = 1/(2·ζ) = (1/R)·√(L/C)
    """

    def __init__(self, R: float, L: float, C: float, sample_rate: float = 1000.0):
        """
        Inicializa el analizador con validación rigurosa.

        Args:
            R: Resistencia (Ω) - debe ser ≥ 0
            L: Inductancia (H) - debe ser > 0
            C: Capacitancia (F) - debe ser > 0
            sample_rate: Frecuencia de muestreo para análisis discreto (Hz)
            
        Raises:
            ConfigurationError: Si los parámetros son físicamente inválidos
        """
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self._nc = NumericalConstants()

        # Validación paramétrica exhaustiva
        self._validate_parameters(R, L, C, sample_rate)

        # Parámetros físicos inmutables
        self._params = SystemParameters(R=float(R), L=float(L), C=float(C))
        
        # Exponer para compatibilidad
        self.R = self._params.R
        self.L = self._params.L
        self.C = self._params.C

        # Parámetros derivados con protección numérica
        self._compute_derived_parameters()

        # Frecuencia de muestreo
        self.sample_rate = float(sample_rate)
        self.T = 1.0 / self.sample_rate

        # Construir sistemas
        self.continuous_system = self._build_continuous_system()
        self.discrete_system = self._compute_discrete_system()

        # Clasificación
        self._classify_system()

        # Cache con metadata
        self._analysis_cache: Dict[str, Dict[str, Any]] = {}
        self._cache_max_size = 50

    def _validate_parameters(self, R: float, L: float, C: float, sample_rate: float) -> None:
        """
        Validación exhaustiva de parámetros físicos con análisis dimensional.
        
        Verifica:
        1. Finitud de valores
        2. Rangos físicamente realizables
        3. Consistencia con frecuencia de muestreo (criterio de Nyquist)
        4. Advertencias para casos límite
        """
        errors = []
        warnings = []
        nc = NumericalConstants()

        # === Validación de finitud y positividad ===
        param_specs = [
            ("R", R, 0.0, 1e9, "Ω"),
            ("L", L, nc.MIN_INDUCTANCE, 1e6, "H"),
            ("C", C, nc.MIN_CAPACITANCE, 1e3, "F"),
            ("sample_rate", sample_rate, 1.0, 1e12, "Hz"),
        ]

        for name, value, min_val, max_val, unit in param_specs:
            if not isinstance(value, (int, float)):
                errors.append(f"{name} debe ser numérico, recibido: {type(value).__name__}")
                continue
            if not math.isfinite(value):
                errors.append(f"{name} debe ser finito, recibido: {value}")
            elif value < min_val:
                errors.append(f"{name} = {value} {unit} < mínimo {min_val} {unit}")
            elif value > max_val:
                warnings.append(f"{name} = {value:.2e} {unit} excede rango típico")

        if errors:
            raise ConfigurationError(
                "Parámetros físicos inválidos:\n" + "\n".join(f"  • {e}" for e in errors)
            )

        # === Análisis de consistencia física ===
        if L > 0 and C > 0:
            omega_n = 1.0 / math.sqrt(L * C)
            f_n = omega_n / (2 * math.pi)
            
            # Verificar criterio de Nyquist extendido
            nyquist_freq = sample_rate / 2
            if f_n > nyquist_freq:
                errors.append(
                    f"Frecuencia natural f_n = {f_n:.2e} Hz > f_Nyquist = {nyquist_freq:.2e} Hz. "
                    f"Aumente sample_rate a ≥ {2 * f_n * nc.NYQUIST_SAFETY_FACTOR:.0f} Hz"
                )
            elif f_n > nyquist_freq / nc.NYQUIST_SAFETY_FACTOR:
                warnings.append(
                    f"Frecuencia natural f_n = {f_n:.2e} Hz cercana a Nyquist. "
                    f"Recomendado: sample_rate ≥ {nc.NYQUIST_SAFETY_FACTOR * 2 * f_n:.0f} Hz"
                )

            # Verificar amortiguamiento
            if R > 0:
                zeta = (R / 2.0) * math.sqrt(C / L)
                if zeta < 0.01:
                    warnings.append(
                        f"Sistema casi sin amortiguamiento (ζ = {zeta:.4f}). "
                        "Riesgo de oscilaciones persistentes."
                    )
                elif zeta > 50:
                    warnings.append(
                        f"Sistema extremadamente sobreamortiguado (ζ = {zeta:.1f}). "
                        "Respuesta muy lenta, considere reducir R."
                    )

        if errors:
            raise ConfigurationError(
                "Inconsistencias físicas detectadas:\n" + "\n".join(f"  • {e}" for e in errors)
            )

        for warning in warnings:
            self.logger.warning(f"⚠️ {warning}")

    def _compute_derived_parameters(self) -> None:
        """
        Calcula parámetros derivados con manejo robusto de casos límite.
        
        Derivaciones:
            ωₙ = 1/√(LC)           Frecuencia natural no amortiguada
            ζ = (R/2)·√(C/L)       Factor de amortiguamiento
            Q = 1/(2ζ) = √(L/C)/R  Factor de calidad
            ωd = ωₙ·√(1-ζ²)        Frecuencia amortiguada (ζ < 1)
        """
        nc = self._nc
        
        # Frecuencia natural
        LC_product = self.L * self.C
        if LC_product > nc.EPSILON_ZERO:
            self.omega_n = 1.0 / math.sqrt(LC_product)
        else:
            self.omega_n = float('inf')
            self.logger.warning("Producto LC ≈ 0, ωₙ → ∞")

        # Factor de amortiguamiento
        if self.L > nc.EPSILON_ZERO:
            self.zeta = (self.R / 2.0) * math.sqrt(self.C / self.L)
        else:
            self.zeta = float('inf')

        # Factor de calidad
        if self.zeta > nc.EPSILON_ZERO:
            self.Q = 1.0 / (2.0 * self.zeta)
        else:
            self.Q = float('inf')

        # Frecuencia amortiguada (solo válida para sistemas subamortiguados)
        if 0 < self.zeta < 1.0:
            self.omega_d = self.omega_n * math.sqrt(1.0 - self.zeta**2)
        else:
            self.omega_d = 0.0

    def _build_continuous_system(self) -> scipy.signal.TransferFunction:
        """Construye la función de transferencia continua."""
        # H(s) = 1 / (LCs² + RCs + 1)
        num = [1.0]
        den = [self.L * self.C, self.R * self.C, 1.0]
        
        try:
            return scipy.signal.TransferFunction(num, den)
        except Exception as e:
            raise ConfigurationError(f"Error construyendo sistema continuo: {e}")

    def _classify_system(self) -> None:
        """
        Clasifica el sistema según su factor de amortiguamiento.
        
        Clasificación basada en la naturaleza de los polos:
        
        | Condición     | Polos                        | Comportamiento           |
        |---------------|------------------------------|--------------------------|
        | ζ < 0         | RHP (parte real > 0)         | Inestable, divergente    |
        | ζ = 0         | Imaginarios puros ±jωₙ       | Oscilador armónico       |
        | 0 < ζ < 1     | Complejos conjugados LHP     | Oscilación amortiguada   |
        | ζ = 1         | Real doble: -ωₙ              | Crítico (más rápido)     |
        | ζ > 1         | Reales distintos LHP         | Exponencial monótona     |
        """
        nc = self._nc
        
        if self.zeta < -nc.EPSILON_ZERO:
            self.damping_class = DampingClass.NEGATIVE
            self.stability_status = StabilityStatus.UNSTABLE
            self.response_type = "DIVERGENT_OSCILLATORY"
            
        elif abs(self.zeta) < nc.EPSILON_ZERO:
            self.damping_class = DampingClass.UNDAMPED
            self.stability_status = StabilityStatus.MARGINALLY_STABLE
            self.response_type = "SUSTAINED_OSCILLATION"
            
        elif self.zeta < 1.0 - nc.EPSILON_UNITY:
            self.damping_class = DampingClass.UNDERDAMPED
            self.stability_status = StabilityStatus.STABLE
            self.response_type = "DAMPED_OSCILLATION"
            
        elif abs(self.zeta - 1.0) < nc.EPSILON_UNITY:
            self.damping_class = DampingClass.CRITICALLY_DAMPED
            self.stability_status = StabilityStatus.STABLE
            self.response_type = "CRITICAL_EXPONENTIAL"
            
        else:
            self.damping_class = DampingClass.OVERDAMPED
            self.stability_status = StabilityStatus.STABLE
            self.response_type = "OVERDAMPED_EXPONENTIAL"

    def _compute_discrete_system(self) -> scipy.signal.TransferFunction:
        """
        Convierte sistema continuo a discreto usando transformación bilineal (Tustin)
        con pre-warping en la frecuencia natural.
        
        Transformación bilineal estándar:
            s = (2/T) · (z-1)/(z+1)
            
        Con pre-warping en ω₀:
            s = (ω₀/tan(ω₀T/2)) · (z-1)/(z+1)
            
        Esto asegura que la frecuencia ω₀ en el dominio continuo mapea exactamente
        a la misma frecuencia en el dominio discreto.
        
        Para H(s) = 1/(a₂s² + a₁s + a₀), la sustitución produce:
        
        H(z) = [(z+1)²] / [A(z-1)² + B(z-1)(z+1) + C(z+1)²]
        
        donde A = a₂k², B = a₁k, C = a₀, y k es el factor de pre-warping.
        """
        T = self.T
        nc = self._nc

        # Frecuencia crítica para pre-warping
        omega_critical = self.omega_n if self.omega_n > 0 and self.omega_n < nc.MAX_FREQUENCY_RAD else 1.0 / T

        # Coeficiente de pre-warping con protección numérica
        omega_T_half = omega_critical * T / 2.0
        
        if omega_T_half < nc.EPSILON_ZERO:
            # Aproximación de Taylor: tan(x) ≈ x para x pequeño
            k = 2.0 / T
        elif omega_T_half > math.pi / 2 - 0.01:
            # Frecuencia demasiado alta para discretización estable
            self.logger.error(
                f"ωT/2 = {omega_T_half:.3f} ≈ π/2. Sistema continuo demasiado rápido "
                f"para sample_rate = {self.sample_rate} Hz"
            )
            k = 2.0 / T  # Fallback sin pre-warping
        else:
            k = omega_critical / math.tan(omega_T_half)

        # Coeficientes del sistema continuo: H(s) = 1/(a₂s² + a₁s + a₀)
        a2 = self.L * self.C
        a1 = self.R * self.C
        a0 = 1.0

        # Transformación bilineal expandida
        k2 = k * k

        # Denominador: D(z) = a₂k²(z-1)² + a₁k(z-1)(z+1) + a₀(z+1)²
        # Expandiendo:
        #   a₂k²(z² - 2z + 1) + a₁k(z² - 1) + a₀(z² + 2z + 1)
        # = (a₂k² + a₁k + a₀)z² + (-2a₂k² + 2a₀)z + (a₂k² - a₁k + a₀)
        
        den_z2 = a2 * k2 + a1 * k + a0
        den_z1 = 2.0 * (a0 - a2 * k2)
        den_z0 = a2 * k2 - a1 * k + a0

        # Numerador: N(z) = (z+1)² = z² + 2z + 1
        num_z2 = 1.0
        num_z1 = 2.0
        num_z0 = 1.0

        # Validar denominador líder
        if abs(den_z2) < nc.EPSILON_ZERO:
            self.logger.warning(
                "Coeficiente líder del denominador discreto ≈ 0. "
                "Retornando aproximación de primer orden."
            )
            # Fallback: discretización de primer orden
            return scipy.signal.TransferFunction([1.0], [1.0], dt=T)

        # Normalizar
        num = np.array([num_z2, num_z1, num_z0]) / den_z2
        den = np.array([1.0, den_z1 / den_z2, den_z0 / den_z2])

        # Validación de estabilidad discreta
        self._validate_discrete_stability(den)

        try:
            return scipy.signal.TransferFunction(num.tolist(), den.tolist(), dt=T)
        except Exception as e:
            self.logger.error(f"Error en discretización: {e}")
            return self.continuous_system

    def _validate_discrete_stability(self, den_coeffs: np.ndarray) -> None:
        """
        Valida estabilidad del sistema discreto verificando que todos los polos
        estén dentro del círculo unitario.
        
        Criterio: |pᵢ| < 1 para todo polo pᵢ
        """
        if np is None:
            return

        try:
            roots = np.roots(den_coeffs)
            magnitudes = np.abs(roots)
            max_magnitude = np.max(magnitudes) if len(magnitudes) > 0 else 0

            if max_magnitude > 1.0 + self._nc.EPSILON_STABILITY:
                self.logger.error(
                    f"⚠️ Sistema discreto INESTABLE: max|polo| = {max_magnitude:.6f} > 1. "
                    f"Aumente sample_rate de {self.sample_rate:.0f} Hz a "
                    f"≥ {self.sample_rate * max_magnitude**2:.0f} Hz"
                )
            elif max_magnitude > 0.99:
                self.logger.warning(
                    f"Sistema discreto marginalmente estable: max|polo| = {max_magnitude:.6f}"
                )
        except Exception as e:
            self.logger.warning(f"No se pudo validar estabilidad discreta: {e}")

    def _calculate_stability_margins(self) -> Dict[str, Any]:
        """
        Calcula márgenes de estabilidad usando soluciones analíticas exactas
        para sistemas de segundo orden.
        
        Para H(s) = ωₙ²/(s² + 2ζωₙs + ωₙ²):
        
        MARGEN DE GANANCIA (GM):
            - Frecuencia de cruce de fase ω_pc: donde ∠H(jω) = -180°
            - Para 2º orden sin ceros: ∠H(jω) → -180° solo cuando ω → ∞
            - Por lo tanto: GM = ∞ (sistema siempre estable bajo ganancia)
        
        MARGEN DE FASE (PM):
            - Frecuencia de cruce de ganancia ω_gc: donde |H(jω)| = 1
            - Condición: |H(jω_gc)|² = 1
            
            Derivación:
                |H(jω)|² = ωₙ⁴ / [(ωₙ² - ω²)² + (2ζωₙω)²]
                
                Igualando a 1:
                ωₙ⁴ = (ωₙ² - ω²)² + 4ζ²ωₙ²ω²
                
                Expandiendo y simplificando:
                ω⁴ + (4ζ² - 2)ωₙ²ω² = 0
                ω²[ω² + (4ζ² - 2)ωₙ²] = 0
                
                Solución no trivial:
                ω_gc² = (2 - 4ζ²)ωₙ² = 2(1 - 2ζ²)ωₙ²
                
                Existe si: 1 - 2ζ² > 0  →  ζ < 1/√2 ≈ 0.707
                
            Fase en ω_gc:
                ∠H(jω_gc) = -arctan(2ζω_gc·ωₙ / (ωₙ² - ω_gc²))
                
            Margen de fase:
                PM = 180° + ∠H(jω_gc)
        """
        nc = self._nc
        
        # Margen de ganancia siempre infinito para 2º orden pasivo
        gain_margin_db = float('inf')
        omega_pc = float('inf')  # Cruce de fase en infinito

        # Análisis según régimen de amortiguamiento
        if self.zeta <= nc.EPSILON_ZERO:
            # Sistema inestable o marginalmente estable
            return {
                "gain_margin_db": gain_margin_db,
                "phase_margin_deg": 0.0,
                "gain_crossover_freq_rad_s": self.omega_n,
                "phase_crossover_freq_rad_s": omega_pc,
                "is_margin_meaningful": False,
                "regime": "UNDAMPED_OR_UNSTABLE",
                "interpretation": "Sistema sin amortiguamiento - PM = 0°"
            }

        # Umbral crítico: ζ_crit = 1/√2 ≈ 0.7071
        zeta_critical = 1.0 / math.sqrt(2.0)
        
        if self.zeta < zeta_critical - nc.EPSILON_UNITY:
            # Caso subamortiguado con cruce de ganancia real
            # ω_gc = ωₙ·√(2 - 4ζ²) = ωₙ·√(2(1 - 2ζ²))
            discriminant = 2.0 * (1.0 - 2.0 * self.zeta**2)
            omega_gc = self.omega_n * math.sqrt(max(0.0, discriminant))
            
            # Fase en ω_gc usando arctan2 para manejo correcto de cuadrantes
            # H(jω) = ωₙ² / (ωₙ² - ω² + j·2ζωₙω)
            # ∠H = -arctan2(2ζωₙω, ωₙ² - ω²)
            
            omega_ratio = omega_gc / self.omega_n
            numerator_phase = 0.0  # Numerador real positivo
            denominator_real = 1.0 - omega_ratio**2
            denominator_imag = 2.0 * self.zeta * omega_ratio
            
            phase_at_gc = -math.atan2(denominator_imag, denominator_real)
            phase_margin_deg = 180.0 + math.degrees(phase_at_gc)
            
            # Fórmula cerrada alternativa (verificación):
            # PM = arctan(2ζ/√(√(1 + 4ζ⁴) - 2ζ²))
            term = math.sqrt(1.0 + 4.0 * self.zeta**4) - 2.0 * self.zeta**2
            if term > nc.EPSILON_ZERO:
                pm_closed_form = math.degrees(math.atan(2.0 * self.zeta / math.sqrt(term)))
                # Usar promedio ponderado para robustez numérica
                phase_margin_deg = 0.5 * (phase_margin_deg + pm_closed_form)
            
            is_meaningful = True
            regime = "UNDERDAMPED_WITH_CROSSOVER"
            
        elif self.zeta < 1.0 - nc.EPSILON_UNITY:
            # Subamortiguado pero sin cruce formal (ζ cerca de 0.707)
            # Usar frecuencia natural como referencia
            omega_gc = self.omega_n
            phase_at_omega_n = -math.pi / 2.0  # -90° en ω = ωₙ
            phase_margin_deg = 180.0 + math.degrees(phase_at_omega_n)  # = 90°
            
            is_meaningful = False
            regime = "UNDERDAMPED_NO_FORMAL_CROSSOVER"
            
        elif abs(self.zeta - 1.0) < nc.EPSILON_UNITY:
            # Críticamente amortiguado
            omega_gc = self.omega_n
            # Fase en ω = ωₙ para ζ = 1: ∠H = -arctan(2) ≈ -63.43°
            phase_margin_deg = 180.0 - math.degrees(math.atan(2.0))  # ≈ 116.57°
            
            is_meaningful = False
            regime = "CRITICALLY_DAMPED"
            
        else:
            # Sobreamortiguado: |H(jω)| < 1 para todo ω
            omega_gc = 0.0
            phase_margin_deg = 180.0  # Efectivamente infinito
            
            is_meaningful = False
            regime = "OVERDAMPED"

        interpretation = self._generate_margin_interpretation(
            self.zeta, phase_margin_deg, regime
        )

        return {
            "gain_margin_db": gain_margin_db,
            "phase_margin_deg": phase_margin_deg,
            "gain_crossover_freq_rad_s": omega_gc,
            "phase_crossover_freq_rad_s": omega_pc,
            "is_margin_meaningful": is_meaningful,
            "regime": regime,
            "zeta_critical": zeta_critical,
            "interpretation": interpretation,
            # Compatibilidad hacia atrás
            "derivation_method": "exact_analytical_second_order",
            "notes": interpretation,
        }

    def _generate_margin_interpretation(self, zeta: float, pm_deg: float, regime: str) -> str:
        """Genera interpretación técnica de los márgenes de estabilidad."""
        
        interpretations = {
            "UNDAMPED_OR_UNSTABLE": (
                f"Sistema sin amortiguamiento efectivo (ζ ≈ 0). "
                f"Marginalmente estable con oscilación sostenida en ω = {self.omega_n:.3f} rad/s."
            ),
            "UNDERDAMPED_WITH_CROSSOVER": (
                f"Sistema subamortiguado (ζ = {zeta:.4f}). "
                f"PM = {pm_deg:.1f}° indica {'buena' if pm_deg > 45 else 'marginal'} "
                f"robustez ante retardos de fase. "
                f"{'Considere aumentar ζ.' if pm_deg < 45 else ''}"
            ),
            "UNDERDAMPED_NO_FORMAL_CROSSOVER": (
                f"Sistema subamortiguado (ζ = {zeta:.4f} ≈ 1/√2). "
                f"Sin cruce de ganancia formal; PM = {pm_deg:.1f}° es referencial en ω = ωₙ."
            ),
            "CRITICALLY_DAMPED": (
                f"Sistema críticamente amortiguado (ζ = 1). "
                f"Respuesta más rápida sin sobrepaso. Inherentemente robusto."
            ),
            "OVERDAMPED": (
                f"Sistema sobreamortiguado (ζ = {zeta:.3f}). "
                f"Ganancia siempre < 1, PM efectivamente infinito. "
                f"Sistema lento pero muy robusto."
            ),
        }
        
        return interpretations.get(regime, f"Régimen: {regime}, ζ = {zeta:.4f}")

    def _calculate_transient_metrics(self) -> Dict[str, Any]:
        """
        Calcula métricas de respuesta transitoria ante entrada escalón unitario.
        
        Para H(s) = ωₙ²/(s² + 2ζωₙs + ωₙ²), la respuesta al escalón es:
        
        CASO SUBAMORTIGUADO (0 < ζ < 1):
            y(t) = 1 - (e^(-ζωₙt)/√(1-ζ²))·sin(ωdt + φ)
            donde ωd = ωₙ√(1-ζ²) y φ = arccos(ζ)
            
            Métricas derivadas analíticamente:
            
            • Tiempo de subida (10% → 90%):
              t_r ≈ (π - arccos(ζ)) / ωd  [exacto]
              t_r ≈ (1.76ζ² - 0.417ζ + 1.039) / ωₙ  [aproximación empírica]
              
            • Tiempo de pico:
              t_p = π / ωd
              
            • Sobrepaso porcentual:
              M_p = exp(-πζ/√(1-ζ²)) × 100%
              
            • Tiempo de asentamiento (criterio ε):
              La envolvente es: e(t) = (1/√(1-ζ²))·e^(-ζωₙt)
              Para e(t_s) = ε:
              t_s = -ln(ε·√(1-ζ²)) / (ζωₙ)
        
        CASO CRÍTICAMENTE AMORTIGUADO (ζ = 1):
            y(t) = 1 - (1 + ωₙt)·e^(-ωₙt)
            
            • t_r ≈ 3.358 / ωₙ  (10% → 90%)
            • t_s(2%) ≈ 5.834 / ωₙ
            
        CASO SOBREAMORTIGUADO (ζ > 1):
            Polos reales: s₁,₂ = -ζωₙ ± ωₙ√(ζ²-1)
            
            • τ_dominante = 1/|s_lento|
            • t_r ≈ 2.2·τ_dominante
            • t_s ≈ 4·τ_dominante
        """
        nc = self._nc
        tol = nc.DEFAULT_SETTLING_TOLERANCE

        # === Caso inestable ===
        if self.zeta < -nc.EPSILON_ZERO:
            return {
                "status": "UNSTABLE",
                "warning": f"Sistema inestable (ζ = {self.zeta:.4f} < 0). Respuesta divergente.",
                "metrics": {},
            }

        # === Caso sin amortiguamiento ===
        if abs(self.zeta) < nc.EPSILON_ZERO:
            period = 2.0 * math.pi / self.omega_n if self.omega_n > 0 else float('inf')
            return {
                "status": "UNDAMPED",
                "rise_time_s": period / 4.0,
                "peak_time_s": period / 2.0,
                "overshoot_percent": 100.0,
                "settling_time_s": float('inf'),
                "oscillation_period_s": period,
                "oscillation_frequency_hz": self.omega_n / (2.0 * math.pi),
                "peak_value": 2.0,
                "steady_state_value": 1.0,
                "warning": "Oscilación armónica sostenida - no converge a estado estacionario.",
            }

        # === Caso subamortiguado (0 < ζ < 1) ===
        if self.zeta < 1.0 - nc.EPSILON_UNITY:
            omega_d = self.omega_d  # Frecuencia amortiguada
            
            # Tiempo de subida: fórmula exacta
            phi = math.acos(self.zeta)
            rise_time_exact = (math.pi - phi) / omega_d
            
            # Aproximación empírica (más precisa para 0.3 ≤ ζ ≤ 0.8)
            rise_time_approx = (1.76 * self.zeta**2 - 0.417 * self.zeta + 1.039) / self.omega_n
            
            # Usar exacta siempre (es derivada, no aproximada)
            rise_time = rise_time_exact
            
            # Tiempo de pico
            peak_time = math.pi / omega_d
            
            # Sobrepaso: M_p = exp(-πζ/√(1-ζ²))
            damping_factor = self.zeta / math.sqrt(1.0 - self.zeta**2)
            overshoot_factor = math.exp(-math.pi * damping_factor)
            overshoot_percent = overshoot_factor * 100.0
            
            # Tiempo de asentamiento con derivación correcta
            # |y(t) - 1| ≤ (1/√(1-ζ²))·e^(-ζωₙt) = tol
            sqrt_term = math.sqrt(1.0 - self.zeta**2)
            settling_argument = tol * sqrt_term
            
            if settling_argument > nc.EPSILON_ZERO and settling_argument < 1.0:
                settling_time = -math.log(settling_argument) / (self.zeta * self.omega_n)
            else:
                # Fallback a aproximación estándar
                settling_time = 4.0 / (self.zeta * self.omega_n)
            
            # Número de oscilaciones antes de asentarse
            n_oscillations = settling_time * omega_d / (2.0 * math.pi)
            
            return {
                "status": "UNDERDAMPED",
                "rise_time_s": rise_time,
                "rise_time_approx_s": rise_time_approx,
                "peak_time_s": peak_time,
                "overshoot_percent": overshoot_percent,
                "overshoot_factor": overshoot_factor,
                "settling_time_2pct_s": settling_time,
                "settling_time_5pct_s": settling_time * math.log(0.02) / math.log(0.05),
                "settling_time_s": settling_time,  # Compatibilidad
                "peak_value": 1.0 + overshoot_factor,
                "steady_state_value": 1.0,
                "damped_frequency_rad_s": omega_d,
                "damped_frequency_hz": omega_d / (2.0 * math.pi),
                "damped_period_s": 2.0 * math.pi / omega_d,
                "oscillations_to_settle": n_oscillations,
                "decay_rate_per_cycle": 1.0 - math.exp(-2.0 * math.pi * damping_factor),
            }

        # === Caso críticamente amortiguado (ζ ≈ 1) ===
        if abs(self.zeta - 1.0) < nc.EPSILON_UNITY:
            # Coeficientes exactos derivados de y(t) = 1 - (1 + ωₙt)e^(-ωₙt)
            # t_r: resolver y(t_r) = 0.9 y y(t_0) = 0.1 numéricamente da:
            rise_time = 3.3579 / self.omega_n
            
            # t_s(2%): resolver (1 + ωₙt)e^(-ωₙt) = 0.02
            settling_time_2pct = 5.8335 / self.omega_n
            settling_time_5pct = 4.7439 / self.omega_n
            
            return {
                "status": "CRITICALLY_DAMPED",
                "rise_time_s": rise_time,
                "peak_time_s": float('inf'),  # No hay pico
                "overshoot_percent": 0.0,
                "settling_time_2pct_s": settling_time_2pct,
                "settling_time_5pct_s": settling_time_5pct,
                "settling_time_s": settling_time_2pct,
                "peak_value": 1.0,  # Valor máximo es el estado estacionario
                "steady_state_value": 1.0,
                "characteristic_time_s": 1.0 / self.omega_n,
                "note": "Respuesta monótona más rápida posible sin sobrepaso.",
            }

        # === Caso sobreamortiguado (ζ > 1) ===
        # Polos: s₁,₂ = -ζωₙ ± ωₙ√(ζ²-1)
        sqrt_discriminant = math.sqrt(self.zeta**2 - 1.0)
        s1 = -self.omega_n * (self.zeta - sqrt_discriminant)  # Polo lento (más cercano a 0)
        s2 = -self.omega_n * (self.zeta + sqrt_discriminant)  # Polo rápido
        
        tau_slow = 1.0 / abs(s1)
        tau_fast = 1.0 / abs(s2)
        
        # Aproximaciones basadas en polo dominante
        rise_time = 2.2 * tau_slow
        settling_time = 4.0 * tau_slow
        
        # Ratio de separación de polos
        pole_ratio = abs(s2 / s1)
        
        return {
            "status": "OVERDAMPED",
            "rise_time_s": rise_time,
            "peak_time_s": float('inf'),
            "overshoot_percent": 0.0,
            "settling_time_s": settling_time,
            "settling_time_2pct_s": settling_time,
            "peak_value": 1.0,
            "steady_state_value": 1.0,
            "pole_slow": s1,
            "pole_fast": s2,
            "time_constant_slow_s": tau_slow,
            "time_constant_fast_s": tau_fast,
            "pole_separation_ratio": pole_ratio,
            "can_approximate_first_order": pole_ratio > 5.0,
            "equivalent_first_order_tau": tau_slow if pole_ratio > 5.0 else None,
            "note": f"Respuesta dominada por polo lento s₁ = {s1:.4f} rad/s",
        }

    def _calculate_parameter_sensitivity(self) -> Dict[str, Any]:
        """
        Calcula sensibilidad paramétrica usando derivadas parciales analíticas.
        
        La sensibilidad normalizada del parámetro y respecto a x se define como:
        
            S_x^y = (∂y/∂x) · (x/y) = ∂(ln y)/∂(ln x)
            
        Esto mide el cambio porcentual en y dado un cambio porcentual en x.
        
        Para el sistema RLC, calculamos sensibilidades de ωₙ, ζ y polos.
        
        Derivaciones:
            ωₙ = 1/√(LC)
            ∂ωₙ/∂L = -ωₙ/(2L)  →  S_L^ωₙ = -1/2
            ∂ωₙ/∂C = -ωₙ/(2C)  →  S_C^ωₙ = -1/2
            ∂ωₙ/∂R = 0         →  S_R^ωₙ = 0
            
            ζ = (R/2)√(C/L)
            ∂ζ/∂R = ζ/R        →  S_R^ζ = 1
            ∂ζ/∂L = -ζ/(2L)    →  S_L^ζ = -1/2
            ∂ζ/∂C = ζ/(2C)     →  S_C^ζ = 1/2
            
        Para polos complejos p = -ζωₙ + jωₙ√(1-ζ²):
            Usamos la regla de la cadena para obtener sensibilidades compuestas.
        """
        nc = self._nc
        
        if self.zeta < nc.EPSILON_ZERO:
            return {
                "status": "UNSTABLE_OR_UNDAMPED",
                "sensitivity_matrix": {},
                "robustness_classification": "NOT_APPLICABLE",
                "warning": "Sensibilidad no definida para sistemas inestables/sin amortiguamiento",
            }

        # === Sensibilidades normalizadas de ωₙ (exactas por derivación) ===
        S_L_omega_n = -0.5  # ∂ln(ωₙ)/∂ln(L) = -1/2
        S_C_omega_n = -0.5  # ∂ln(ωₙ)/∂ln(C) = -1/2
        S_R_omega_n = 0.0   # ωₙ no depende de R

        # === Sensibilidades normalizadas de ζ ===
        S_R_zeta = 1.0   # ∂ln(ζ)/∂ln(R) = 1
        S_L_zeta = -0.5  # ∂ln(ζ)/∂ln(L) = -1/2
        S_C_zeta = 0.5   # ∂ln(ζ)/∂ln(C) = 1/2

        # === Sensibilidad de polos (más compleja) ===
        if 0 < self.zeta < 1.0:
            # Polos complejos: p = σ ± jω_d donde σ = -ζωₙ, ω_d = ωₙ√(1-ζ²)
            sigma = -self.zeta * self.omega_n
            omega_d = self.omega_d
            
            # Magnitud del polo: |p| = ωₙ (siempre para 2º orden canónico)
            pole_mag = self.omega_n
            
            # Sensibilidad de la magnitud del polo
            S_R_pole_mag = 0.0
            S_L_pole_mag = S_L_omega_n
            S_C_pole_mag = S_C_omega_n
            
            # Sensibilidad de la parte real (afecta estabilidad relativa)
            # σ = -ζωₙ → S_x^σ = S_x^ζ + S_x^ωₙ
            S_R_sigma = S_R_zeta + S_R_omega_n
            S_L_sigma = S_L_zeta + S_L_omega_n
            S_C_sigma = S_C_zeta + S_C_omega_n
            
        else:
            # Polos reales
            S_R_pole_mag = 0.5
            S_L_pole_mag = -0.5
            S_C_pole_mag = -0.5
            S_R_sigma = S_R_zeta
            S_L_sigma = S_L_zeta
            S_C_sigma = S_C_zeta

        # === Matriz de sensibilidad completa ===
        sensitivity_matrix = {
            "R": {
                "omega_n": S_R_omega_n,
                "zeta": S_R_zeta,
                "pole_magnitude": S_R_pole_mag if 0 < self.zeta < 1 else abs(S_R_zeta),
                "pole_real_part": S_R_sigma,
                "stability_impact": "HIGH" if abs(S_R_zeta) > 0.5 else "MODERATE",
            },
            "L": {
                "omega_n": S_L_omega_n,
                "zeta": S_L_zeta,
                "pole_magnitude": S_L_pole_mag if 0 < self.zeta < 1 else abs(S_L_zeta + S_L_omega_n),
                "pole_real_part": S_L_sigma,
                "stability_impact": "HIGH" if abs(S_L_zeta + S_L_omega_n) > 0.75 else "MODERATE",
            },
            "C": {
                "omega_n": S_C_omega_n,
                "zeta": S_C_zeta,
                "pole_magnitude": S_C_pole_mag if 0 < self.zeta < 1 else abs(S_C_zeta + S_C_omega_n),
                "pole_real_part": S_C_sigma,
                "stability_impact": "MODERATE",  # Efectos opuestos en ωₙ y ζ
            },
        }

        # === Métricas escalares de sensibilidad ===
        sens_R = abs(S_R_zeta)  # R solo afecta ζ
        sens_L = math.sqrt(S_L_omega_n**2 + S_L_zeta**2)  # Norma L2
        sens_C = math.sqrt(S_C_omega_n**2 + S_C_zeta**2)
        
        # === Número de condición (medida de robustez) ===
        # Definido como ratio entre máxima y mínima sensibilidad
        sensitivities = [sens_R, sens_L, sens_C]
        max_sens = max(sensitivities)
        min_sens = min(s for s in sensitivities if s > nc.EPSILON_ZERO) if any(s > nc.EPSILON_ZERO for s in sensitivities) else 1.0
        
        condition_number = max_sens / min_sens if min_sens > nc.EPSILON_ZERO else float('inf')
        
        # === Clasificación de robustez ===
        if max_sens > 2.0:
            robustness_class = "FRAGILE"
        elif max_sens > 1.0:
            robustness_class = "SENSITIVE"
        elif condition_number > 5.0:
            robustness_class = "UNBALANCED"
        elif max_sens < 0.5:
            robustness_class = "ROBUST"
        else:
            robustness_class = "MODERATE"

        # === Parámetro más sensible ===
        param_sens = {"R": sens_R, "L": sens_L, "C": sens_C}
        most_sensitive = max(param_sens, key=param_sens.get)

        # === Recomendaciones ===
        recommendations = self._generate_sensitivity_recommendations(sens_R, sens_L, sens_C, most_sensitive)

        return {
            "sensitivity_matrix": sensitivity_matrix,
            "normalized_sensitivities": {
                "omega_n": {"R": S_R_omega_n, "L": S_L_omega_n, "C": S_C_omega_n},
                "zeta": {"R": S_R_zeta, "L": S_L_zeta, "C": S_C_zeta},
            },
            "scalar_sensitivities": param_sens,
            "most_sensitive_parameter": most_sensitive,
            "condition_number": condition_number,
            "robustness_classification": robustness_class,
            "recommendations": recommendations,
            
            # Compatibilidad hacia atrás
            "sensitivity_to_R": sens_R,
            "sensitivity_to_L": sens_L,
            "sensitivity_to_C": sens_C,
            "most_sensitive": most_sensitive,
            "robustness_class": robustness_class,
        }

    def _generate_sensitivity_recommendations(
        self, sens_R: float, sens_L: float, sens_C: float, most_sensitive: str
    ) -> List[str]:
        """Genera recomendaciones técnicas basadas en análisis de sensibilidad."""
        recommendations = []
        
        thresholds = {"HIGH": 1.0, "MEDIUM": 0.5}
        
        if sens_R > thresholds["HIGH"]:
            recommendations.append(
                f"⚠️ Alta sensibilidad a R (S = {sens_R:.2f}). "
                "Use resistores de precisión (±0.1%) y considere compensación térmica."
            )
        
        if sens_L > thresholds["HIGH"]:
            recommendations.append(
                f"⚠️ Alta sensibilidad a L (S = {sens_L:.2f}). "
                "Prefiera inductores con núcleo de aire o ferrita de baja histéresis. "
                "Evite saturación magnética."
            )
        
        if sens_C > thresholds["HIGH"]:
            recommendations.append(
                f"⚠️ Alta sensibilidad a C (S = {sens_C:.2f}). "
                "Use capacitores NPO/C0G para mínima deriva. "
                "Evite electrolíticos en la ruta de señal."
            )
        
        if most_sensitive == "R" and self.zeta < 0.3:
            recommendations.append(
                "Sistema subamortiguado con R dominante en sensibilidad. "
                "Pequeños cambios en R pueden causar oscilaciones significativas."
            )
        
        if not recommendations:
            recommendations.append(
                "✓ Sistema bien condicionado. Sensibilidades paramétricas dentro de rangos aceptables."
            )
        
        return recommendations

    def get_frequency_response(
        self, 
        frequencies: Optional[np.ndarray] = None,
        n_points: int = 500,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        """
        Calcula respuesta en frecuencia con evaluación directa optimizada.
        
        Para H(s) = 1/(LCs² + RCs + 1), evaluamos H(jω) directamente:
        
            H(jω) = 1 / (1 - LCω² + jRCω)
            
        Magnitud:
            |H(jω)| = 1 / √[(1 - LCω²)² + (RCω)²]
            
        Fase:
            ∠H(jω) = -arctan(RCω / (1 - LCω²))
        """
        # Generación de clave de cache
        if frequencies is not None:
            cache_key = f"freq_{hash(frequencies.tobytes())}"
        else:
            cache_key = f"freq_default_{n_points}"
        
        if use_cache and cache_key in self._analysis_cache:
            cached = self._analysis_cache[cache_key]
            if time.time() - cached.get("timestamp", 0) < 3600:  # Cache de 1 hora
                return cached["data"]

        # Generación de frecuencias si no se proporcionan
        if frequencies is None:
            w_min = max(self.omega_n / 1000.0, 1e-4)
            w_max = min(self.omega_n * 1000.0, 1e8)
            frequencies = np.logspace(np.log10(w_min), np.log10(w_max), n_points)

        # Evaluación vectorizada directa
        w = frequencies
        LC = self.L * self.C
        RC = self.R * self.C
        
        # Denominador complejo: D(jω) = (1 - LCω²) + j(RCω)
        real_part = 1.0 - LC * w**2
        imag_part = RC * w
        
        # H(jω) = 1 / D(jω)
        denominator_mag_sq = real_part**2 + imag_part**2
        
        # Protección contra división por cero
        denominator_mag_sq = np.maximum(denominator_mag_sq, 1e-30)
        
        H_real = real_part / denominator_mag_sq
        H_imag = -imag_part / denominator_mag_sq
        
        magnitude = 1.0 / np.sqrt(denominator_mag_sq)
        magnitude_db = 20.0 * np.log10(np.maximum(magnitude, 1e-30))
        phase_rad = np.arctan2(H_imag, H_real)
        phase_deg = np.degrees(phase_rad)
        
        # Unwrap de fase para continuidad
        phase_deg = np.unwrap(np.radians(phase_deg)) * 180 / np.pi

        # Resonancia analítica
        resonance = self._find_resonance_analytical()

        # Ancho de banda con interpolación logarítmica
        bandwidth = self._calculate_bandwidth_log_interp(frequencies, magnitude_db)

        result = {
            "frequencies_rad_s": frequencies.tolist(),
            "frequencies_hz": (frequencies / (2 * np.pi)).tolist(),
            "magnitude": magnitude.tolist(),
            "magnitude_db": magnitude_db.tolist(),
            "phase_rad": phase_rad.tolist(),
            "phase_deg": phase_deg.tolist(),
            "nyquist_real": H_real.tolist(),
            "nyquist_imag": H_imag.tolist(),
            "resonance": resonance,
            "bandwidth_rad_s": bandwidth,
            "bandwidth_hz": bandwidth / (2 * np.pi),
            "dc_gain": 1.0,
            "dc_gain_db": 0.0,
            "high_freq_rolloff_db_per_decade": -40.0,  # Segundo orden
        }

        # Cache
        self._analysis_cache[cache_key] = {"data": result, "timestamp": time.time()}
        self._prune_cache()

        return result

    def _find_resonance_analytical(self) -> Dict[str, Any]:
        """
        Encuentra pico de resonancia usando fórmulas analíticas exactas.
        
        Frecuencia de resonancia (donde |H| es máximo):
            d|H|²/dω = 0  →  ω_r = ωₙ√(1 - 2ζ²)
            
        Existe solo si 1 - 2ζ² > 0  →  ζ < 1/√2 ≈ 0.707
        
        Magnitud en resonancia:
            |H(jω_r)| = 1 / (2ζ√(1-ζ²)) = Q / √(1 - 1/(4Q²))
        """
        nc = self._nc
        zeta_threshold = 1.0 / math.sqrt(2.0)
        
        if self.zeta >= zeta_threshold or self.zeta <= nc.EPSILON_ZERO:
            return {
                "exists": False,
                "frequency_rad_s": 0.0,
                "frequency_hz": 0.0,
                "magnitude": 1.0,
                "magnitude_db": 0.0,
                "reason": "ζ ≥ 1/√2 - Sin pico de resonancia"
            }

        # Frecuencia de resonancia
        omega_r = self.omega_n * math.sqrt(1.0 - 2.0 * self.zeta**2)
        
        # Magnitud en resonancia
        denominator = 2.0 * self.zeta * math.sqrt(1.0 - self.zeta**2)
        if denominator > nc.EPSILON_ZERO:
            resonance_mag = 1.0 / denominator
        else:
            resonance_mag = float('inf')
        
        resonance_db = 20.0 * math.log10(resonance_mag) if resonance_mag < float('inf') else float('inf')

        return {
            "exists": True,
            "frequency_rad_s": omega_r,
            "frequency_hz": omega_r / (2.0 * math.pi),
            "magnitude": resonance_mag,
            "magnitude_db": resonance_db,
            "quality_factor": self.Q,
            "amplification_factor": resonance_mag,  # Ganancia sobre DC
        }

    def _calculate_bandwidth_log_interp(
        self, frequencies: np.ndarray, magnitude_db: np.ndarray
    ) -> float:
        """
        Calcula ancho de banda -3dB usando interpolación en escala logarítmica.
        
        El ancho de banda se define como la frecuencia donde |H| cae 3dB desde DC.
        Para sistemas de paso bajo, esto es el primer cruce descendente.
        """
        if len(magnitude_db) < 2:
            return 0.0

        dc_gain_db = magnitude_db[0]
        target_db = dc_gain_db - 3.0

        # Buscar cruce descendente
        for i in range(len(magnitude_db) - 1):
            if magnitude_db[i] >= target_db > magnitude_db[i + 1]:
                # Interpolación logarítmica (más precisa para respuestas en frecuencia)
                log_f1 = np.log10(frequencies[i])
                log_f2 = np.log10(frequencies[i + 1])
                
                # Interpolación lineal en log-frecuencia vs dB
                t = (target_db - magnitude_db[i]) / (magnitude_db[i + 1] - magnitude_db[i])
                log_bw = log_f1 + t * (log_f2 - log_f1)
                
                return 10.0 ** log_bw

        # No se encontró cruce
        if magnitude_db[-1] > target_db:
            return frequencies[-1]  # Ganancia nunca cae 3dB
        return 0.0

    def _prune_cache(self) -> None:
        """Limpia cache si excede tamaño máximo."""
        if len(self._analysis_cache) > self._cache_max_size:
            # Eliminar entradas más antiguas
            sorted_keys = sorted(
                self._analysis_cache.keys(),
                key=lambda k: self._analysis_cache[k].get("timestamp", 0)
            )
            for key in sorted_keys[:len(sorted_keys) // 2]:
                del self._analysis_cache[key]

    def analyze_stability(self) -> Dict[str, Any]:
        """
        Análisis completo de estabilidad del sistema.
        
        Combina:
        - Análisis de polos (continuo y discreto)
        - Márgenes de estabilidad
        - Métricas de respuesta transitoria
        - Sensibilidad paramétrica
        - Recomendaciones de control
        """
        cache_key = "stability_analysis"
        if cache_key in self._analysis_cache:
            cached = self._analysis_cache[cache_key]
            if time.time() - cached.get("timestamp", 0) < 60:
                return cached["data"]

        # Polos continuos y discretos
        poles_c = self.continuous_system.poles
        zeros_c = self.continuous_system.zeros
        poles_d = self.discrete_system.poles
        zeros_d = self.discrete_system.zeros

        # Clasificación de estabilidad
        nc = self._nc
        unstable_c = [p for p in poles_c if p.real > nc.EPSILON_STABILITY]
        unstable_d = [p for p in poles_d if abs(p) > 1.0 + nc.EPSILON_STABILITY]
        
        is_stable = len(unstable_c) == 0 and len(unstable_d) == 0
        
        if unstable_c:
            status = "UNSTABLE_CONTINUOUS"
        elif unstable_d:
            status = "UNSTABLE_DISCRETE"
        elif any(abs(p.real) < nc.EPSILON_STABILITY for p in poles_c):
            status = "MARGINALLY_STABLE"
        else:
            status = "STABLE"

        # Calcular métricas
        margins = self._calculate_stability_margins()
        transient = self._calculate_transient_metrics()
        sensitivity = self._calculate_parameter_sensitivity()
        recommendations = self._generate_control_recommendations(margins, sensitivity)

        result = {
            "status": status,
            "is_stable": is_stable,
            "is_marginally_stable": status == "MARGINALLY_STABLE",
            
            "continuous": {
                "poles": [(complex(p).real, complex(p).imag) for p in poles_c],
                "zeros": [(complex(z).real, complex(z).imag) for z in zeros_c],
                "natural_frequency_rad_s": self.omega_n,
                "damping_ratio": self.zeta,
                "quality_factor": self.Q,
                "damping_class": self.damping_class.name,
                "response_type": self.response_type,
            },
            
            "discrete": {
                "poles": [(complex(p).real, complex(p).imag) for p in poles_d],
                "zeros": [(complex(z).real, complex(z).imag) for z in zeros_d],
                "sample_rate_hz": self.sample_rate,
                "sample_period_s": self.T,
                "is_stable": len(unstable_d) == 0,
                "max_pole_magnitude": max(abs(p) for p in poles_d) if len(poles_d) > 0 else 0,
            },
            
            "stability_margins": margins,
            "transient_response": transient,
            "parameter_sensitivity": sensitivity,
            "control_recommendations": recommendations,
        }

        self._analysis_cache[cache_key] = {"data": result, "timestamp": time.time()}
        return result

    def _generate_control_recommendations(
        self, margins: Dict[str, Any], sensitivity: Dict[str, Any]
    ) -> List[str]:
        """Genera recomendaciones para diseño de control."""
        recommendations = []
        
        # Basadas en amortiguamiento
        if self.zeta < 0.2:
            recommendations.append(
                f"⚠️ Amortiguamiento muy bajo (ζ = {self.zeta:.3f}). "
                "Implemente control derivativo (PD) o realimentación de velocidad."
            )
        elif self.zeta > 2.0:
            recommendations.append(
                f"Sistema sobreamortiguado (ζ = {self.zeta:.3f}). "
                "Considere reducir R o implementar control proporcional para acelerar respuesta."
            )

        # Basadas en frecuencia natural
        nyquist = self.sample_rate / 2
        if self.omega_n > nyquist * 0.5:
            recommendations.append(
                f"⚠️ ωₙ = {self.omega_n:.1f} rad/s cerca de Nyquist. "
                f"Aumente sample_rate a ≥ {20 * self.omega_n:.0f} Hz para control digital."
            )

        # Basadas en margen de fase
        pm = margins.get("phase_margin_deg", 0)
        if pm < 30:
            recommendations.append(
                f"⚠️ Margen de fase bajo ({pm:.1f}°). "
                "Sistema susceptible a retardos. Reduzca ganancia o agregue compensación de adelanto."
            )

        # Basadas en sensibilidad
        if sensitivity.get("robustness_classification", "").startswith("FRAGILE"):
            recommendations.append(
                "Sistema frágil ante variaciones paramétricas. "
                "Considere control robusto (H∞) o adaptativo."
            )

        if not recommendations:
            recommendations.append(
                "✓ Sistema bien condicionado para control convencional (PID)."
            )

        return recommendations

    def get_laplace_pyramid(self) -> Dict[str, Any]:
        """
        Genera la Pirámide de Laplace - resumen jerárquico del análisis.
        
        Estructura de 4 niveles:
        
        Nivel 0 (Vértice) - VEREDICTO: ¿Es controlable?
        Nivel 1 (Superior) - ROBUSTEZ: Márgenes y sensibilidad
        Nivel 2 (Medio) - DINÁMICA: Polos, ωₙ, ζ
        Nivel 3 (Base) - FÍSICA: Parámetros R, L, C
        """
        stability = self.analyze_stability()
        margins = stability["stability_margins"]
        sensitivity = stability["parameter_sensitivity"]
        
        # Determinar veredicto
        is_controllable = (
            stability["is_stable"] and
            margins.get("phase_margin_deg", 0) > 30 and
            sensitivity.get("robustness_classification", "") not in ["FRAGILE", "UNSTABLE"]
        )

        return {
            "level_0_verdict": {
                "is_controllable": is_controllable,
                "stability_status": stability["status"],
                "confidence": "HIGH" if margins.get("phase_margin_deg", 0) > 45 else "MODERATE",
                "summary": (
                    "✓ APTO para control" if is_controllable 
                    else "⚠️ REQUIERE atención antes de control"
                ),
            },
            
            "level_1_robustness": {
                "phase_margin_deg": margins["phase_margin_deg"],
                "gain_margin_db": margins["gain_margin_db"],
                "robustness_class": sensitivity.get("robustness_classification", "UNKNOWN"),
                "most_sensitive_param": sensitivity.get("most_sensitive_parameter", "N/A"),
                "condition_number": sensitivity.get("condition_number", 1.0),
            },
            
            "level_2_dynamics": {
                "omega_n_rad_s": self.omega_n,
                "omega_n_hz": self.omega_n / (2 * math.pi),
                "zeta": self.zeta,
                "Q": self.Q,
                "poles": stability["continuous"]["poles"],
                "damping_class": self.damping_class.name,
                "response_type": self.response_type,
            },
            
            "level_3_physics": {
                "R_ohm": self.R,
                "L_henry": self.L,
                "C_farad": self.C,
                "sample_rate_hz": self.sample_rate,
                "impedance_at_resonance": self.R,  # En resonancia, Z = R
                "characteristic_impedance": math.sqrt(self.L / self.C) if self.C > 0 else 0,
            },
            
            "metadata": {
                "analysis_version": "3.0",
                "timestamp": time.time(),
            }
        }