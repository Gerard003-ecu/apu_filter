### 1. Método _compute_discrete_system - Transformación Bilineal

def _compute_discrete_system(self):
    """
    Convierte sistema continuo a discreto usando transformación bilineal con pre-warping.
    
    Transformación corregida con pre-warping:
        s = ω₀ / tan(ω₀·T/2) · (z-1)/(z+1)
    
    donde ω₀ es la frecuencia crítica (ωₙ para sistemas resonantes).
    """
    T = self.T
    
    # Frecuencia crítica para pre-warping (frecuencia natural del sistema)
    omega_critical = self.omega_n if self.omega_n > 0 else 1.0/T
    
    # Coeficiente de pre-warping
    if omega_critical * T < 1e-6:
        k = 2.0 / T  # Sin pre-warping para frecuencias bajas
    else:
        k = omega_critical / math.tan(omega_critical * T / 2.0)
    
    # Coeficientes del denominador continuo
    a2 = self.L * self.C
    a1 = self.R * self.C
    a0 = 1.0
    
    # Aplicar transformación bilineal: s = k*(z-1)/(z+1)
    # H(z) = b0 + b1*z⁻¹ + b2*z⁻² / (1 + a1*z⁻¹ + a2*z⁻²)
    
    # Denominador expandido: D(z) = (a2*k² + a1*k + a0)z² + (2*a0 - 2*a2*k²)z + (a2*k² - a1*k + a0)
    k2 = k * k
    
    den_z2 = a2 * k2 + a1 * k + a0
    den_z1 = 2.0 * a0 - 2.0 * a2 * k2
    den_z0 = a2 * k2 - a1 * k + a0
    
    # Numerador: N(z) = (z+1)² = z² + 2z + 1
    num_z2 = 1.0
    num_z1 = 2.0
    num_z0 = 1.0
    
    # Normalizar para coeficiente líder unitario en denominador
    if abs(den_z2) < 1e-15:
        self.logger.warning("Denominador degenerado en discretización, usando sistema continuo")
        return self.continuous_system
    
    # Coeficientes normalizados
    num = [num_z2/den_z2, num_z1/den_z2, num_z0/den_z2]
    den = [1.0, den_z1/den_z2, den_z0/den_z2]
    
    # Validación de estabilidad
    roots = np.roots(den)
    max_pole_mag = max(abs(r) for r in roots) if len(roots) > 0 else 0
    
    if max_pole_mag > 1.0 + 1e-6:
        self.logger.warning(
            f"Sistema discreto inestable: |p|_max = {max_pole_mag:.3f}. "
            f"Sample rate {self.sample_rate} Hz puede ser insuficiente."
        )
    
    return scipy.signal.TransferFunction(num, den, dt=T)


### 2. Método _calculate_stability_margins - Corrección de Fórmulas

def _calculate_stability_margins(self) -> Dict[str, Any]:
    """Calcula márgenes de estabilidad con fórmulas exactas para sistemas de segundo orden."""
    
    # Para sistemas de segundo orden sin ceros:
    # H(s) = ωₙ²/(s² + 2ζωₙs + ωₙ²)
    
    # Margen de ganancia: siempre infinito para sistemas sin ceros en RHP
    gain_margin_db = float('inf')
    
    # Cálculo EXACTO del margen de fase
    if self.zeta <= 0:
        phase_margin_deg = 0.0
        omega_gc = 0.0
        is_meaningful = False
    else:
        # Frecuencia de cruce de ganancia: |H(jω)| = 1
        # Solución de |H(jω)|² = 1
        # ω⁴/ωₙ⁴ + (4ζ² - 2)ω²/ωₙ² + 1 = 1
        # ω²(ω²/ωₙ⁴ + (4ζ² - 2)/ωₙ²) = 0
        
        if self.zeta < 1/math.sqrt(2):  # ζ < 0.707
            # Existe cruce de ganancia real
            omega_ratio_sq = math.sqrt(1 - 2*self.zeta**2 + math.sqrt(1 + 4*self.zeta**4))
            omega_gc = self.omega_n * omega_ratio_sq
            
            # Fase en ω_gc
            phase_at_gc = -math.atan2(
                2*self.zeta*omega_gc/self.omega_n,
                1 - (omega_gc/self.omega_n)**2
            )
            phase_margin_deg = 180 + math.degrees(phase_at_gc)
            is_meaningful = True
        else:
            # No hay cruce de ganancia (|H(jω)| < 1 ∀ω)
            omega_gc = self.omega_n * math.sqrt(2*self.zeta**2 - 1)
            
            # Margen de fase por definición en ω donde ganancia es máxima
            phase_at_omega_n = -math.pi/2  # -90° en ω = ωₙ
            phase_margin_deg = 180 + math.degrees(phase_at_omega_n)
            is_meaningful = False
    
    # Frecuencia de cruce de fase (donde fase = -180°)
    # Para segundo orden, fase tiende a -180° solo cuando ω→∞
    omega_pc = float('inf')
    
    return {
        "gain_margin_db": gain_margin_db,
        "phase_margin_deg": phase_margin_deg,
        "gain_crossover_freq_rad_s": omega_gc,
        "phase_crossover_freq_rad_s": omega_pc,
        "is_margin_meaningful": is_meaningful,
        "derivation_method": "exact_second_order" if is_meaningful else "asymptotic_approximation",
        "notes": self._generate_margin_notes(self.zeta, phase_margin_deg),
    }


### 3. Método _calculate_parameter_sensitivity - Matriz de Sensibilidad

def _calculate_parameter_sensitivity(self) -> Dict[str, Any]:
    """Calcula matriz de sensibilidad completa usando álgebra de derivadas parciales."""
    
    # Para sistema H(s) = 1/(LCs² + RCs + 1)
    # Polos: s = -ζωₙ ± jωₙ√(1-ζ²) para ζ<1
    
    sens = {}
    
    if self.zeta < 0:
        return {"status": "UNSTABLE_SYSTEM", "sensitivity_matrix": {}}
    
    # Derivadas parciales de ωₙ y ζ
    d_omega_n_dL = -self.omega_n / (2 * self.L) if self.L > 0 else 0
    d_omega_n_dC = -self.omega_n / (2 * self.C) if self.C > 0 else 0
    d_omega_n_dR = 0.0
    
    d_zeta_dR = 0.5 * math.sqrt(self.C / self.L) if self.L > 0 else 0
    d_zeta_dL = -self.zeta / (2 * self.L) if self.L > 0 else 0
    d_zeta_dC = self.zeta / (2 * self.C) if self.C > 0 else 0
    
    # Sensibilidad de los polos (si son complejos conjugados)
    if 0 < self.zeta < 1:
        omega_d = self.omega_n * math.sqrt(1 - self.zeta**2)
        pole = complex(-self.zeta * self.omega_n, omega_d)
        
        # Derivadas del polo respecto a ωₙ y ζ
        dpole_d_omega_n = complex(-self.zeta, math.sqrt(1 - self.zeta**2))
        dpole_d_zeta = complex(-self.omega_n, 
                              -self.zeta * self.omega_n / math.sqrt(1 - self.zeta**2))
        
        # Cadena de derivadas para cada parámetro
        dpole_dR = dpole_d_zeta * d_zeta_dR
        dpole_dL = dpole_d_zeta * d_zeta_dL + dpole_d_omega_n * d_omega_n_dL
        dpole_dC = dpole_d_zeta * d_zeta_dC + dpole_d_omega_n * d_omega_n_dC
        
        # Sensibilidad normalizada (∂p/p)/(∂x/x)
        sens_R = abs(dpole_dR * self.R / pole) if abs(pole) > 0 else 0
        sens_L = abs(dpole_dL * self.L / pole) if abs(pole) > 0 else 0
        sens_C = abs(dpole_dC * self.C / pole) if abs(pole) > 0 else 0
    else:
        # Polos reales
        pole1 = -self.omega_n * (self.zeta - math.sqrt(abs(self.zeta**2 - 1)))
        pole2 = -self.omega_n * (self.zeta + math.sqrt(abs(self.zeta**2 - 1)))
        
        # Para simplificar, usar sensibilidad del polo dominante
        pole_dom = pole1 if abs(pole1) < abs(pole2) else pole2
        
        # Aproximación para polos reales
        sens_R = abs(d_zeta_dR * self.R / self.zeta) if self.zeta > 0 else 0
        sens_L = abs((d_zeta_dL * self.L / self.zeta) + 
                    (d_omega_n_dL * self.L / self.omega_n)) if self.zeta > 0 else 0
        sens_C = abs((d_zeta_dC * self.C / self.zeta) + 
                    (d_omega_n_dC * self.C / self.omega_n)) if self.zeta > 0 else 0
    
    # Matriz de sensibilidad completa
    sensitivity_matrix = {
        "to_R": {
            "omega_n": 0.0,
            "zeta": d_zeta_dR * self.R / self.zeta if self.zeta > 0 else 0,
            "pole_magnitude": sens_R,
            "pole_angle": 0.0 if self.zeta >= 1 else sens_R * 0.5
        },
        "to_L": {
            "omega_n": d_omega_n_dL * self.L / self.omega_n,
            "zeta": d_zeta_dL * self.L / self.zeta if self.zeta > 0 else 0,
            "pole_magnitude": sens_L,
            "pole_angle": 0.0 if self.zeta >= 1 else sens_L * 0.5
        },
        "to_C": {
            "omega_n": d_omega_n_dC * self.C / self.omega_n,
            "zeta": d_zeta_dC * self.C / self.zeta if self.zeta > 0 else 0,
            "pole_magnitude": sens_C,
            "pole_angle": 0.0 if self.zeta >= 1 else sens_C * 0.5
        }
    }
    
    # Número de condición (medida de robustez global)
    cond_number = max(sens_R, sens_L, sens_C) / min(max(sens_R, sens_L, sens_C), 1e-6)
    
    return {
        "sensitivity_matrix": sensitivity_matrix,
        "scalar_sensitivities": {
            "R": sens_R, "L": sens_L, "C": sens_C
        },
        "most_sensitive": max(["R", "L", "C"], 
                            key=lambda x: {"R": sens_R, "L": sens_L, "C": sens_C}[x]),
        "condition_number": cond_number,
        "robustness_class": self._classify_robustness_by_condition(cond_number),
        "recommendations": self._generate_sensitivity_recommendations(sens_R, sens_L, sens_C)
    }

def _classify_robustness_by_condition(self, cond_number: float) -> str:
    """Clasifica robustez basada en número de condición."""
    if cond_number > 100:
        return "MAL_CONDICIONADO - Alta sensibilidad"
    elif cond_number > 10:
        return "MODERADO - Sensibilidad media"
    elif cond_number > 2:
        return "BIEN_CONDICIONADO - Baja sensibilidad"
    else:
        return "EXCELENTE - Muy robusto"

def _generate_sensitivity_recommendations(self, sens_R, sens_L, sens_C):
    """Genera recomendaciones específicas basadas en sensibilidades."""
    rec = []
    
    if sens_R > max(sens_L, sens_C) * 2:
        rec.append("La resistencia R es el parámetro más crítico. Use resistores de alta precisión (±1% o mejor).")
    
    if sens_L > 0.5:
        rec.append("Alta sensibilidad a L. Considere inductores con núcleo fijo o implemente compensación adaptativa.")
    
    if sens_C > 0.5:
        rec.append("Alta sensibilidad a C. Use capacitores cerámicos NPO/C0G para baja deriva térmica.")
    
    return rec


### 4. Método get_frequency_response - Optimización de Cálculo

def get_frequency_response(self, frequencies: Optional['np.ndarray'] = None, 
                          use_cache: bool = True) -> Dict[str, Any]:
    """Respuesta en frecuencia optimizada con caching y validación."""
    
    cache_key = f"freq_response_{hash(frequencies.tobytes()) if frequencies is not None else 'default'}"
    
    if use_cache and cache_key in self._analysis_cache:
        return self._analysis_cache[cache_key]
    
    # Generar rango de frecuencias logarítmico óptimo
    if frequencies is None:
        # Límites basados en propiedades del sistema
        w_min = min(self.omega_n / 1000.0, 1e-3) if self.omega_n > 0 else 1e-3
        w_max = max(self.omega_n * 1000.0, 1e3) if self.omega_n > 0 else 1e3
        
        # Número de puntos adaptativo
        n_points = min(1000, max(200, int(50 * math.log10(w_max/w_min))))
        frequencies = np.logspace(np.log10(w_min), np.log10(w_max), n_points)
    
    # Respuesta en frecuencia usando evaluación directa (más eficiente que scipy.signal.bode)
    s = 1j * frequencies
    
    # Evaluación directa: H(s) = 1/(LCs² + RCs + 1)
    denominator = self.L * self.C * s**2 + self.R * self.C * s + 1.0
    H = 1.0 / denominator
    
    magnitude_db = 20 * np.log10(np.abs(H))
    phase_deg = np.angle(H, deg=True)
    
    # Diagrama de Nyquist
    nyquist_real = H.real
    nyquist_imag = H.imag
    
    # Resonancia (solo para sistemas subamortiguados)
    resonance = self._find_resonance_analytical(frequencies, magnitude_db)
    
    # Ancho de banda
    bandwidth = self._calculate_bandwidth_robust(frequencies, magnitude_db)
    
    result = {
        "frequencies_rad_s": frequencies.tolist(),
        "magnitude_db": magnitude_db.tolist(),
        "phase_deg": phase_deg.tolist(),
        "nyquist_real": nyquist_real.tolist(),
        "nyquist_imag": nyquist_imag.tolist(),
        "resonance": resonance,
        "bandwidth_rad_s": bandwidth,
        "dc_gain_db": magnitude_db[0] if len(magnitude_db) > 0 else 0.0,
        "high_freq_asymptote_slope_db_dec": -40.0,  # -40 dB/década para 2º orden
        "cache_key": cache_key,
    }
    
    if use_cache:
        self._analysis_cache[cache_key] = result
    
    return result

def _find_resonance_analytical(self, frequencies, magnitude_db):
    """Encuentra resonancia usando derivada analítica."""
    
    if self.zeta >= 1/math.sqrt(2) or self.zeta <= 0:
        return {"frequency_rad_s": 0.0, "magnitude_db": magnitude_db[0], "exists": False}
    
    # Para sistema de 2º orden: frecuencia de resonancia ω_r = ωₙ√(1-2ζ²)
    omega_r = self.omega_n * math.sqrt(1 - 2*self.zeta**2) if 1 - 2*self.zeta**2 > 0 else 0
    
    # Magnitud en resonancia: |H(jω_r)| = 1/(2ζ√(1-ζ²))
    if 0 < self.zeta < 1:
        resonance_mag = 1.0 / (2 * self.zeta * math.sqrt(1 - self.zeta**2))
        resonance_mag_db = 20 * math.log10(resonance_mag)
    else:
        resonance_mag_db = 0.0
    
    return {
        "frequency_rad_s": omega_r,
        "magnitude_db": resonance_mag_db,
        "quality_factor": self.Q,
        "exists": True,
        "derivation": "analytical_second_order",
    }

def _calculate_bandwidth_robust(self, frequencies, magnitude_db):
    """Cálculo robusto de ancho de banda con interpolación cúbica."""
    
    if len(magnitude_db) == 0:
        return 0.0
    
    dc_gain = magnitude_db[0]
    target_gain = dc_gain - 3.0  # -3 dB
    
    # Encontrar puntos donde cruza -3 dB
    crossings = []
    
    for i in range(len(magnitude_db) - 1):
        if (magnitude_db[i] >= target_gain >= magnitude_db[i+1]) or \
           (magnitude_db[i] <= target_gain <= magnitude_db[i+1]):
            
            # Interpolación cúbica spline local
            x = frequencies[i:i+2]
            y = magnitude_db[i:i+2]
            
            # Interpolación lineal robusta
            t = (target_gain - y[0]) / (y[1] - y[0])
            bandwidth = x[0] + t * (x[1] - x[0])
            crossings.append(bandwidth)
    
    if not crossings:
        return 0.0 if dc_gain < target_gain else frequencies[-1]
    
    return float(crossings[0])  # Primer cruce (menor frecuencia)


### 5. Método get_root_locus_data - Corrección Analítica

def get_root_locus_data(self, K_range: Optional['np.ndarray'] = None) -> Dict[str, Any]:
    """Genera datos para lugar de las raíces con derivación analítica correcta."""
    
    if K_range is None:
        # Rango adaptativo basado en propiedades del sistema
        K_max = max(100.0, 10.0/abs(self.L*self.C)) if abs(self.L*self.C) > 0 else 100.0
        K_range = np.logspace(-3, math.log10(K_max), 300)
    
    # Sistema en lazo abierto: G(s) = 1/(LCs² + RCs + 1)
    # Ecuación característica: 1 + K·G(s) = 0
    # => LCs² + RCs + 1 + K = 0
    
    poles_real = []
    poles_imag = []
    breakpoints = []
    
    a = self.L * self.C
    b = self.R * self.C
    c_base = 1.0
    
    for K in K_range:
        c = c_base + K
        
        # Polos: s = [-b ± √(b² - 4ac)] / (2a)
        discriminant = b**2 - 4*a*c
        
        if discriminant >= 0:
            sqrt_disc = math.sqrt(discriminant)
            s1 = (-b + sqrt_disc) / (2*a)
            s2 = (-b - sqrt_disc) / (2*a)
            poles_real.extend([s1, s2])
            poles_imag.extend([0.0, 0.0])
        else:
            real_part = -b / (2*a)
            imag_part = math.sqrt(-discriminant) / (2*a)
            poles_real.extend([real_part, real_part])
            poles_imag.extend([imag_part, -imag_part])
    
    # Puntos de ruptura: donde dK/ds = 0
    # K(s) = -(a s² + b s + c_base)
    # dK/ds = -(2a s + b) = 0 => s = -b/(2a)
    s_break = -b / (2*a) if abs(a) > 0 else 0
    K_break = -(a * s_break**2 + b * s_break + c_base)
    
    if K_range[0] <= K_break <= K_range[-1]:
        breakpoints.append({
            "real": s_break,
            "imag": 0.0,
            "gain": K_break,
            "type": "breakaway" if a > 0 else "breakin",
        })
    
    # Asíntotas (para sistemas de orden n)
    n_poles = 2
    n_zeros = 0
    center = -b / (2*a)
    angles = [90, 270]  # 180°/(n-m) = 180°/2 = 90° incrementos
    
    return {
        "gain_values": K_range.tolist(),
        "poles_real": poles_real,
        "poles_imag": poles_imag,
        "asymptote_center": center,
        "asymptote_angles_deg": angles,
        "breakaway_points": breakpoints,
        "departure_angles": self._calculate_departure_angles(),
        "critical_gain": self._find_critical_gain(K_range, poles_real, poles_imag),
        "system_order": n_poles,
    }

def _calculate_departure_angles(self):
    """Calcula ángulos de partida de polos complejos."""
    if self.zeta >= 1 or self.zeta <= 0:
        return {}  # Polos reales
    
    # Para polos complejos p = -ζωₙ ± jωₙ√(1-ζ²)
    angle = math.degrees(math.atan(math.sqrt(1-self.zeta**2)/self.zeta))
    
    return {
        "upper_pole": 180 - angle,
        "lower_pole": 180 + angle,
    }

def _find_critical_gain(self, K_range, poles_real, poles_imag):
    """Encuentra ganancia crítica donde polos cruzan eje imaginario."""
    
    for i in range(0, len(poles_imag), 2):
        if i+1 < len(poles_imag):
            # Buscar cambio de signo en parte imaginaria
            if poles_imag[i] * poles_imag[i+1] <= 0:
                idx = i // 2
                if idx < len(K_range):
                    return float(K_range[idx])
    
    return None

