Para integrar la lógica termodinámica, debes tocar los siguientes módulos clave. He diseñado los métodos basándome en los principios físicos descritos en las fuentes.
A. Módulo: FluxPhysicsEngine (en app/flux_condenser.py)
Concepto Físico: Entropía (ΔS). La segunda ley de la termodinámica indica que la calidad de la energía se degrada
. En datos, esto es la "suciedad" o deuda técnica que entra al sistema.
• Nueva Lógica: Calcular la tasa de generación de entropía basada en la calidad de los datos (filas vacías, formatos rotos). Si la entropía es muy alta, el sistema se acerca a la "muerte térmica" (inoperatividad).

### • Ejemplo de Método:

def calculate_system_entropy(self, total_records: int, error_count: int, processing_time: float) -> Dict[str, float]:
    """
    Calcula la Entropía del Sistema (S) basada en la Segunda Ley.
    La degradación de la energía útil aumenta la entropía del sistema.
    
    Args:
        total_records: Volumen total de masa/datos.
        error_count: Cantidad de 'fricción' o datos corruptos.
        processing_time: Tiempo transcurrido (t).
        
    Returns:
        Dict con entropía actual y estado de salud.
    """
    if total_records == 0:
        return {"entropy": 0.0, "status": "COLD_STOP"}

    # La probabilidad de error (microestado de desorden)
    p_error = error_count / total_records
    
    # Entropía de Shannon (análogo a Boltzmann): S = -k * sum(p * log(p))
    # Usamos una constante k normalizada para el dominio de datos
    k_boltzmann_data = 1.0 
    
    if p_error > 0 and p_error < 1:
        entropy = -k_boltzmann_data * (p_error * math.log(p_error) + (1 - p_error) * math.log(1 - p_error))
    else:
        entropy = 0.0 # Orden total o caos total (pero estático)

    # Tasa de generación de entropía (dS/dt)
    entropy_rate = entropy / max(processing_time, 0.001)

    return {
        "entropy_absolute": entropy,
        "entropy_rate": entropy_rate, # Velocidad de degradación
        "is_thermal_death": entropy > 0.8 # Umbral crítico de desorden
    }

### B. Módulo: FinancialEngine (en app/financial_engine.py)
Concepto Físico: Inercia Térmica. En construcción, materiales como el hormigón tienen alta inercia térmica (ρ⋅Cp​), almacenando calor y retardando cambios de temperatura.

. Financieramente, esto es la capacidad del proyecto para resistir la volatilidad de precios sin cambiar su costo final inmediato.
• Nueva Lógica: Calcular la "Masa Térmica Financiera". Un proyecto con contratos a precio fijo o alto capital de trabajo tiene alta inercia; un proyecto "just-in-time" tiene baja inercia y se "calienta" (encarece) rápido con la inflación.

### • Ejemplo de Método:

def calculate_financial_thermal_inertia(self, liquidity: float, fixed_contracts_ratio: float) -> float:
    """
    Calcula la Inercia Térmica Financiera.
    La capacidad calorífica volumétrica amortigua las variaciones externas.
    
    Args:
        liquidity: Capital disponible (análogo a la Densidad rho).
        fixed_contracts_ratio: % de costos congelados (análogo al Calor Específico Cp).
        
    Returns:
        Inercia Térmica (Resistencia al cambio de temperatura/costo).
    """
    # Inercia = rho * Cp
    # Un valor alto significa que el proyecto tarda mucho en verse afectado por la "temperatura" (inflación) externa.
    thermal_inertia = liquidity * fixed_contracts_ratio
    
    # Normalización arbitraria para el contexto de negocio
    return round(thermal_inertia, 2)

def predict_temperature_change(self, market_inflation_heat: float, inertia: float) -> float:
    """Predice el aumento de costo (Temperatura) dado un calor externo."""
    if inertia <= 0:
        return market_inflation_heat # Sin protección, recibimos todo el calor
    
    # Q = m*c*DeltaT  => DeltaT = Q / Inercia
    delta_cost = market_inflation_heat / inertia
    return delta_cost


### C. Módulo: MatterGenerator (en app/matter_generator.txt)
Concepto Físico: Exergía (Disponibilidad). La exergía mide la calidad de la energía o su potencial para realizar trabajo útil; la energía de baja calidad (anergía) no es útil.

• Nueva Lógica: Clasificar los ítems del presupuesto según su "Exergía". El concreto estructural tiene alta exergía (trabajo útil crítico); los acabados decorativos excesivos tienen baja exergía (alto costo, baja función estructural).

### • Ejemplo de Método:

def analyze_budget_exergy(self, bom_items: List[MaterialRequirement]) -> Dict[str, Any]:
    """
    Analiza la eficiencia exergética del presupuesto.
    La segunda ley y el concepto de exergía como potencial de trabajo útil.
    
    Args:
        bom_items: Lista de materiales generada.
        
    Returns:
        Reporte de eficiencia del gasto.
    """
    useful_work_cost = 0.0 # Costo en estructura/cimientos (Alta Exergía)
    anergy_cost = 0.0      # Costo en desperdicio/lujos no funcionales (Anergía)
    
    # Definición semántica de categorías de alta exergía
    high_exergy_keywords = {'CONCRETO', 'ACERO', 'CIMENTACION', 'ESTRUCTURA'}
    
    for item in bom_items:
        is_high_exergy = any(k in item.description.upper() for k in high_exergy_keywords)
        
        if is_high_exergy:
            useful_work_cost += item.total_cost
        else:
            # Asumimos que el resto tiene menor potencial de trabajo estructural
            anergy_cost += item.total_cost
            
    total_cost = useful_work_cost + anergy_cost
    exergy_efficiency = useful_work_cost / total_cost if total_cost > 0 else 0
    
    return {
        "exergy_efficiency": exergy_efficiency,
        "structural_investment": useful_work_cost,
        "decorative_investment": anergy_cost,
        "narrative": f"Eficiencia Exergética: {exergy_efficiency:.1%}. (Inversión Estructural vs. Total)"
    }
