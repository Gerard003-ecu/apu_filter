### 1. Gram√°tica Mejorada

APU_GRAMMAR = r"""
    ?start: line

    // Una l√≠nea DEBE tener al menos un campo con contenido significativo.
    // Se define expl√≠citamente la estructura para evitar ambig√ºedades.
    line: field (SEP field)*

    // Un campo puede estar vac√≠o (para manejar ';;') o contener un valor.
    // MEJORA: Hacemos expl√≠cito que un campo vac√≠o es v√°lido estructuralmente.
    field: FIELD_VALUE -> field_with_value
         |              -> field_empty

    // MEJORA: Patr√≥n m√°s restrictivo que excluye caracteres de control
    // y limita la longitud m√°xima para evitar backtracking excesivo.
    FIELD_VALUE: /[^;\r\n\x00-\x1f]{1,2000}/

    // MEJORA: Separador m√°s estricto, solo punto y coma con espacios opcionales.
    SEP: /[ \t]*;[ \t]*/

    // Terminales ignorados expl√≠citamente.
    %import common.WS_INLINE
    %ignore WS_INLINE
"""

### 2. APUTransformer - M√©todos Robustecidos

@v_args(inline=False)
class APUTransformer(Transformer):
    """
    Orquestador que coordina a los especialistas para transformar una l√≠nea.
    ROBUSTECIDO: Manejo defensivo de tokens, validaci√≥n estricta y logging mejorado.
    """

    # Constantes para tipos de token esperados
    _SEP_TOKEN_TYPE = "SEP"
    _FIELD_VALUE_TOKEN_TYPE = "FIELD_VALUE"
    _MIN_FIELDS_FOR_VALID_LINE = 3
    _MAX_DESCRIPTION_LENGTH = 500

    def __init__(
        self,
        apu_context: Dict[str, Any],
        config: Dict[str, Any],
        profile: Dict[str, Any],
        keyword_cache: Any,
    ):
        """Inicializa el Transformer con validaci√≥n de par√°metros."""
        # ROBUSTECIDO: Validaci√≥n defensiva de par√°metros de entrada
        if apu_context is None:
            logger.warning("apu_context es None, usando diccionario vac√≠o")
        if config is None:
            logger.warning("config es None, usando diccionario vac√≠o")

        self.apu_context = apu_context if isinstance(apu_context, dict) else {}
        self.config = config if isinstance(config, dict) else {}
        self.profile = profile if isinstance(profile, dict) else {}
        self.keyword_cache = keyword_cache

        # Inicializar especialistas con manejo de errores
        try:
            self.pattern_matcher = PatternMatcher()
            self.units_validator = UnitsValidator()
            self.thresholds = self._load_validation_thresholds()
            self.numeric_extractor = NumericFieldExtractor(
                self.config, self.profile, self.thresholds
            )
        except Exception as e:
            logger.error(f"Error inicializando especialistas: {e}")
            raise RuntimeError(f"Fallo en inicializaci√≥n de APUTransformer: {e}") from e

        super().__init__()

    def _extract_value(self, item: Any) -> str:
        """
        Extrae el valor string de un token o string de forma segura.
        
        ROBUSTECIDO:
        - Manejo expl√≠cito de cada tipo esperado
        - Eliminaci√≥n de c√≥digo muerto (bytes no esperados en Lark)
        - Logging espec√≠fico para casos inesperados
        - Sanitizaci√≥n de salida
        """
        if item is None:
            return ""

        # Caso 1: Token de Lark (caso m√°s com√∫n)
        if isinstance(item, Token):
            raw_value = item.value
            if raw_value is None:
                return ""
            # ROBUSTECIDO: Asegurar que siempre devolvemos string limpio
            return str(raw_value).strip()

        # Caso 2: String directo
        if isinstance(item, str):
            return item.strip()

        # Caso 3: Lista (puede ocurrir con reglas anidadas)
        if isinstance(item, (list, tuple)):
            if not item:
                return ""
            # ROBUSTECIDO: Procesar recursivamente el primer elemento no vac√≠o
            for sub_item in item:
                extracted = self._extract_value(sub_item)
                if extracted:
                    return extracted
            return ""

        # Caso 4: Tipo inesperado - log y conversi√≥n segura
        logger.debug(
            f"_extract_value: tipo inesperado {type(item).__name__}, "
            f"valor: {repr(item)[:100]}"
        )
        try:
            return str(item).strip()
        except Exception as e:
            logger.warning(f"No se pudo convertir a string: {type(item).__name__}, error: {e}")
            return ""

    def field(self, args: List[Any]) -> str:
        """
        Procesa un campo individual parseado por Lark.
        
        ROBUSTECIDO:
        - Manejo de lista vac√≠a
        - Manejo de m√∫ltiples elementos en args
        - Validaci√≥n de longitud m√°xima
        """
        if not args:
            return ""

        # ROBUSTECIDO: Si hay m√∫ltiples elementos, concatenar (caso raro pero posible)
        if len(args) > 1:
            logger.debug(f"field() recibi√≥ {len(args)} elementos, concatenando")
            parts = [self._extract_value(arg) for arg in args]
            result = " ".join(filter(None, parts))
        else:
            result = self._extract_value(args[0])

        # ROBUSTECIDO: Limitar longitud para evitar campos an√≥malos
        if len(result) > self._MAX_DESCRIPTION_LENGTH:
            logger.warning(
                f"Campo truncado de {len(result)} a {self._MAX_DESCRIPTION_LENGTH} caracteres"
            )
            result = result[:self._MAX_DESCRIPTION_LENGTH]

        return result

    def field_with_value(self, args: List[Any]) -> str:
        """Procesa un campo que tiene valor expl√≠cito."""
        return self.field(args)

    def field_empty(self, args: List[Any]) -> str:
        """Procesa un campo vac√≠o expl√≠cito."""
        return ""

    def line(self, args: List[Any]) -> Optional[InsumoProcesado]:
        """
        Procesa una l√≠nea parseada por Lark.
        
        ROBUSTECIDO:
        - Filtrado mejorado de tokens SEP con validaci√≥n de tipo
        - Manejo defensivo de estructuras inesperadas
        - Validaci√≥n temprana de campos m√≠nimos
        - Logging detallado para diagn√≥stico
        """
        if not args:
            logger.debug("line() recibi√≥ args vac√≠o")
            return None

        fields = []
        skipped_tokens = 0

        for arg in args:
            # ROBUSTECIDO: Identificaci√≥n precisa de tokens SEP
            if isinstance(arg, Token):
                if arg.type == self._SEP_TOKEN_TYPE:
                    skipped_tokens += 1
                    continue
                # Token que no es SEP - extraer valor
                value = self._extract_value(arg)
                if value is not None:  # Permitir strings vac√≠os
                    fields.append(value)
            elif isinstance(arg, list):
                # ROBUSTECIDO: Procesar listas de forma recursiva pero controlada
                for sub_arg in arg:
                    if isinstance(sub_arg, Token) and sub_arg.type == self._SEP_TOKEN_TYPE:
                        skipped_tokens += 1
                        continue
                    value = self._extract_value(sub_arg)
                    if value is not None:
                        fields.append(value)
            else:
                # Caso directo (string u otro)
                value = self._extract_value(arg)
                if value is not None:
                    fields.append(value)

        # ROBUSTECIDO: Logging de diagn√≥stico en modo debug
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug(
                f"line(): {len(args)} args -> {len(fields)} campos "
                f"(skipped {skipped_tokens} SEP tokens)"
            )

        # Limpiar campos vac√≠os al final
        clean_fields = self._filter_trailing_empty(fields)

        # ROBUSTECIDO: Validaci√≥n temprana con mensajes espec√≠ficos
        if not clean_fields:
            logger.debug("line(): todos los campos est√°n vac√≠os despu√©s de limpieza")
            return None

        if not clean_fields[0] or not clean_fields[0].strip():
            logger.debug("line(): primer campo (descripci√≥n) est√° vac√≠o")
            return None

        # ROBUSTECIDO: Verificar m√≠nimo de campos antes de procesar
        if len(clean_fields) < self._MIN_FIELDS_FOR_VALID_LINE:
            logger.debug(
                f"line(): insuficientes campos ({len(clean_fields)} < "
                f"{self._MIN_FIELDS_FOR_VALID_LINE})"
            )
            return None

        # Detectar formato y construir
        formato = self._detect_format(clean_fields)

        if formato == FormatoLinea.DESCONOCIDO:
            logger.debug(f"line(): formato desconocido para: {clean_fields[0][:50]}...")
            return None

        return self._dispatch_builder(formato, clean_fields)

    def _filter_trailing_empty(self, tokens: List[str]) -> List[str]:
        """
        Elimina campos vac√≠os al final de una lista de campos.
        
        ROBUSTECIDO:
        - Manejo de lista vac√≠a
        - Manejo de lista con solo elementos vac√≠os
        - Preservaci√≥n de campos vac√≠os intermedios (importante para estructura)
        """
        if not tokens:
            return []

        # Encontrar el √∫ltimo √≠ndice con contenido
        last_non_empty_idx = -1
        for i in range(len(tokens) - 1, -1, -1):
            # ROBUSTECIDO: Verificar que es string antes de strip
            token = tokens[i]
            if isinstance(token, str) and token.strip():
                last_non_empty_idx = i
                break
            elif token and not isinstance(token, str):
                # Caso inesperado pero manejable
                last_non_empty_idx = i
                break

        if last_non_empty_idx < 0:
            return []

        return tokens[: last_non_empty_idx + 1]

    def _dispatch_builder(
        self, formato: FormatoLinea, tokens: List[str]
    ) -> Optional[InsumoProcesado]:
        """
        Llama al m√©todo constructor adecuado seg√∫n el formato detectado.
        
        ROBUSTECIDO:
        - Try/except espec√≠fico por tipo de formato
        - Logging con contexto completo
        - Validaci√≥n de resultado antes de retornar
        """
        builder_map = {
            FormatoLinea.MO_COMPLETA: self._build_mo_completa,
            FormatoLinea.INSUMO_BASICO: self._build_insumo_basico,
        }

        builder = builder_map.get(formato)
        if builder is None:
            logger.warning(f"No hay builder para formato: {formato}")
            return None

        try:
            result = builder(tokens)

            # ROBUSTECIDO: Validar que el resultado es del tipo esperado
            if result is not None and not isinstance(result, InsumoProcesado):
                logger.error(
                    f"Builder {formato.value} retorn√≥ tipo inesperado: "
                    f"{type(result).__name__}"
                )
                return None

            return result

        except ValueError as ve:
            # Errores de validaci√≥n de datos - esperados en algunos casos
            logger.debug(f"Validaci√≥n fallida en {formato.value}: {ve}")
            return None
        except TypeError as te:
            # Errores de tipos - indica problema en l√≥gica
            logger.error(f"Error de tipo en {formato.value}: {te}, tokens: {tokens[:3]}")
            return None
        except Exception as e:
            # Errores inesperados - log completo
            logger.error(
                f"Error inesperado construyendo {formato.value}: "
                f"{type(e).__name__}: {e}"
            )
            if self.config.get("debug_mode", False):
                import traceback
                logger.debug(f"Traceback:\n{traceback.format_exc()}")
            return None

### 3. APUProcessor - M√©todos de Parsing Robustecidos

class APUProcessor:
    """Procesador de APUs - M√©todos de parsing robustecidos."""

    def _initialize_parser(self) -> Optional["Lark"]:
        """
        Inicializa el parser Lark con validaci√≥n exhaustiva.
        
        ROBUSTECIDO:
        - Validaci√≥n de gram√°tica antes de crear parser
        - Manejo espec√≠fico de diferentes tipos de errores Lark
        - Configuraci√≥n optimizada para rendimiento y diagn√≥stico
        - Fallback informativo en caso de fallo
        """
        try:
            from lark import Lark
            from lark.exceptions import GrammarError, ConfigurationError

            # ROBUSTECIDO: Validar que la gram√°tica no est√° vac√≠a
            if not APU_GRAMMAR or not APU_GRAMMAR.strip():
                logger.error("APU_GRAMMAR est√° vac√≠a o no definida")
                return None

            # Configuraci√≥n del parser con opciones expl√≠citas
            parser_config = {
                "start": "line",
                "parser": "lalr",  # M√°s r√°pido y predecible que earley
                "maybe_placeholders": False,
                "propagate_positions": False,  # Desactivar si no se necesita posici√≥n
                "cache": True,  # Cache de estados del parser
            }

            # ROBUSTECIDO: Modo debug con m√°s informaci√≥n
            if self.config.get("debug_mode", False):
                parser_config["debug"] = True
                logger.info("Parser Lark inicializado en modo debug")

            parser = Lark(APU_GRAMMAR, **parser_config)

            # ROBUSTECIDO: Validaci√≥n post-creaci√≥n
            if parser is None:
                logger.error("Lark retorn√≥ None al crear parser")
                return None

            # Test de sanidad: intentar parsear una l√≠nea simple
            try:
                test_result = parser.parse("test;value;123")
                if test_result is None:
                    logger.warning("Test de sanidad del parser retorn√≥ None")
            except Exception as test_error:
                logger.warning(
                    f"Test de sanidad del parser fall√≥ (puede ser esperado): {test_error}"
                )

            logger.info("‚úì Parser Lark inicializado correctamente")
            return parser

        except GrammarError as ge:
            logger.error(
                f"Error de gram√°tica Lark:\n"
                f"  Mensaje: {ge}\n"
                f"  Revise APU_GRAMMAR para errores de sintaxis"
            )
            return None

        except ConfigurationError as ce:
            logger.error(f"Error de configuraci√≥n Lark: {ce}")
            return None

        except ImportError as ie:
            logger.error(
                f"No se pudo importar Lark: {ie}\n"
                f"  Ejecute: pip install lark"
            )
            return None

        except Exception as e:
            logger.error(
                f"Error inesperado inicializando parser Lark:\n"
                f"  Tipo: {type(e).__name__}\n"
                f"  Error: {e}"
            )
            if self.config.get("debug_mode", False):
                import traceback
                logger.debug(f"Traceback:\n{traceback.format_exc()}")
            return None

    def _process_apu_lines(
        self,
        lines: List[str],
        apu_context: Dict[str, Any],
        line_cache: Optional[Dict[str, Any]] = None,
    ) -> List["InsumoProcesado"]:
        """
        Procesa l√≠neas de APU con reutilizaci√≥n de cache de parsing.
        
        ROBUSTECIDO:
        - Reutilizaci√≥n de transformer para eficiencia
        - Validaci√≥n de integridad del cache
        - Manejo espec√≠fico de cada tipo de error Lark
        - L√≠mites de tiempo y recursos
        - Estad√≠sticas detalladas
        """
        if not lines:
            return []

        # ROBUSTECIDO: Verificar que el parser est√° disponible
        if self.parser is None:
            logger.error("Parser no inicializado, no se pueden procesar l√≠neas")
            return []

        results = []
        stats = ParsingStats()
        apu_code = apu_context.get("codigo_apu", "UNKNOWN")

        # ROBUSTECIDO: Usar cache combinado con validaci√≥n
        active_cache = self._validate_and_merge_cache(line_cache)

        # ROBUSTECIDO: Reutilizar transformer para todas las l√≠neas del APU
        # (m√°s eficiente que crear uno nuevo por l√≠nea)
        transformer = APUTransformer(
            apu_context, self.config, self.profile, self.keyword_cache
        )

        logger.debug(
            f"Procesando {len(lines)} l√≠neas para APU: {apu_code} "
            f"(cache: {len(active_cache)} entradas)"
        )

        for line_num, line in enumerate(lines, start=1):
            # ROBUSTECIDO: Validaci√≥n temprana de l√≠nea
            if not self._is_valid_line(line):
                continue

            stats.total_lines += 1
            line_clean = line.strip()
            insumo = None
            tree = None

            try:
                # PASO 1: Intentar obtener √°rbol del cache
                cache_key = self._compute_cache_key(line_clean)
                if cache_key in active_cache:
                    cached_tree = active_cache[cache_key]
                    # ROBUSTECIDO: Validar que el √°rbol cacheado es usable
                    if self._is_valid_tree(cached_tree):
                        tree = cached_tree
                        stats.cache_hits += 1
                        logger.debug(f"  ‚ö° L√≠nea {line_num}: Usando √°rbol del cache")
                    else:
                        logger.debug(
                            f"  ‚ö†Ô∏è L√≠nea {line_num}: √Årbol en cache inv√°lido, re-parseando"
                        )

                # PASO 2: Parsear si no hay √°rbol v√°lido en cache
                if tree is None:
                    tree = self._parse_line_safe(line_clean, line_num, stats)
                    if tree is None:
                        continue  # Error ya registrado en stats

                # PASO 3: Transformar √°rbol a insumo
                insumo = self._transform_tree_safe(
                    tree, transformer, line_clean, line_num, stats
                )

                # PASO 4: Agregar resultado si es v√°lido
                if insumo is not None:
                    # ROBUSTECIDO: Validar estructura del insumo antes de agregar
                    if self._validate_insumo(insumo):
                        insumo.line_number = line_num
                        results.append(insumo)
                    else:
                        logger.debug(f"  ‚ö†Ô∏è L√≠nea {line_num}: Insumo inv√°lido descartado")
                        stats.empty_results += 1
                else:
                    stats.failed_lines.append({
                        "line_number": line_num,
                        "content": line_clean[:100],
                        "apu_code": apu_code,
                        "reason": "transform_returned_none",
                    })

            except Exception as unexpected_error:
                self._handle_unexpected_error(
                    unexpected_error, line_num, line_clean, apu_code, stats
                )
                continue

        # Log y merge de estad√≠sticas
        self._log_parsing_stats(apu_code, stats)
        self._merge_stats(stats)

        return results

    def _validate_and_merge_cache(
        self, line_cache: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Valida y combina caches de parsing.
        
        ROBUSTECIDO:
        - Verificaci√≥n de tipos de cache
        - L√≠mite de tama√±o para evitar uso excesivo de memoria
        """
        MAX_CACHE_SIZE = 50000  # L√≠mite razonable

        combined = {}

        # Agregar cache global primero
        if self.parse_cache and isinstance(self.parse_cache, dict):
            combined.update(self.parse_cache)

        # Agregar cache espec√≠fico (sobrescribe si hay duplicados)
        if line_cache and isinstance(line_cache, dict):
            combined.update(line_cache)

        # ROBUSTECIDO: Limitar tama√±o del cache
        if len(combined) > MAX_CACHE_SIZE:
            logger.warning(
                f"Cache excede l√≠mite ({len(combined)} > {MAX_CACHE_SIZE}), "
                f"usando solo las primeras {MAX_CACHE_SIZE} entradas"
            )
            # Mantener las m√°s recientes (asumiendo dict ordenado en Python 3.7+)
            keys_to_keep = list(combined.keys())[-MAX_CACHE_SIZE:]
            combined = {k: combined[k] for k in keys_to_keep}

        return combined

    def _is_valid_line(self, line: Any) -> bool:
        """Verifica si una l√≠nea es v√°lida para procesamiento."""
        if line is None:
            return False
        if not isinstance(line, str):
            logger.debug(f"L√≠nea no es string: {type(line).__name__}")
            return False
        if not line.strip():
            return False
        # ROBUSTECIDO: Verificar longitud m√≠nima razonable
        if len(line.strip()) < 3:
            return False
        return True

    def _compute_cache_key(self, line: str) -> str:
        """
        Computa una clave de cache para una l√≠nea.
        
        ROBUSTECIDO: Normalizaci√≥n para mejorar hit rate.
        """
        # Normalizar espacios m√∫ltiples y case para mejor cache hit
        normalized = " ".join(line.split())
        return normalized

    def _is_valid_tree(self, tree: Any) -> bool:
        """
        Verifica que un √°rbol Lark del cache es v√°lido y usable.
        
        ROBUSTECIDO: Verificaci√≥n de estructura del √°rbol.
        """
        if tree is None:
            return False

        # Verificar que tiene la estructura b√°sica esperada
        try:
            # Un √°rbol Lark v√°lido deber√≠a tener data y children
            if not hasattr(tree, "data"):
                return False
            if not hasattr(tree, "children"):
                return False
            return True
        except Exception:
            return False

    def _parse_line_safe(
        self, line: str, line_num: int, stats: ParsingStats
    ) -> Optional[Any]:
        """
        Parsea una l√≠nea de forma segura con manejo espec√≠fico de errores.
        
        ROBUSTECIDO:
        - Manejo de cada tipo de excepci√≥n Lark
        - Logging contextual
        - Actualizaci√≥n de estad√≠sticas espec√≠ficas
        """
        from lark.exceptions import (
            UnexpectedCharacters,
            UnexpectedToken,
            UnexpectedInput,
            UnexpectedEOF,
        )

        try:
            return self.parser.parse(line)

        except UnexpectedCharacters as uc:
            stats.lark_unexpected_chars += 1
            logger.debug(
                f"  ‚úó L√≠nea {line_num}: Car√°cter inesperado en posici√≥n {uc.column}\n"
                f"    Contexto: ...{line[max(0, uc.column-10):uc.column+10]}..."
            )
            return None

        except UnexpectedToken as ut:
            stats.lark_parse_errors += 1
            logger.debug(
                f"  ‚úó L√≠nea {line_num}: Token inesperado '{ut.token}'\n"
                f"    Esperado: {ut.expected}"
            )
            return None

        except UnexpectedEOF as ueof:
            stats.lark_parse_errors += 1
            logger.debug(
                f"  ‚úó L√≠nea {line_num}: Fin de entrada inesperado\n"
                f"    Esperado: {ueof.expected}"
            )
            return None

        except UnexpectedInput as ui:
            stats.lark_unexpected_input += 1
            logger.debug(f"  ‚úó L√≠nea {line_num}: Entrada inesperada: {ui}")
            return None

        except LarkError as le:
            stats.lark_parse_errors += 1
            logger.warning(f"  ‚úó L√≠nea {line_num}: Error Lark gen√©rico: {le}")
            return None

        except Exception as e:
            stats.lark_parse_errors += 1
            logger.error(
                f"  üö® L√≠nea {line_num}: Error inesperado en parser\n"
                f"    Tipo: {type(e).__name__}\n"
                f"    Error: {e}"
            )
            return None

    def _transform_tree_safe(
        self,
        tree: Any,
        transformer: APUTransformer,
        line: str,
        line_num: int,
        stats: ParsingStats,
    ) -> Optional[InsumoProcesado]:
        """
        Transforma un √°rbol Lark de forma segura.
        
        ROBUSTECIDO:
        - Manejo de lista vs objeto √∫nico
        - Validaci√≥n de resultado
        - Estad√≠sticas detalladas
        """
        try:
            result = transformer.transform(tree)

            # Manejar caso donde transform devuelve lista
            if isinstance(result, list):
                if not result:
                    stats.empty_results += 1
                    logger.debug(f"  ‚ö†Ô∏è L√≠nea {line_num}: Transformer devolvi√≥ lista vac√≠a")
                    return None
                # Tomar el primer elemento v√°lido
                for item in result:
                    if item is not None:
                        stats.successful_parses += 1
                        return item
                stats.empty_results += 1
                return None

            # Resultado directo
            if result is not None:
                stats.successful_parses += 1
            else:
                stats.empty_results += 1
                logger.debug(f"  ‚ö†Ô∏è L√≠nea {line_num}: Transformer devolvi√≥ None")

            return result

        except Exception as transform_error:
            stats.transformer_errors += 1
            logger.error(
                f"  ‚úó L√≠nea {line_num}: Error en transformer\n"
                f"    Tipo: {type(transform_error).__name__}\n"
                f"    Error: {transform_error}\n"
                f"    L√≠nea: {line[:80]}..."
            )
            if self.debug_mode:
                import traceback
                logger.debug(f"Traceback:\n{traceback.format_exc()}")
            return None

    def _validate_insumo(self, insumo: InsumoProcesado) -> bool:
        """
        Valida que un insumo tiene los campos m√≠nimos requeridos.
        
        ROBUSTECIDO: Verificaci√≥n de campos obligatorios.
        """
        if insumo is None:
            return False

        # Campos m√≠nimos requeridos
        required_attrs = ["descripcion_insumo", "tipo_insumo"]
        for attr in required_attrs:
            if not hasattr(insumo, attr):
                return False
            value = getattr(insumo, attr)
            if value is None or (isinstance(value, str) and not value.strip()):
                return False

        # Validar que valores num√©ricos sean razonables
        if hasattr(insumo, "valor_total"):
            valor = getattr(insumo, "valor_total")
            if valor is not None and (valor < 0 or valor > 1e12):
                logger.debug(f"Insumo con valor_total fuera de rango: {valor}")
                return False

        return True

    def _handle_unexpected_error(
        self,
        error: Exception,
        line_num: int,
        line: str,
        apu_code: str,
        stats: ParsingStats,
    ) -> None:
        """Maneja errores inesperados de forma centralizada."""
        logger.error(
            f"  üö® L√≠nea {line_num}: Error inesperado\n"
            f"    APU: {apu_code}\n"
            f"    Tipo: {type(error).__name__}\n"
            f"    Error: {error}\n"
            f"    L√≠nea: {line[:100]}"
        )

        if self.debug_mode:
            import traceback
            logger.debug(f"Traceback completo:\n{traceback.format_exc()}")

        stats.failed_lines.append({
            "line_number": line_num,
            "content": line[:100],
            "error": str(error),
            "error_type": type(error).__name__,
            "apu_code": apu_code,
        })