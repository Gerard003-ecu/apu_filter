"""
Transformaremos el APUProcessor para que orqueste las transiciones de estado, absorbiendo la lógica matemática que antes residía erróneamente en el Director.

Implementación del Ciclo de Vida (State Machine) en apu_processor.py

"""

# 1. Implementación Extendida en apu_processor.py
A continuación, presento el código extendido. Se introducen la clase APULifecycleState y se refactoriza APUProcessor para usar transiciones monádicas.
A. Definición de Estados (Nuevo Enum)
Agrega esto al inicio de apu_processor.py, junto a los otros Enums.

class APULifecycleState(Enum):
    """
    Define la ontología del estado de un APU en el pipeline.
    
    1. RAW: Datos crudos recién parseados o cargados (Nivel Físico).
    2. STRUCTURED: Estructura sintáctica validada (Tipos correctos, campos no nulos).
    3. ENRICHED: Datos cruzados con maestros de insumos (Fusión completada).
    4. CLASSIFIED: Naturaleza ontológica definida (Material vs Mano de Obra).
    5. CALCULATED: Costos unitarios y totales computados (Nivel Táctico).
    6. VALIDATED: Reglas de negocio y topología verificadas (Listo para Estrategia).
    7. ERROR: Estado de fallo atrapado (Dead Letter).
    """
    RAW = auto()
    STRUCTURED = auto()
    ENRICHED = auto()
    CLASSIFIED = auto()
    CALCULATED = auto()
    VALIDATED = auto()
    ERROR = auto()

B. Refactorización del APUProcessor (Máquina de Estados)
Se extiende la clase para incluir el motor de transiciones.

# En app/apu_processor.py

class APUProcessor:
    # ... (__init__ y métodos existentes se mantienen) ...

    def process_lifecycle_monadic(self, raw_record: Dict[str, Any]) -> OptionMonad[InsumoProcesado]:
        """
        Orquestador Monádico del Ciclo de Vida.
        Transforma un registro crudo en un APU Validado pasando por todos los estados.
        Si cualquier paso falla, la Mónada captura el error y detiene la cadena.
        """
        # 1. RAW -> STRUCTURED (Parsing y Validación Física)
        monad = (OptionMonad.pure(raw_record)
                 .bind(self._parse_and_structure)
                 .bind(lambda apu: self._transition_to(apu, APULifecycleState.STRUCTURED)))

        # 2. STRUCTURED -> ENRICHED (Si hay datos externos para cruzar)
        # Nota: En un flujo batch, el enriquecimiento puede venir pre-inyectado
        monad = monad.bind(lambda apu: self._transition_to(apu, APULifecycleState.ENRICHED))

        # 3. ENRICHED -> CLASSIFIED (Inferencia Ontológica - Antes en Director)
        monad = monad.bind(lambda apu: self._transition_to(apu, APULifecycleState.CLASSIFIED))

        # 4. CLASSIFIED -> CALCULATED (Aritmética Táctica - Antes en Director)
        monad = monad.bind(lambda apu: self._transition_to(apu, APULifecycleState.CALCULATED))

        # 5. CALCULATED -> VALIDATED (Gatekeeper Final)
        monad = monad.bind(lambda apu: self._transition_to(apu, APULifecycleState.VALIDATED))

        return monad

    def _transition_to(self, apu: InsumoProcesado, target_state: APULifecycleState) -> OptionMonad[InsumoProcesado]:
        """
        Ejecuta la transición de estado aplicando los 'Gatekeepers' lógicos.
        """
        try:
            if target_state == APULifecycleState.STRUCTURED:
                # Validación de integridad estructural básica
                if not apu.descripcion_insumo or not apu.unidad_insumo:
                    return OptionMonad.fail(f"Estructura incompleta en {apu.codigo_apu}")

            elif target_state == APULifecycleState.CLASSIFIED:
                self._apply_classification(apu)
            
            elif target_state == APULifecycleState.CALCULATED:
                # AQUÍ reside ahora la lógica matemática
                self._apply_calculation(apu)
            
            elif target_state == APULifecycleState.VALIDATED:
                if not self._validate_business_rules(apu):
                    return OptionMonad.fail(f"Reglas de negocio fallidas para {apu.codigo_apu}")

            # Actualizar etiqueta de estado (si el objeto lo soporta)
            # apu.lifecycle_state = target_state 
            return OptionMonad.pure(apu)

        except Exception as e:
            logger.error(f"Fallo transición a {target_state.name} para APU {apu.codigo_apu}: {e}")
            return OptionMonad.fail(f"Error en estado {target_state.name}: {str(e)}")

    # -------------------------------------------------------------------------
    # LÓGICA TÁCTICA ENCAPSULADA (Migrada desde PipelineDirector/Calculators)
    # -------------------------------------------------------------------------

    def _apply_classification(self, apu: InsumoProcesado) -> None:
        """
        Determina la ontología del APU (Material, Equipo, MO).
        Integra la lógica de `APUClassifier` y expresiones regulares.
        """
        # 1. Clasificación por Patrones (Regex)
        # Lógica traída de APUCostCalculator._normalize_tipo_insumo [Fuente 635]
        if not apu.tipo_insumo or apu.tipo_insumo == "INDEFINIDO":
            inferred_type = self._infer_resource_type_by_pattern(apu.descripcion_insumo)
            apu.tipo_insumo = inferred_type.value

        # 2. Clasificación Estructural (Si es un APU padre)
        # Si tiene componentes hijos, usar `StructuralClassifier` [Fuente 557]
        # (Esta lógica se aplica más a nivel agregado, pero se prepara aquí)

    def _apply_calculation(self, apu: InsumoProcesado) -> None:
        """
        Motor Aritmético Táctico.
        Ejecuta: Valor Total = Cantidad * Precio Unitario * Factores.
        Reemplaza la aritmética dispersa de `calculate_insumo_costs` [Fuente 644].
        """
        # Validación de Finitud (Physics check)
        qty = 0.0 if math.isnan(apu.cantidad) else apu.cantidad
        price = 0.0 if math.isnan(apu.precio_unitario) else apu.precio_unitario

        # Aplicación de Factores de Desperdicio (Lógica de Entropía)
        # [Fuente 974]: Materiales tienen entropía/desperdicio inherente
        waste_factor = 1.0
        if apu.tipo_insumo == "MATERIAL":
             # Ejemplo: Configurable desde self.thresholds
            waste_factor = 1.05 
        
        # Cálculo Vectorial Escalar
        apu.valor_total = qty * price * waste_factor
        
        # Invariante de Negocio: No existen costos negativos [Fuente 771]
        if apu.valor_total < 0:
            logger.warning(f"Costo negativo detectado en {apu.id}. Coercionando a 0.")
            apu.valor_total = 0.0

    def _validate_business_rules(self, apu: InsumoProcesado) -> bool:
        """
        Validación Topológica y de Negocio (Gatekeeper Final).
        Integra validaciones de `DataValidator` [Fuente 771].
        """
        # Regla 1: Integridad de Enlace (No Huérfanos)
        if not apu.codigo_apu:
            return False 
        
        # Regla 2: Coherencia de Precios (Alertas de Precio Extremo)
        if apu.valor_total > self.config.get("max_cost_per_item", 1e9):
            logger.warning(f"Costo excesivo detectado en {apu.codigo_apu}")
            # No retornamos False porque puede ser un outlier válido, pero marcamos alerta
            # apu.add_warning("COSTO_EXCESIVO") 
        
        return True

    def _infer_resource_type_by_pattern(self, description: str) -> InsumoType:
        """Helper interno para clasificación por regex (lógica migrada)."""
        desc_upper = description.upper()
        # [Fuente 636] Patrones de clasificación
        if any(x in desc_upper for x in ["MANO DE OBRA", "CUADRILLA", "OFICIAL"]):
            return InsumoType.MANO_DE_OBRA
        if any(x in desc_upper for x in ["EQUIPO", "HERRAMIENTA", "MAQUINARIA"]):
            return InsumoType.EQUIPO
        if any(x in desc_upper for x in ["TRANSPORTE", "ACARREO"]):
            return InsumoType.TRANSPORTE
        return InsumoType.SUMINISTRO # Default seguro

3. Integración en el Pipeline Director
Una vez implementada esta máquina de estados, el pipeline_director.txt se simplifica drásticamente. El paso de cálculo ya no "calcula", solo invoca la transición de estado.

# En pipeline_director.py

class CalculateCostsStep(ProcessingStep):
    def execute(self, context: dict, telemetry: TelemetryContext) -> dict:
        telemetry.start_step("calculate_lifecycle")
        
        processor = APUProcessor(self.config, self.thresholds)
        raw_records = context["raw_records"] # O df_merged convertido a dicts
        
        processed_apus = []
        
        for record in raw_records:
            # EL DIRECTOR SOLO PIDE: "PROCESA EL CICLO DE VIDA"
            # No sabe de multiplicaciones ni reglas de if/else.
            result_monad = processor.process_lifecycle_monadic(record)
            
            if result_monad.is_valid():
                processed_apus.append(result_monad.value)
            else:
                telemetry.record_warning("lifecycle_rejected", result_monad.error)

        context["processed_apus"] = processed_apus
        telemetry.end_step("calculate_lifecycle", "success")
        return context

