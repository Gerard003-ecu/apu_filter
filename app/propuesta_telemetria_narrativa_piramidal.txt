Esta extensi√≥n de telemetry_narrative.py es fundamental para completar la visi√≥n del Consejo de Sabios. Al aplicar la l√≥gica piramidal, transformamos el reporte narrativo de una "lista plana de errores" a una historia causal profunda, donde el sistema explica no solo qu√© fall√≥, sino por qu√© la estructura del negocio (topolog√≠a) o la f√≠sica de los datos (flujo) hicieron inevitable el fallo financiero.
A continuaci√≥n, presento la refactorizaci√≥n de telemetry_narrative.py integrando la jerarqu√≠a DIKW (Datos, Informaci√≥n, Conocimiento, Sabidur√≠a) y los invariantes topol√≥gicos definidos en su arquitectura.

--------------------------------------------------------------------------------
1. Concepto: La Narrativa Estratificada
El nuevo narrador no trata todos los pasos por igual. Agrupa los TelemetrySpan en sus respectivos Estratos (definidos en schemas.txt) y aplica una l√≥gica de Clausura Transitiva:
‚Ä¢ Si falla la F√≠sica (Nivel 3), la T√°ctica (Nivel 2) es irrelevante (ruido).
‚Ä¢ Si la T√°ctica es incoherente (Ciclos Œ≤1‚Äã>0), la Estrategia (Nivel 1) es una alucinaci√≥n ("Falso Positivo").
2. C√≥digo Refactorizado: telemetry_narrative.py

"""
M√≥dulo de Narrativa de Telemetr√≠a H√≠brido (Lattice + DIKW + Topolog√≠a).

Extiende la l√≥gica algebraica de severidad con una estructura ontol√≥gica piramidal.
Transforma la ejecuci√≥n t√©cnica en un 'Juicio del Consejo'.

Referencias:
- LENGUAJE_CONSEJO.md [1]: Definici√≥n de la voz de los sabios.
- schemas.txt [2]: Definici√≥n del Enum Stratum.
"""

from dataclasses import dataclass, field
from enum import IntEnum
from itertools import chain
from typing import Any, Dict, Iterator, List, Optional, Tuple

from app.telemetry import StepStatus, TelemetryContext, TelemetrySpan
from app.schemas import Stratum  # Importaci√≥n cr√≠tica para la jerarqu√≠a

# --- Estructuras Algebraicas (Lattice Logic) ---
# [Se mantiene la clase SeverityLevel original...]

class SeverityLevel(IntEnum):
    OPTIMO = 0
    ADVERTENCIA = 1
    CRITICO = 2
    
    # ... (m√©todos from_step_status, supremum, infimum se mantienen igual)

# --- Estructuras de Datos Topol√≥gicas ---

@dataclass
class StratumAnalysis:
    """
    An√°lisis consolidado de un Estrato de la Pir√°mide.
    Representa la salud de una capa completa de realidad (F√≠sica, T√°ctica, Estrategia).
    """
    stratum: Stratum
    severity: SeverityLevel
    narrative: str
    metrics: Dict[str, Any]
    issues: List['Issue']

    @property
    def is_compromised(self) -> bool:
        return self.severity == SeverityLevel.CRITICO

@dataclass
class PyramidalReport:
    """
    Reporte final estructurado jer√°rquicamente (DIKW).
    Sustituye al NarrativeReport plano.
    """
    verdict: str                  # El Juicio Final (Wisdom)
    executive_summary: str        # Narrativa causal (Top-down)
    strata_analysis: Dict[str, Dict[str, Any]] # Detalle por nivel (Bottom-up)
    forensic_evidence: List[Dict[str, Any]]    # Trazabilidad de errores

# --- Narrador Piramidal ---

class PyramidalNarrator(TelemetryNarrator): # Hereda la l√≥gica base
    """
    Narrador que implementa la l√≥gica del 'Consejo de Sabios'.
    Organiza la evidencia forense seg√∫n la jerarqu√≠a DIKW.
    """

    # Mapeo de Pasos del Pipeline a Estratos (Ontolog√≠a del Sistema)
    STEP_TO_STRATUM = {
        # Nivel 3: F√çSICA (El Guardi√°n) - Ingesta y Estabilidad
        "load_data": Stratum.PHYSICS,
        "merge_data": Stratum.PHYSICS,
        "flux_condenser": Stratum.PHYSICS,
        "final_merge": Stratum.PHYSICS,
        
        # Nivel 2: T√ÅCTICA (El Arquitecto) - Estructura y Costos
        "calculate_costs": Stratum.TACTICS,
        "materialization": Stratum.TACTICS,
        "oracle_analyze": Stratum.TACTICS, # An√°lisis de polos/ceros
        
        # Nivel 1: ESTRATEGIA (El Or√°culo) - Valor y Riesgo
        "business_topology": Stratum.STRATEGY, # Genera el reporte de riesgo
        "financial_analysis": Stratum.STRATEGY,
        
        # Nivel 0: SABIDUR√çA (El Agente) - S√≠ntesis y Salida
        "build_output": Stratum.WISDOM,
        "response_preparation": Stratum.WISDOM
    }

    def summarize_execution(self, context: TelemetryContext) -> Dict[str, Any]:
        """
        Punto de entrada principal.
        Ejecuta la s√≠ntesis piramidal.
        """
        # 1. An√°lisis por Fases (L√≥gica Algebraica existente)
        # Reutilizamos _analyze_phase de la clase base para obtener datos crudos
        root_spans = context.root_spans
        phases_analysis = [self._analyze_phase(span) for span in root_spans]

        # 2. Agrupaci√≥n por Estratos (L√≥gica Topol√≥gica)
        strata_results = self._group_by_stratum(phases_analysis)

        # 3. Construcci√≥n de Narrativa Causal (L√≥gica DIKW)
        narrative, verdict = self._synthesize_wisdom(strata_results)

        # 4. Generaci√≥n del Reporte
        report = PyramidalReport(
            verdict=verdict,
            executive_summary=narrative,
            strata_analysis={k.name: v.to_dict() for k, v in strata_results.items()}, # Asumiendo m√©todo to_dict en StratumAnalysis
            forensic_evidence=[i.to_dict() for i in self._extract_critical_evidence(strata_results)]
        )
        
        return report.__dict__ # Simplificado para el ejemplo

    def _group_by_stratum(self, phases: List['PhaseAnalysis']) -> Dict[Stratum, StratumAnalysis]:
        """Agrupa los an√°lisis de fases en estratos coherentes."""
        grouped = {s: [] for s in Stratum}
        
        for phase in phases:
            # Identificar estrato del paso
            stratum = self.STEP_TO_STRATUM.get(phase.name, Stratum.PHYSICS) # Default a Physics si desconocido
            grouped[stratum].append(phase)

        results = {}
        for stratum in Stratum: # Iterar en orden (WISDOM -> STRATEGY -> TACTICS -> PHYSICS)
            phases_in_stratum = grouped[stratum]
            
            # Calcular severidad del estrato (Supremo del lattice)
            severity = SeverityLevel.supremum(*(p.severity for p in phases_in_stratum))
            
            # Generar narrativa espec√≠fica del nivel
            narrative = self._narrate_stratum(stratum, phases_in_stratum, severity)
            
            results[stratum] = StratumAnalysis(
                stratum=stratum,
                severity=severity,
                narrative=narrative,
                metrics=self._aggregate_metrics(phases_in_stratum),
                issues=list(chain.from_iterable(p.issues for p in phases_in_stratum))
            )
            
        return results

    def _narrate_stratum(self, stratum: Stratum, phases: List['PhaseAnalysis'], severity: SeverityLevel) -> str:
        """
        Genera la voz del 'Sabio' correspondiente al nivel.
        Ref: LENGUAJE_CONSEJO.md
        """
        if not phases:
            return "Nivel inactivo."

        if severity == SeverityLevel.OPTIMO:
            if stratum == Stratum.PHYSICS:
                return "‚úÖ **Cimentaci√≥n Estable**: Flujo laminar de datos confirmado. Sin turbulencia (Flyback)."
            elif stratum == Stratum.TACTICS:
                return "‚úÖ **Estructura Coherente**: Topolog√≠a conexa (Œ≤‚ÇÄ=1) y ac√≠clica (Œ≤‚ÇÅ=0)."
            elif stratum == Stratum.STRATEGY:
                return "‚úÖ **Viabilidad Confirmada**: El modelo financiero es robusto ante la volatilidad."

        # Narrativa de Fallo (La parte interesante)
        if severity >= SeverityLevel.ADVERTENCIA:
            if stratum == Stratum.PHYSICS:
                return "üî• **Falla en Cimentaci√≥n**: Se detect√≥ inestabilidad f√≠sica (Saturaci√≥n/Flyback). Los datos no son confiables."
            elif stratum == Stratum.TACTICS:
                # Buscar evidencia espec√≠fica de ciclos
                has_cycles = any("ciclo" in i.message.lower() for p in phases for i in p.issues)
                if has_cycles:
                    return "üîÑ **Socav√≥n L√≥gico Detectado**: La estructura contiene bucles infinitos (Œ≤‚ÇÅ > 0). El costo es incalculable."
                return "üèóÔ∏è **Fragmentaci√≥n**: El grafo del proyecto est√° desconectado (Islas de datos)."
            elif stratum == Stratum.STRATEGY:
                return "üìâ **Riesgo Sist√©mico**: Aunque la estructura es v√°lida, la simulaci√≥n financiera proyecta p√©rdidas (VaR alto)."

        return "Ejecuci√≥n completada con advertencias menores."

    def _synthesize_wisdom(self, strata: Dict[Stratum, StratumAnalysis]) -> Tuple[str, str]:
        """
        La fase de Sabidur√≠a: Determina la causalidad del estado final.
        Aplica la regla de Clausura Transitiva: Fallo abajo implica fallo arriba.
        """
        # 1. Chequeo de F√≠sica (Nivel 3 - Base)
        physics = strata[Stratum.PHYSICS]
        if physics.is_compromised:
            return (
                "‚õî **PROCESO ABORTADO POR INESTABILIDAD F√çSICA**\n"
                "El Guardi√°n detect√≥ que el flujo de datos es turbulento o corrupto. "
                "No tiene sentido analizar la estrategia financiera de datos que no existen f√≠sicamente.\n"
                f"> Diagn√≥stico: {physics.narrative}",
                "RECHAZADO_TECNICO"
            )

        # 2. Chequeo de T√°ctica (Nivel 2 - Estructura)
        tactics = strata[Stratum.TACTICS]
        if tactics.is_compromised:
            return (
                "üöß **VETO ESTRUCTURAL DEL ARQUITECTO**\n"
                "Los datos son legibles, pero forman una estructura imposible (Pir√°mide Invertida o Ciclos). "
                "Cualquier c√°lculo financiero sobre esta base ser√≠a una alucinaci√≥n.\n"
                f"> Diagn√≥stico: {tactics.narrative}",
                "VETO_ESTRUCTURAL"
            )

        # 3. Chequeo de Estrategia (Nivel 1 - Valor)
        strategy = strata[Stratum.STRATEGY]
        if strategy.is_compromised:
            return (
                "üìâ **ALERTA FINANCIERA DEL OR√ÅCULO**\n"
                "La estructura es s√≥lida, pero el mercado es hostil o el proyecto no es rentable.\n"
                f"> Diagn√≥stico: {strategy.narrative}",
                "RIESGO_FINANCIERO"
            )

        # 4. Sabidur√≠a (√âxito)
        return (
            "üèõÔ∏è **CERTIFICADO DE SOLIDEZ INTEGRAL**\n"
            "El Consejo valida el proyecto en todas sus dimensiones: "
            "F√≠sicamente estable, Topol√≥gicamente conexo y Financieramente viable.",
            "APROBADO"
        )

    def _extract_critical_evidence(self, strata: Dict[Stratum, StratumAnalysis]) -> List['Issue']:
        """Extrae solo la evidencia relevante para el nivel de fallo m√°s bajo."""
        # Si falla f√≠sica, solo mostrar errores f√≠sicos. No ensuciar con errores consecuentes de estrategia.
        for stratum in reversed(Stratum): # PHYSICS (3) -> TACTICS (2) ...
             # Nota: IntEnum ordena WISDOM=0...PHYSICS=3. Reversed ir√≠a 3,2,1,0.
             pass 
        
        # L√≥gica simplificada: Recolectar todo lo cr√≠tico
        all_evidence = []
        for analysis in strata.values():
            for issue in analysis.issues:
                if issue.is_critical: # Usando la propiedad is_critical de la clase Issue original
                    # Enriquecer con contexto de estrato
                    issue.context = {"stratum": analysis.stratum.name}
                    all_evidence.append(issue)
        return all_evidence

3. Integraci√≥n y Beneficios
Esta extensi√≥n proporciona los siguientes beneficios cr√≠ticos basados en sus fuentes:
1. Diagn√≥stico Causal (Caja de Cristal): El m√©todo _synthesize_wisdom implementa expl√≠citamente la l√≥gica de que "La Econom√≠a no puede anular a la F√≠sica". Si el estrato PHYSICS falla, el reporte final lo dice claramente ("PROCESO ABORTADO POR INESTABILIDAD F√çSICA"), evitando que el usuario pierda tiempo analizando errores financieros que son solo efectos secundarios.
2. Lenguaje del Consejo: El m√©todo _narrate_stratum utiliza el vocabulario definido en LENGUAJE_CONSEJO.md, hablando de "Socavones L√≥gicos" y "Flujo Laminar" en lugar de KeyError o ValueError. Esto alinea la telemetr√≠a con la visi√≥n del producto.
3. Observabilidad Estructural: Al agrupar los pasos (load_data, calculate_costs) en estratos, el sistema proporciona una radiograf√≠a instant√°nea de d√≥nde est√° el problema en la pir√°mide de abstracci√≥n. Esto es esencial para la "Gobernanza Computacional Federada", ya que permite identificar si un fallo es local (un archivo corrupto) o sist√©mico (una mala estrategia).
Para aplicar esto, simplemente reemplace la clase TelemetryNarrator en telemetry_narrative.txt con esta versi√≥n extendida PyramidalNarrator, asegur√°ndose de importar Stratum desde schemas.