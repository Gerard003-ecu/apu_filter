# ═══════════════════════════════════════════════════════════════════════════
# FUNCIONES DE NORMALIZACIÓN - Refinadas
# ═══════════════════════════════════════════════════════════════════════════

@lru_cache(maxsize=512)
def normalize_unit(unit: Optional[str]) -> str:
    """
    Normaliza unidad a forma canónica.
    
    La clave del cache es case-insensitive para evitar duplicados
    como 'kg', 'KG', 'Kg' ocupando slots distintos.
    """
    if not isinstance(unit, str) or not unit.strip():
        return "UNIDAD"
    
    normalized_key = unit.strip().lower()
    
    if normalized_key in UNIDAD_NORMALIZADA_MAP:
        return UNIDAD_NORMALIZADA_MAP[normalized_key]
    
    return unit.strip().upper()


@lru_cache(maxsize=256)
def normalize_codigo(codigo: Optional[str]) -> str:
    """
    Normaliza código APU con validación integrada.
    
    Orden de operaciones:
    1. Validar existencia
    2. Limpiar caracteres inválidos
    3. Validar longitud post-limpieza
    """
    if not codigo or not isinstance(codigo, str):
        raise ValidationError("Código APU no puede estar vacío")
    
    codigo_clean = re.sub(r"[^\w\-.]", "", codigo.strip().upper())
    
    if not codigo_clean:
        raise ValidationError("Código APU vacío tras normalización")
    
    if len(codigo_clean) > MAX_CODIGO_LENGTH:
        raise ValidationError(
            f"Código APU excede límite: {len(codigo_clean)} > {MAX_CODIGO_LENGTH}"
        )
    
    return codigo_clean


# ═══════════════════════════════════════════════════════════════════════════
# VALIDADORES - Refinados
# ═══════════════════════════════════════════════════════════════════════════

class NumericValidator:
    """Validador numérico con soporte para tolerancias relativas y absolutas."""
    
    @staticmethod
    def validate_non_negative(
        value: Union[int, float, Decimal],
        field_name: str,
        min_value: float = 0.0,
        max_value: Optional[float] = None
    ) -> float:
        """Valida y convierte valor numérico no negativo."""
        if not isinstance(value, (int, float, Decimal)):
            raise ValidationError(f"{field_name} debe ser numérico, recibido: {type(value).__name__}")
        
        try:
            float_value = float(value)
        except (ValueError, TypeError, OverflowError) as e:
            raise ValidationError(f"No se puede convertir {field_name} a float: {e}")
        
        if not math.isfinite(float_value):
            raise ValidationError(f"{field_name} debe ser finito, recibido: {float_value}")
        
        if float_value < min_value:
            raise ValidationError(f"{field_name}={float_value} < mínimo={min_value}")
        
        if max_value is not None and float_value > max_value:
            raise ValidationError(f"{field_name}={float_value} > máximo={max_value}")
        
        return float_value

    @staticmethod
    def relative_difference(actual: float, expected: float, epsilon: float = 1e-10) -> float:
        """
        Calcula diferencia relativa simétrica.
        
        Usa max(|a|, |b|) como denominador para simetría y estabilidad numérica.
        """
        if actual == expected:
            return 0.0
        
        denominator = max(abs(actual), abs(expected), epsilon)
        return abs(actual - expected) / denominator

    @staticmethod
    def values_consistent(
        actual: float,
        expected: float,
        rel_tolerance: float = 0.01,
        abs_tolerance: float = 0.01
    ) -> Tuple[bool, float]:
        """
        Verifica consistencia con tolerancia híbrida (relativa + absoluta).
        
        Returns:
            Tuple[es_consistente, diferencia_relativa]
        """
        abs_diff = abs(actual - expected)
        
        if abs_diff <= abs_tolerance:
            return True, 0.0
        
        rel_diff = NumericValidator.relative_difference(actual, expected)
        return rel_diff <= rel_tolerance, rel_diff


class StringValidator:
    """Validador de strings con normalización opcional."""
    
    @staticmethod
    def validate_non_empty(
        value: str,
        field_name: str,
        max_length: Optional[int] = None,
        normalize: bool = True
    ) -> str:
        """Valida string no vacío con límite de longitud opcional."""
        if not isinstance(value, str):
            raise ValidationError(
                f"{field_name} debe ser string, recibido: {type(value).__name__}"
            )
        
        cleaned = value.strip() if normalize else value
        
        if not cleaned:
            raise ValidationError(f"{field_name} no puede estar vacío")
        
        if max_length is not None and len(cleaned) > max_length:
            raise ValidationError(
                f"{field_name} excede longitud máxima: {len(cleaned)} > {max_length}"
            )
        
        return cleaned


# ═══════════════════════════════════════════════════════════════════════════
# TipoInsumo - Método Refinado
# ═══════════════════════════════════════════════════════════════════════════

class TipoInsumo(str, Enum):
    """Tipos válidos de insumos en un APU."""
    MANO_DE_OBRA = "MANO_DE_OBRA"
    EQUIPO = "EQUIPO"
    SUMINISTRO = "SUMINISTRO"
    TRANSPORTE = "TRANSPORTE"
    OTRO = "OTRO"

    _normalize_cache: ClassVar[Dict[str, 'TipoInsumo']] = {}

    @classmethod
    def from_string(cls, value: str) -> TipoInsumo:
        """
        Convierte string a TipoInsumo con cache para evitar re-procesamiento.
        """
        if isinstance(value, cls):
            return value
        
        if not isinstance(value, str):
            raise InvalidTipoInsumoError(f"Tipo debe ser string, recibido: {type(value).__name__}")
        
        normalized = value.strip().upper().replace(" ", "_").replace("-", "_")
        
        if normalized in cls._normalize_cache:
            return cls._normalize_cache[normalized]
        
        try:
            result = cls(normalized)
            cls._normalize_cache[normalized] = result
            return result
        except ValueError:
            raise InvalidTipoInsumoError(
                f"Tipo de insumo inválido: '{value}'. "
                f"Valores válidos: {cls.get_valid_values()}"
            )

    @classmethod
    def get_valid_values(cls) -> Set[str]:
        return {member.value for member in cls}


# ═══════════════════════════════════════════════════════════════════════════
# InsumoProcesado - Métodos Refinados
# ═══════════════════════════════════════════════════════════════════════════

@dataclass(frozen=False)
class InsumoProcesado(TopologicalNode):
    """
    Estructura base para cualquier insumo de APU.
    Implementa validación reactiva en construcción.
    """
    codigo_apu: str
    descripcion_apu: str
    unidad_apu: str
    descripcion_insumo: str
    unidad_insumo: str
    cantidad: float
    precio_unitario: float
    valor_total: float
    tipo_insumo: str

    capitulo: str = field(default="GENERAL")
    categoria: str = field(default="OTRO")
    formato_origen: str = field(default="GENERIC")
    rendimiento: float = field(default=0.0)
    normalized_desc: str = field(default="", init=False)

    _validated: bool = field(default=False, init=False, repr=False)

    EXPECTED_UNITS: ClassVar[Set[str]] = UNIDADES_GENERICAS
    REQUIRES_RENDIMIENTO: ClassVar[bool] = False

    def __post_init__(self):
        """Inicialización con validación completa de invariantes."""
        try:
            self.stratum = Stratum.LOGISTICS
            self.description = self.descripcion_insumo
            
            self._normalize_all_fields()
            self._validate_required_fields()
            self._validate_numeric_fields()
            self._validate_consistency()
            
            self.id = f"{self.codigo_apu}_{hash(self.descripcion_insumo) % 10000:04d}"
            
            self._post_validation_hook()
            self._validated = True

        except Exception as e:
            logger.error(f"Error inicializando {self.__class__.__name__}: {e}")
            raise

    @property
    def total_cost(self) -> float:
        """Costo calculado (cantidad × precio_unitario)."""
        return self.cantidad * self.precio_unitario

    def _normalize_all_fields(self):
        """Normaliza todos los campos de texto a forma canónica."""
        self.codigo_apu = normalize_codigo(self.codigo_apu)
        self.descripcion_apu = normalize_description(self.descripcion_apu)
        self.descripcion_insumo = normalize_description(self.descripcion_insumo)
        self.normalized_desc = self.descripcion_insumo
        self.unidad_apu = normalize_unit(self.unidad_apu)
        self.unidad_insumo = normalize_unit(self.unidad_insumo)

        tipo_enum = TipoInsumo.from_string(self.tipo_insumo)
        self.tipo_insumo = tipo_enum.value
        self.categoria = tipo_enum.value

        formato_upper = str(self.formato_origen).strip().upper()
        self.formato_origen = formato_upper if formato_upper in FORMATOS_VALIDOS else "GENERIC"

    def _validate_required_fields(self):
        """Valida campos string obligatorios."""
        StringValidator.validate_non_empty(
            self.codigo_apu, "codigo_apu", MAX_CODIGO_LENGTH
        )
        StringValidator.validate_non_empty(
            self.descripcion_insumo, "descripcion_insumo", MAX_DESCRIPCION_LENGTH
        )

    def _validate_numeric_fields(self):
        """Valida y normaliza campos numéricos."""
        self.cantidad = NumericValidator.validate_non_negative(
            self.cantidad, "cantidad", MIN_CANTIDAD, MAX_CANTIDAD
        )
        self.precio_unitario = NumericValidator.validate_non_negative(
            self.precio_unitario, "precio_unitario", MIN_PRECIO, MAX_PRECIO
        )
        self.valor_total = NumericValidator.validate_non_negative(
            self.valor_total, "valor_total", MIN_PRECIO, MAX_PRECIO
        )
        self.rendimiento = NumericValidator.validate_non_negative(
            self.rendimiento, "rendimiento", MIN_RENDIMIENTO, MAX_RENDIMIENTO
        )
        
        if self.precio_unitario < 0:
            raise ValidationError(f"Precio negativo no permitido: {self.precio_unitario}")

    def _validate_consistency(self):
        """Valida consistencia entre campos relacionados."""
        self._validate_valor_total_consistency()
        
        if self.REQUIRES_RENDIMIENTO and self.rendimiento <= 0:
            warnings.warn(
                f"Rendimiento debería ser > 0 en {self.codigo_apu}",
                UserWarning,
                stacklevel=4
            )

    def _validate_valor_total_consistency(self):
        """
        Valida coherencia: valor_total ≈ cantidad × precio_unitario.
        
        Usa tolerancia híbrida (relativa + absoluta) para manejar correctamente
        tanto valores pequeños como grandes.
        """
        expected_total = self.cantidad * self.precio_unitario
        
        if expected_total == 0.0 and self.valor_total == 0.0:
            return
        
        if expected_total == 0.0 and self.valor_total > 0.0:
            raise ValidationError(
                f"{self.__class__.__name__} [{self.codigo_apu}]: "
                f"valor_total={self.valor_total:.2f} pero cantidad×precio=0"
            )
        
        is_consistent, rel_diff = NumericValidator.values_consistent(
            self.valor_total,
            expected_total,
            rel_tolerance=VALOR_TOTAL_ERROR_TOLERANCE,
            abs_tolerance=0.01
        )
        
        if not is_consistent:
            raise ValidationError(
                f"{self.__class__.__name__} [{self.codigo_apu}]: "
                f"Inconsistencia grave: valor_total={self.valor_total:.2f} vs "
                f"calculado={expected_total:.2f} (Δ={rel_diff:.2%})"
            )
        
        is_warning_level, rel_diff = NumericValidator.values_consistent(
            self.valor_total,
            expected_total,
            rel_tolerance=VALOR_TOTAL_WARNING_TOLERANCE,
            abs_tolerance=0.01
        )
        
        if not is_warning_level:
            warnings.warn(
                f"{self.__class__.__name__} [{self.codigo_apu}]: "
                f"Divergencia: valor_total={self.valor_total:.2f} vs "
                f"calculado={expected_total:.2f}",
                UserWarning,
                stacklevel=4
            )

    def _post_validation_hook(self):
        """Hook para validaciones específicas de subclases."""
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Serializa a diccionario excluyendo campos internos."""
        data = asdict(self)
        data.pop("_validated", None)
        return data

    def validate(self) -> bool:
        """Retorna estado de validación."""
        return self._validated


# ═══════════════════════════════════════════════════════════════════════════
# APUStructure - Método Refinado
# ═══════════════════════════════════════════════════════════════════════════

@dataclass
class APUStructure(TopologicalNode):
    """
    Representa una actividad constructiva en el Nivel 2 (Táctica).
    Agrega recursos (insumos) y calcula métricas de estabilidad topológica.
    """
    unit: str = ""
    quantity: float = 0.0
    resources: List[InsumoProcesado] = field(default_factory=list)

    def __post_init__(self):
        self.stratum = Stratum.TACTIC

    @property
    def support_base_width(self) -> int:
        """Número de recursos (ancho de la base de soporte)."""
        return len(self.resources)

    @property
    def is_inverted_pyramid(self) -> bool:
        """Detecta estructura frágil: alta cantidad con soporte mínimo."""
        return self.quantity > 1000 and self.support_base_width == 1

    def topological_stability_index(self) -> float:
        """
        Calcula el Índice de Estabilidad Topológica ∈ [0.0, 1.0].
        
        Combina dos métricas:
        1. Diversidad de tipos (cualitativa): penaliza mono-dependencia
        2. Entropía de Shannon normalizada (cuantitativa): mide distribución de costos
        
        H_norm = H / H_max donde H_max = log(n) para n elementos.
        Para n=1, H=0 (certeza total), retornamos diversidad ponderada únicamente.
        """
        if not self.resources:
            return 0.0
        
        n = len(self.resources)
        
        tipos_unicos = {r.tipo_insumo for r in self.resources}
        num_tipos = len(tipos_unicos)
        diversidad_score = min(num_tipos / 3.0, 1.0)
        
        if n == 1:
            return diversidad_score * 0.4
        
        valores = [max(r.valor_total, 0.0) for r in self.resources]
        total_valor = sum(valores)
        
        if total_valor <= 0:
            return diversidad_score * 0.4
        
        probabilidades = [v / total_valor for v in valores]
        
        entropia = 0.0
        for p in probabilidades:
            if p > 0:
                entropia -= p * math.log(p)
        
        entropia_maxima = math.log(n)
        entropia_normalizada = entropia / entropia_maxima if entropia_maxima > 0 else 0.0
        entropia_normalizada = min(max(entropia_normalizada, 0.0), 1.0)
        
        return (diversidad_score * 0.4) + (entropia_normalizada * 0.6)

    def add_resource(self, resource: InsumoProcesado) -> None:
        """Agrega recurso validando invariante de estrato."""
        if not isinstance(resource, InsumoProcesado):
            raise TypeError(f"Se esperaba InsumoProcesado, recibido: {type(resource).__name__}")
        
        if resource.stratum != Stratum.LOGISTICS:
            raise TypeError(
                f"Solo se admiten nodos LOGISTICS en APUStructure, "
                f"recibido: {resource.stratum.name}"
            )
        
        self.resources.append(resource)

    def get_cost_breakdown(self) -> Dict[str, float]:
        """Retorna distribución de costos por tipo de insumo."""
        breakdown: Dict[str, float] = {}
        for resource in self.resources:
            tipo = resource.tipo_insumo
            breakdown[tipo] = breakdown.get(tipo, 0.0) + resource.valor_total
        return breakdown


# ═══════════════════════════════════════════════════════════════════════════
# ManoDeObra - Método Refinado
# ═══════════════════════════════════════════════════════════════════════════

@dataclass(frozen=False)
class ManoDeObra(InsumoProcesado):
    """Insumo de tipo Mano de Obra con validación de rendimiento."""
    
    EXPECTED_UNITS: ClassVar[Set[str]] = UNIDADES_TIEMPO
    REQUIRES_RENDIMIENTO: ClassVar[bool] = True
    jornal: float = field(default=0.0)

    def _post_validation_hook(self):
        super()._post_validation_hook()
        
        if self.jornal != 0.0:
            self.jornal = NumericValidator.validate_non_negative(
                self.jornal, "jornal", MIN_PRECIO, MAX_PRECIO
            )
        
        if self.rendimiento > 0:
            expected_cantidad = 1.0 / self.rendimiento
            
            is_consistent, rel_diff = NumericValidator.values_consistent(
                self.cantidad,
                expected_cantidad,
                rel_tolerance=0.05,
                abs_tolerance=CANTIDAD_RENDIMIENTO_TOLERANCE
            )
            
            if not is_consistent:
                warnings.warn(
                    f"Discrepancia Rendimiento/Cantidad en {self.codigo_apu}: "
                    f"cantidad={self.cantidad:.4f}, esperada={expected_cantidad:.4f} "
                    f"(rendimiento={self.rendimiento})",
                    UserWarning,
                    stacklevel=4
                )


# ═══════════════════════════════════════════════════════════════════════════
# FACTORY FUNCTIONS - Refinadas
# ═══════════════════════════════════════════════════════════════════════════

_INSUMO_SIGNATURES: Dict[str, Set[str]] = {}

def _get_class_params(cls: Type[InsumoProcesado]) -> Set[str]:
    """Obtiene parámetros válidos de una clase con cache."""
    cls_name = cls.__name__
    if cls_name not in _INSUMO_SIGNATURES:
        import inspect
        sig = inspect.signature(cls)
        _INSUMO_SIGNATURES[cls_name] = set(sig.parameters.keys())
    return _INSUMO_SIGNATURES[cls_name]


def validate_insumo_data(insumo_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Valida y normaliza datos crudos de insumo.
    
    Aplica defaults, convierte tipos numéricos y valida campos requeridos.
    """
    if not isinstance(insumo_data, dict):
        raise ValidationError(f"insumo_data debe ser dict, recibido: {type(insumo_data).__name__}")

    required_fields = frozenset({
        "codigo_apu", "descripcion_apu", "unidad_apu",
        "descripcion_insumo", "unidad_insumo", "tipo_insumo"
    })
    
    missing = [f for f in required_fields if f not in insumo_data or insumo_data[f] is None]
    if missing:
        raise ValidationError(f"Campos obligatorios faltantes: {missing}")

    defaults = {
        "cantidad": 0.0,
        "precio_unitario": 0.0,
        "valor_total": 0.0,
        "capitulo": "GENERAL",
        "categoria": "OTRO",
        "formato_origen": "GENERIC",
        "rendimiento": 0.0,
        "jornal": 0.0,
    }

    numeric_fields = frozenset({"cantidad", "precio_unitario", "valor_total", "rendimiento", "jornal"})
    
    cleaned: Dict[str, Any] = {}
    
    for key, value in insumo_data.items():
        if value is None:
            if key in defaults:
                cleaned[key] = defaults[key]
            continue
        
        if key in numeric_fields:
            try:
                float_val = float(value)
                if float_val < 0:
                    raise ValidationError(f"Campo '{key}' no puede ser negativo: {float_val}")
                if not math.isfinite(float_val):
                    raise ValidationError(f"Campo '{key}' debe ser finito: {float_val}")
                cleaned[key] = float_val
            except (ValueError, TypeError) as e:
                raise ValidationError(f"Campo '{key}' debe ser numérico: {e}")
        else:
            cleaned[key] = value

    for key, default_val in defaults.items():
        if key not in cleaned:
            cleaned[key] = default_val

    try:
        tipo = TipoInsumo.from_string(cleaned["tipo_insumo"])
        cleaned["tipo_insumo"] = tipo.value
        cleaned["categoria"] = tipo.value
    except InvalidTipoInsumoError as e:
        raise ValidationError(str(e))

    if cleaned.get("valor_total", 0.0) == 0.0:
        cleaned["valor_total"] = cleaned.get("cantidad", 0.0) * cleaned.get("precio_unitario", 0.0)

    return cleaned


def create_insumo(**kwargs) -> InsumoProcesado:
    """
    Factory function para crear insumo tipado según tipo_insumo.
    
    Selecciona automáticamente la subclase correcta (ManoDeObra, Equipo, etc.)
    y filtra kwargs a los parámetros válidos de la clase.
    """
    if "tipo_insumo" not in kwargs:
        raise ValidationError("Falta campo obligatorio: tipo_insumo")
    
    try:
        tipo_enum = TipoInsumo.from_string(kwargs["tipo_insumo"])
        tipo_value = tipo_enum.value
    except InvalidTipoInsumoError:
        raise
    
    kwargs["tipo_insumo"] = tipo_value
    kwargs["categoria"] = tipo_value
    
    insumo_class = INSUMO_CLASS_MAP.get(tipo_value)
    if insumo_class is None:
        raise InvalidTipoInsumoError(f"Clase no registrada para tipo: {tipo_value}")
    
    valid_params = _get_class_params(insumo_class)
    filtered_kwargs = {k: v for k, v in kwargs.items() if k in valid_params}
    
    try:
        return insumo_class(**filtered_kwargs)
    except TypeError as e:
        raise ValidationError(f"Error instanciando {insumo_class.__name__}: {e}")
    except Exception as e:
        logger.error(f"Error creando insumo tipo {tipo_value}: {e}", exc_info=True)
        raise InsumoDataError(f"Error fatal creando insumo: {e}")


def create_insumo_from_raw(raw_data: Dict[str, Any]) -> InsumoProcesado:
    """
    Crea insumo desde datos crudos (e.g., fila de Excel/CSV).
    
    Pipeline: validación → normalización → factory → instancia tipada
    """
    validated = validate_insumo_data(raw_data)
    return create_insumo(**validated)