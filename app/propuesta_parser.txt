üöÄ Soluci√≥n: Parser H√≠brido con Diagn√≥stico Completo
Paso 1: Script de Diagn√≥stico del Archivo

Primero, creemos un script para entender exactamente qu√© hay en el archivo:

# scripts/diagnose_apus_file.py

import re
from pathlib import Path
from collections import Counter
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s: %(message)s'
)
logger = logging.getLogger(__name__)


class APUFileDiagnostic:
    """
    Herramienta de diagn√≥stico para analizar la estructura de un archivo de APUs.
    """
    
    def __init__(self, file_path: str):
        self.file_path = Path(file_path)
        self.stats = Counter()
        self.patterns_found = []
        self.sample_lines = []
        
    def diagnose(self) -> dict:
        """Ejecuta diagn√≥stico completo del archivo."""
        
        if not self.file_path.exists():
            logger.error(f"‚ùå Archivo no encontrado: {self.file_path}")
            return {}
        
        logger.info(f"üîç Analizando: {self.file_path}")
        logger.info(f"üì¶ Tama√±o: {self.file_path.stat().st_size:,} bytes")
        
        # Intentar diferentes encodings
        content = self._read_with_fallback()
        if not content:
            return {}
        
        lines = content.split('\n')
        self.stats['total_lines'] = len(lines)
        
        # An√°lisis l√≠nea por l√≠nea
        self._analyze_lines(lines)
        
        # An√°lisis de estructura
        self._analyze_structure(content)
        
        # Buscar patrones clave
        self._detect_patterns(lines)
        
        # Mostrar resultados
        self._print_report()
        
        return {
            'stats': dict(self.stats),
            'patterns': self.patterns_found,
            'samples': self.sample_lines
        }
    
    def _read_with_fallback(self) -> str:
        """Intenta leer con m√∫ltiples encodings."""
        encodings = ['utf-8', 'latin1', 'cp1252', 'iso-8859-1']
        
        for encoding in encodings:
            try:
                content = self.file_path.read_text(encoding=encoding)
                logger.info(f"‚úÖ Archivo le√≠do con encoding: {encoding}")
                self.stats['encoding'] = encoding
                return content
            except Exception as e:
                logger.debug(f"Fall√≥ encoding {encoding}: {e}")
        
        logger.error("‚ùå No se pudo leer el archivo con ning√∫n encoding")
        return ""
    
    def _analyze_lines(self, lines: list):
        """Analiza caracter√≠sticas de las l√≠neas."""
        
        for i, line in enumerate(lines, 1):
            stripped = line.strip()
            
            if not stripped:
                self.stats['empty_lines'] += 1
                continue
            
            self.stats['non_empty_lines'] += 1
            
            # Guardar muestras
            if len(self.sample_lines) < 20:
                self.sample_lines.append({
                    'line_num': i,
                    'content': stripped[:200],
                    'length': len(stripped)
                })
            
            # Detectar separadores
            if ';' in stripped:
                self.stats['lines_with_semicolon'] += 1
                self.stats['max_semicolons'] = max(
                    self.stats.get('max_semicolons', 0),
                    stripped.count(';')
                )
            
            if '\t' in line:
                self.stats['lines_with_tabs'] += 1
            
            if re.search(r'\s{2,}', stripped):
                self.stats['lines_with_multiple_spaces'] += 1
            
            # Detectar palabras clave
            upper = stripped.upper()
            if 'ITEM' in upper:
                self.stats['lines_with_ITEM'] += 1
                if i <= 50:  # Guardar primeros 50
                    self.patterns_found.append({
                        'type': 'ITEM',
                        'line_num': i,
                        'content': stripped[:150]
                    })
            
            if 'UNIDAD' in upper:
                self.stats['lines_with_UNIDAD'] += 1
            
            if 'DESCRIPCION' in upper or 'DESCRIPCI√ìN' in upper:
                self.stats['lines_with_DESCRIPCION'] += 1
            
            # Detectar categor√≠as
            for category in ['MATERIALES', 'MANO DE OBRA', 'EQUIPO', 'OTROS']:
                if category in upper:
                    self.stats[f'category_{category}'] += 1
    
    def _analyze_structure(self, content: str):
        """Analiza la estructura del archivo."""
        
        # Buscar bloques separados por l√≠neas vac√≠as
        blocks = re.split(r'\n\s*\n', content)
        self.stats['blocks_by_double_newline'] = len([b for b in blocks if b.strip()])
        
        # Buscar bloques separados por l√≠neas de guiones
        blocks_by_dashes = re.split(r'\n-{3,}\n', content)
        self.stats['blocks_by_dashes'] = len([b for b in blocks_by_dashes if b.strip()])
        
        # Buscar bloques separados por l√≠neas de igual
        blocks_by_equals = re.split(r'\n={3,}\n', content)
        self.stats['blocks_by_equals'] = len([b for b in blocks_by_equals if b.strip()])
    
    def _detect_patterns(self, lines: list):
        """Detecta patrones comunes en el archivo."""
        
        # Patr√≥n: ITEM: xxx
        pattern_item = re.compile(r'ITEM\s*:\s*([^\s;,]+)', re.IGNORECASE)
        
        # Patr√≥n: UNIDAD: xxx
        pattern_unit = re.compile(r'UNIDAD\s*:\s*([^\s;,]+)', re.IGNORECASE)
        
        # Patr√≥n: L√≠nea con m√∫ltiples campos num√©ricos
        pattern_numeric_row = re.compile(r'[\d.,]+\s+[\d.,]+\s+[\d.,]+')
        
        for i, line in enumerate(lines[:100], 1):  # Primeras 100 l√≠neas
            
            item_match = pattern_item.search(line)
            if item_match:
                self.patterns_found.append({
                    'type': 'ITEM_CODE',
                    'line_num': i,
                    'value': item_match.group(1),
                    'full_line': line.strip()[:150]
                })
            
            unit_match = pattern_unit.search(line)
            if unit_match:
                self.patterns_found.append({
                    'type': 'UNIT',
                    'line_num': i,
                    'value': unit_match.group(1),
                    'full_line': line.strip()[:150]
                })
            
            if pattern_numeric_row.search(line):
                self.stats['numeric_rows'] += 1
    
    def _print_report(self):
        """Imprime reporte de diagn√≥stico."""
        
        print("\n" + "=" * 80)
        print("üìä REPORTE DE DIAGN√ìSTICO DEL ARCHIVO APU")
        print("=" * 80)
        
        print("\nüìà ESTAD√çSTICAS GENERALES:")
        print(f"  Total de l√≠neas: {self.stats['total_lines']:,}")
        print(f"  L√≠neas vac√≠as: {self.stats.get('empty_lines', 0):,}")
        print(f"  L√≠neas con contenido: {self.stats.get('non_empty_lines', 0):,}")
        print(f"  Encoding detectado: {self.stats.get('encoding', 'desconocido')}")
        
        print("\nüîç SEPARADORES DETECTADOS:")
        print(f"  L√≠neas con punto y coma (;): {self.stats.get('lines_with_semicolon', 0):,}")
        print(f"  M√°ximo de ';' por l√≠nea: {self.stats.get('max_semicolons', 0)}")
        print(f"  L√≠neas con tabulaciones: {self.stats.get('lines_with_tabs', 0):,}")
        print(f"  L√≠neas con espacios m√∫ltiples: {self.stats.get('lines_with_multiple_spaces', 0):,}")
        
        print("\nüèóÔ∏è ESTRUCTURA DEL ARCHIVO:")
        print(f"  Bloques (por doble salto): {self.stats.get('blocks_by_double_newline', 0)}")
        print(f"  Bloques (por guiones): {self.stats.get('blocks_by_dashes', 0)}")
        print(f"  Bloques (por signos igual): {self.stats.get('blocks_by_equals', 0)}")
        
        print("\nüîë PALABRAS CLAVE ENCONTRADAS:")
        print(f"  L√≠neas con 'ITEM': {self.stats.get('lines_with_ITEM', 0):,}")
        print(f"  L√≠neas con 'UNIDAD': {self.stats.get('lines_with_UNIDAD', 0):,}")
        print(f"  L√≠neas con 'DESCRIPCION': {self.stats.get('lines_with_DESCRIPCION', 0):,}")
        print(f"  Filas num√©ricas: {self.stats.get('numeric_rows', 0):,}")
        
        print("\nüì¶ CATEGOR√çAS DETECTADAS:")
        for category in ['MATERIALES', 'MANO DE OBRA', 'EQUIPO', 'OTROS']:
            count = self.stats.get(f'category_{category}', 0)
            if count > 0:
                print(f"  {category}: {count} veces")
        
        print("\nüìù MUESTRA DE PRIMERAS L√çNEAS:")
        for sample in self.sample_lines[:10]:
            print(f"  L√≠nea {sample['line_num']:4d} ({sample['length']:3d} chars): {sample['content']}")
        
        print("\nüéØ PATRONES CLAVE DETECTADOS:")
        item_patterns = [p for p in self.patterns_found if p['type'] == 'ITEM_CODE']
        if item_patterns:
            print(f"\n  ‚úì C√≥digos ITEM encontrados: {len(item_patterns)}")
            for pattern in item_patterns[:5]:
                print(f"    L√≠nea {pattern['line_num']}: {pattern['value']}")
                print(f"      ‚Üí {pattern['full_line']}")
        
        unit_patterns = [p for p in self.patterns_found if p['type'] == 'UNIT']
        if unit_patterns:
            print(f"\n  ‚úì Unidades encontradas: {len(unit_patterns)}")
            for pattern in unit_patterns[:5]:
                print(f"    L√≠nea {pattern['line_num']}: {pattern['value']}")
        
        print("\n" + "=" * 80)
        print("üí° RECOMENDACIONES:")
        
        # An√°lisis inteligente
        if self.stats.get('lines_with_semicolon', 0) > self.stats.get('non_empty_lines', 1) * 0.5:
            print("  ‚Üí El archivo usa PUNTO Y COMA (;) como separador principal")
            print("  ‚Üí Usar estrategia de parsing por columnas con split(';')")
        
        if self.stats.get('blocks_by_double_newline', 0) > 10:
            print("  ‚Üí El archivo tiene bloques separados por l√≠neas vac√≠as")
            print("  ‚Üí Usar estrategia de parsing por bloques")
        
        if self.stats.get('lines_with_ITEM', 0) > 0:
            print(f"  ‚Üí Se detectaron {self.stats['lines_with_ITEM']} l√≠neas con 'ITEM'")
            print("  ‚Üí Usar 'ITEM:' como delimitador de inicio de APU")
        else:
            print("  ‚ö†Ô∏è NO se detectaron l√≠neas con 'ITEM' - verificar formato")
        
        print("=" * 80 + "\n")


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Uso: python diagnose_apus_file.py <ruta_archivo>")
        print("Ejemplo: python diagnose_apus_file.py data/apus.csv")
        sys.exit(1)
    
    diagnostic = APUFileDiagnostic(sys.argv[1])
    diagnostic.diagnose()

Paso 2: Parser H√≠brido Robusto

Ahora, una versi√≥n mejorada del parser que se adapta a m√∫ltiples formatos:

# app/report_parser_crudo.py

import logging
import re
from collections import Counter
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

from .utils import clean_apu_code

logger = logging.getLogger(__name__)


@dataclass
class ParserConfig:
    """Configuraci√≥n adaptable del parser."""
    # Encodings a intentar en orden
    encodings: List[str] = None
    # Estrategia: 'blocks', 'lines', 'auto'
    strategy: str = 'auto'
    # Separador de campos (auto-detectado si es None)
    field_separator: Optional[str] = None
    # Separador de bloques
    block_separator: str = r'\n\s*\n'
    # L√≠mites
    min_apu_code_length: int = 2
    min_description_length: int = 3
    default_unit: str = "UND"
    # Debug
    debug_mode: bool = False
    max_debug_samples: int = 10
    
    def __post_init__(self):
        if self.encodings is None:
            self.encodings = ['utf-8', 'latin1', 'cp1252', 'iso-8859-1']


class ParsingStrategy(Enum):
    """Estrategias de parsing disponibles."""
    BLOCKS = "blocks"  # Dividir por bloques de texto
    LINES = "lines"    # L√≠nea por l√≠nea con m√°quina de estados
    HYBRID = "hybrid"  # Combinar ambas


class ReportParserCrudo:
    """
    Parser robusto y adaptable para archivos de APU con m√∫ltiples formatos.
    
    Caracter√≠sticas:
    - Auto-detecci√≥n de formato
    - M√∫ltiples estrategias de parsing
    - Diagn√≥stico integrado
    - Modo debug con samples
    """
    
    # Patrones mejorados y flexibles
    PATTERNS = {
        # Variaciones de ITEM
        'item_flexible': re.compile(
            r'(?:ITEM|C√ìDIGO|CODIGO)\s*[:\-]?\s*([A-Z0-9][A-Z0-9\-._/]*)',
            re.IGNORECASE
        ),
        # Variaciones de UNIDAD
        'unit_flexible': re.compile(
            r'(?:UNIDAD|UND|U)\s*[:\-]?\s*([A-Z]{1,10})',
            re.IGNORECASE
        ),
        # L√≠nea de descripci√≥n con ITEM y UNIDAD
        'header_full': re.compile(
            r'(?P<desc>.+?)\s+(?:UNIDAD|UND)\s*[:\-]?\s*(?P<unit>\S+)\s+(?:ITEM|C√ìDIGO)\s*[:\-]?\s*(?P<item>\S+)',
            re.IGNORECASE
        ),
        # Alternativa: ITEM primero
        'header_item_first': re.compile(
            r'(?:ITEM|C√ìDIGO)\s*[:\-]?\s*(?P<item>\S+).*?(?:DESCRIPCION|DESCRIPCI√ìN)\s*[:\-]?\s*(?P<desc>.+?)(?:\s+(?:UNIDAD|UND)\s*[:\-]?\s*(?P<unit>\S+))?',
            re.IGNORECASE
        ),
        # Detectar l√≠neas num√©ricas (posibles insumos)
        'numeric_row': re.compile(
            r'[\d.,]+\s+[\d.,]+\s+[\d.,]+'
        ),
        # Detectar encabezados de tabla
        'table_header': re.compile(
            r'^\s*(?:CODIGO|C√ìDIGO|DESCRIPCION|DESCRIPCI√ìN|UNIDAD|CANTIDAD|V\.?\s*UNITARIO|V\.?\s*TOTAL)\s*$',
            re.IGNORECASE
        ),
    }
    
    # Categor√≠as con variaciones
    CATEGORY_KEYWORDS = {
        'MATERIALES': {'MATERIALES', 'MATERIAL'},
        'MANO DE OBRA': {'MANO DE OBRA', 'MANO OBRA', 'M.O.', 'MO'},
        'EQUIPO': {'EQUIPO', 'EQUIPOS'},
        'TRANSPORTE': {'TRANSPORTE', 'TRANSPORTES'},
        'HERRAMIENTA': {'HERRAMIENTA', 'HERRAMIENTAS'},
        'OTROS': {'OTROS', 'OTRO'},
    }
    
    # L√≠neas que deben ignorarse
    JUNK_PATTERNS = [
        re.compile(r'^\s*SUBTOTAL', re.IGNORECASE),
        re.compile(r'^\s*COSTO\s+DIRECTO', re.IGNORECASE),
        re.compile(r'^\s*TOTAL', re.IGNORECASE),
        re.compile(r'^\s*IMPUESTO', re.IGNORECASE),
        re.compile(r'^\s*[-=]{3,}\s*$'),  # L√≠neas de separadores
        re.compile(r'^\s*[_]{3,}\s*$'),
    ]
    
    def __init__(
        self, 
        file_path: str,
        config: Optional[ParserConfig] = None
    ):
        self.file_path = Path(file_path)
        self.config = config or ParserConfig()
        
        # Validaci√≥n
        if not self.file_path.exists():
            raise FileNotFoundError(f"Archivo no encontrado: {self.file_path}")
        
        # Estado
        self.raw_records: List[Dict[str, str]] = []
        self.stats = Counter()
        self.debug_samples: List[Dict] = []
        self._detected_separator: Optional[str] = None
        
    def parse_to_raw(self) -> List[Dict[str, str]]:
        """
        Punto de entrada principal. Auto-detecta formato y aplica estrategia √≥ptima.
        """
        logger.info(f"üîç Iniciando parsing de: {self.file_path}")
        logger.info(f"üì¶ Tama√±o: {self.file_path.stat().st_size:,} bytes")
        
        # Leer archivo con encoding apropiado
        content = self._read_file()
        if not content:
            logger.error("‚ùå No se pudo leer el archivo")
            return []
        
        self.stats['file_size_bytes'] = len(content)
        self.stats['total_lines'] = content.count('\n')
        
        # Auto-detectar formato si es necesario
        if self.config.strategy == 'auto':
            self._auto_detect_format(content)
        
        # Aplicar estrategia de parsing
        if self.config.strategy == 'blocks' or self._should_use_blocks(content):
            logger.info("üìã Usando estrategia: BLOQUES")
            self._parse_by_blocks(content)
        else:
            logger.info("üìã Usando estrategia: L√çNEAS")
            self._parse_by_lines(content)
        
        # Logging de resultados
        self._log_statistics()
        
        if self.config.debug_mode:
            self._log_debug_samples()
        
        return self.raw_records
    
    def _read_file(self) -> str:
        """Lee el archivo intentando m√∫ltiples encodings."""
        for encoding in self.config.encodings:
            try:
                content = self.file_path.read_text(encoding=encoding)
                logger.info(f"‚úÖ Archivo le√≠do con encoding: {encoding}")
                self.stats['encoding_used'] = encoding
                return content
            except UnicodeDecodeError:
                logger.debug(f"Fall√≥ encoding {encoding}, intentando siguiente...")
                continue
            except Exception as e:
                logger.error(f"Error al leer con {encoding}: {e}")
                continue
        
        logger.error("‚ùå No se pudo leer el archivo con ning√∫n encoding")
        return ""
    
    def _auto_detect_format(self, content: str):
        """Auto-detecta el formato del archivo."""
        lines = content.split('\n')
        
        # Detectar separador de campos
        semicolon_count = sum(1 for line in lines[:100] if ';' in line)
        tab_count = sum(1 for line in lines[:100] if '\t' in line)
        
        if semicolon_count > 50:
            self._detected_separator = ';'
            logger.info("üìä Separador detectado: punto y coma (;)")
        elif tab_count > 50:
            self._detected_separator = '\t'
            logger.info("üìä Separador detectado: tabulaci√≥n")
        else:
            self._detected_separator = r'\s{2,}'  # M√∫ltiples espacios
            logger.info("üìä Separador detectado: espacios m√∫ltiples")
        
        self.stats['detected_separator'] = self._detected_separator
    
    def _should_use_blocks(self, content: str) -> bool:
        """Determina si usar estrategia de bloques."""
        # Contar bloques potenciales
        blocks = re.split(self.config.block_separator, content)
        valid_blocks = [b for b in blocks if b.strip()]
        
        # Si hay bloques bien definidos, usarlos
        if len(valid_blocks) > 5:
            logger.info(f"  Bloques detectados: {len(valid_blocks)}")
            return True
        
        return False
    
    def _parse_by_blocks(self, content: str):
        """Estrategia de parsing por bloques."""
        blocks = re.split(self.config.block_separator, content)
        valid_blocks = [b.strip() for b in blocks if b.strip()]
        
        logger.info(f"  Procesando {len(valid_blocks)} bloques...")
        
        for block_num, block in enumerate(valid_blocks, 1):
            self._process_block(block, block_num)
        
        self.stats['total_blocks_processed'] = len(valid_blocks)
    
    def _process_block(self, block: str, block_num: int):
        """Procesa un bloque individual de APU."""
        lines = [line.strip() for line in block.split('\n') if line.strip()]
        
        if not lines:
            self.stats['empty_blocks'] += 1
            return
        
        # Intentar extraer encabezado del APU
        apu_context = self._extract_apu_context(lines)
        
        if not apu_context:
            self.stats['blocks_without_header'] += 1
            
            if self.config.debug_mode and len(self.debug_samples) < self.config.max_debug_samples:
                self.debug_samples.append({
                    'type': 'block_no_header',
                    'block_num': block_num,
                    'first_lines': lines[:3],
                    'reason': 'No se pudo extraer encabezado APU'
                })
            
            logger.warning(
                f"Bloque #{block_num}: No se detect√≥ encabezado APU. "
                f"Primera l√≠nea: '{lines[0][:80]}...'"
            )
            return
        
        self.stats['valid_apu_blocks'] += 1
        logger.debug(
            f"Bloque #{block_num}: APU detectado -> {apu_context['apu_code']}"
        )
        
        # Procesar insumos del bloque
        self._extract_insumos_from_lines(lines, apu_context, block_num)
    
    def _extract_apu_context(self, lines: List[str]) -> Optional[Dict[str, str]]:
        """
        Extrae contexto del APU de las primeras l√≠neas del bloque.
        Intenta m√∫ltiples patrones.
        """
        # Buscar en las primeras 5 l√≠neas
        search_lines = lines[:min(5, len(lines))]
        
        for line in search_lines:
            # Patr√≥n 1: Descripci√≥n UNIDAD: xxx ITEM: xxx
            match = self.PATTERNS['header_full'].search(line)
            if match:
                data = match.groupdict()
                return {
                    'apu_code': clean_apu_code(data['item']),
                    'apu_desc': data['desc'].strip(),
                    'apu_unit': data['unit'].strip(),
                }
            
            # Patr√≥n 2: ITEM: xxx DESCRIPCION: xxx UNIDAD: xxx
            match = self.PATTERNS['header_item_first'].search(line)
            if match:
                data = match.groupdict()
                return {
                    'apu_code': clean_apu_code(data['item']),
                    'apu_desc': data.get('desc', '').strip(),
                    'apu_unit': data.get('unit', self.config.default_unit).strip(),
                }
        
        # Patr√≥n 3: Buscar ITEM e UNIDAD en l√≠neas separadas
        item_code = None
        unit = None
        desc = ""
        
        for line in search_lines:
            if not item_code:
                item_match = self.PATTERNS['item_flexible'].search(line)
                if item_match:
                    item_code = clean_apu_code(item_match.group(1))
            
            if not unit:
                unit_match = self.PATTERNS['unit_flexible'].search(line)
                if unit_match:
                    unit = unit_match.group(1).strip()
            
            # La primera l√≠nea sin palabras clave podr√≠a ser descripci√≥n
            if not desc and not self._is_junk_line(line):
                if not self.PATTERNS['table_header'].match(line):
                    if len(line) >= self.config.min_description_length:
                        desc = line.strip()
        
        if item_code:
            return {
                'apu_code': item_code,
                'apu_desc': desc or f"Descripci√≥n no encontrada para {item_code}",
                'apu_unit': unit or self.config.default_unit,
            }
        
        return None
    
    def _extract_insumos_from_lines(
        self, 
        lines: List[str], 
        apu_context: Dict[str, str],
        block_num: int
    ):
        """Extrae insumos de las l√≠neas de un bloque."""
        current_category = "INDEFINIDO"
        
        for line_num, line in enumerate(lines, 1):
            line_upper = line.upper()
            
            # Verificar si es categor√≠a
            detected_category = self._detect_category(line_upper)
            if detected_category:
                current_category = detected_category
                self.stats[f'category_{current_category}'] += 1
                continue
            
            # Verificar si es l√≠nea de ruido
            if self._is_junk_line(line):
                self.stats['junk_lines'] += 1
                continue
            
            # Verificar si es insumo v√°lido
            if self._is_valid_insumo(line):
                record = {
                    'apu_code': apu_context['apu_code'],
                    'apu_desc': apu_context['apu_desc'],
                    'apu_unit': apu_context['apu_unit'],
                    'category': current_category,
                    'insumo_line': line,
                }
                self.raw_records.append(record)
                self.stats['insumos_extracted'] += 1
                
                # Sample para debug
                if (self.config.debug_mode and 
                    len(self.debug_samples) < self.config.max_debug_samples):
                    self.debug_samples.append({
                        'type': 'insumo_extracted',
                        'block_num': block_num,
                        'line_num': line_num,
                        'category': current_category,
                        'line': line[:100]
                    })
    
    def _parse_by_lines(self, content: str):
        """Estrategia de parsing l√≠nea por l√≠nea (similar al original)."""
        lines = content.split('\n')
        
        logger.info(f"  Procesando {len(lines)} l√≠neas...")
        
        current_apu = None
        current_category = "INDEFINIDO"
        
        for line_num, line in enumerate(lines, 1):
            line_clean = line.strip()
            
            if not line_clean:
                self.stats['empty_lines'] += 1
                continue
            
            # Intentar detectar inicio de APU
            apu_context = self._extract_apu_context([line_clean])
            if apu_context:
                current_apu = apu_context
                current_category = "INDEFINIDO"
                self.stats['apus_detected'] += 1
                logger.debug(f"L√≠nea {line_num}: APU detectado -> {current_apu['apu_code']}")
                continue
            
            # Si no hay APU activo, continuar
            if not current_apu:
                self.stats['lines_before_first_apu'] += 1
                continue
            
            # Detectar categor√≠a
            detected_category = self._detect_category(line_clean.upper())
            if detected_category:
                current_category = detected_category
                self.stats[f'category_{current_category}'] += 1
                continue
            
            # Procesar como posible insumo
            if self._is_valid_insumo(line_clean):
                if not self._is_junk_line(line_clean):
                    record = {
                        'apu_code': current_apu['apu_code'],
                        'apu_desc': current_apu['apu_desc'],
                        'apu_unit': current_apu['apu_unit'],
                        'category': current_category,
                        'insumo_line': line_clean,
                    }
                    self.raw_records.append(record)
                    self.stats['insumos_extracted'] += 1
    
    def _detect_category(self, line_upper: str) -> Optional[str]:
        """Detecta si una l√≠nea es una categor√≠a."""
        # Solo considerar l√≠neas cortas
        if len(line_upper) > 100:
            return None
        
        # No debe contener m√∫ltiples separadores (probable insumo)
        if self._detected_separator:
            sep = self._detected_separator
            if sep in line_upper and line_upper.count(sep) > 1:
                return None
        
        # Buscar coincidencia con categor√≠as conocidas
        for canonical, variations in self.CATEGORY_KEYWORDS.items():
            for variation in variations:
                if variation in line_upper:
                    # Verificar que no sea parte de otra palabra
                    if re.search(rf'\b{re.escape(variation)}\b', line_upper):
                        return canonical
        
        return None
    
    def _is_junk_line(self, line: str) -> bool:
        """Determina si una l√≠nea debe ignorarse."""
        for pattern in self.JUNK_PATTERNS:
            if pattern.search(line):
                return True
        
        # Ignorar l√≠neas demasiado cortas
        if len(line.strip()) < 3:
            return True
        
        # Ignorar encabezados de tabla
        if self.PATTERNS['table_header'].match(line):
            return True
        
        return False
    
    def _is_valid_insumo(self, line: str) -> bool:
        """Determina si una l√≠nea es un insumo v√°lido."""
        # Debe tener contenido
        if not line or len(line) < 5:
            return False
        
        # Determinar separador a usar
        separator = self._detected_separator or ';'
        
        # Si el separador es regex, usar split con regex
        if separator.startswith('\\'):
            parts = re.split(separator, line)
        else:
            parts = line.split(separator)
        
        # Debe tener al menos 2 partes
        if len(parts) < 2:
            return False
        
        # Al menos una parte debe tener contenido significativo
        significant_parts = [p.strip() for p in parts if p.strip() and len(p.strip()) > 1]
        if len(significant_parts) < 2:
            return False
        
        # Alternativamente, si tiene n√∫meros, es probable insumo
        if self.PATTERNS['numeric_row'].search(line):
            return True
        
        return True
    
    def _log_statistics(self):
        """Registra estad√≠sticas del parsing."""
        logger.info("=" * 80)
        logger.info("üìä RESUMEN DE PARSING")
        logger.info("=" * 80)
        logger.info(f"Encoding usado: {self.stats.get('encoding_used', 'desconocido')}")
        logger.info(f"Separador detectado: {self.stats.get('detected_separator', 'desconocido')}")
        logger.info(f"Total de l√≠neas: {self.stats.get('total_lines', 0):,}")
        logger.info(f"L√≠neas vac√≠as: {self.stats.get('empty_lines', 0):,}")
        
        if 'total_blocks_processed' in self.stats:
            logger.info(f"\nBloques procesados: {self.stats['total_blocks_processed']}")
            logger.info(f"Bloques con APU v√°lido: {self.stats.get('valid_apu_blocks', 0)}")
            logger.info(f"Bloques sin encabezado: {self.stats.get('blocks_without_header', 0)}")
        
        if 'apus_detected' in self.stats:
            logger.info(f"\nAPUs detectados (l√≠nea por l√≠nea): {self.stats['apus_detected']}")
        
        logger.info(f"\n‚úÖ INSUMOS EXTRA√çDOS: {self.stats.get('insumos_extracted', 0)}")
        
        # Categor√≠as
        categories_found = [k for k in self.stats.keys() if k.startswith('category_')]
        if categories_found:
            logger.info("\nCategor√≠as detectadas:")
            for cat_key in categories_found:
                cat_name = cat_key.replace('category_', '')
                logger.info(f"  {cat_name}: {self.stats[cat_key]} veces")
        
        logger.info(f"\nL√≠neas ignoradas (ruido): {self.stats.get('junk_lines', 0)}")
        logger.info("=" * 80)
        
        # Advertencia si no se extrajo nada
        if self.stats.get('insumos_extracted', 0) == 0:
            logger.error("\n‚ùå ¬°ADVERTENCIA! No se extrajo ning√∫n insumo")
            logger.error("Posibles causas:")
            logger.error("  1. Formato de archivo no reconocido")
            logger.error("  2. Separadores no detectados correctamente")
            logger.error("  3. Encabezados APU en formato inesperado")
            logger.error("\nüí° Ejecuta el script de diagn√≥stico para m√°s informaci√≥n:")
            logger.error(f"   python scripts/diagnose_apus_file.py {self.file_path}")
    
    def _log_debug_samples(self):
        """Muestra samples de debug."""
        if not self.debug_samples:
            return
        
        logger.info("\n" + "=" * 80)
        logger.info("üêõ DEBUG SAMPLES")
        logger.info("=" * 80)
        
        for i, sample in enumerate(self.debug_samples, 1):
            logger.info(f"\nSample #{i}: {sample['type']}")
            for key, value in sample.items():
                if key != 'type':
                    logger.info(f"  {key}: {value}")
        
        logger.info("=" * 80)

Paso 3: Script de Testing

# scripts/test_parser.py

import sys
from pathlib import Path

# Agregar el directorio ra√≠z al path
sys.path.insert(0, str(Path(__file__).parent.parent))

from app.report_parser_crudo import ReportParserCrudo, ParserConfig
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(levelname)s - %(message)s'
)

def test_parser(file_path: str, debug: bool = True):
    """Prueba el parser con diferentes configuraciones."""
    
    print("\n" + "="*80)
    print("üß™ TESTING PARSER")
    print("="*80 + "\n")
    
    # Test 1: Auto-detecci√≥n
    print("üìã Test 1: Modo AUTO")
    config = ParserConfig(
        strategy='auto',
        debug_mode=debug
    )
    parser = ReportParserCrudo(file_path, config)
    records = parser.parse_to_raw()
    print(f"Resultado: {len(records)} registros extra√≠dos\n")
    
    # Test 2: Forzar bloques
    print("üìã Test 2: Modo BLOQUES")
    config = ParserConfig(
        strategy='blocks',
        debug_mode=debug
    )
    parser = ReportParserCrudo(file_path, config)
    records = parser.parse_to_raw()
    print(f"Resultado: {len(records)} registros extra√≠dos\n")
    
    # Test 3: Forzar l√≠neas
    print("üìã Test 3: Modo L√çNEAS")
    config = ParserConfig(
        strategy='lines',
        debug_mode=debug
    )
    parser = ReportParserCrudo(file_path, config)
    records = parser.parse_to_raw()
    print(f"Resultado: {len(records)} registros extra√≠dos\n")
    
    # Mostrar muestra de registros si se extrajeron
    if records:
        print("\nüìù Muestra de primeros 3 registros:")
        for i, record in enumerate(records[:3], 1):
            print(f"\nRegistro #{i}:")
            for key, value in record.items():
                print(f"  {key}: {value[:100] if isinstance(value, str) else value}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Uso: python test_parser.py <ruta_archivo>")
        sys.exit(1)
    
    test_parser(sys.argv[1])