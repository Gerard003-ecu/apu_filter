### 1. Mejora Cr칤tica: CapitalAssetPricing.sensitivity_analysis
# Este m칠todo ahora es side-effect free (sin efectos secundarios), lo cual es una mejor pr치ctica fundamental.

def sensitivity_analysis(
    self, parameter: str, range_values: List[float]
) -> Dict[float, float]:
    """
    Realiza un an치lisis de sensibilidad del WACC respecto a un par치metro,
    sin mutar el objeto de configuraci칩n original.

    Args:
        parameter: Nombre del par치metro a variar (ej. 'beta').
        range_values: Lista de valores a probar.

    Returns:
        Dict[float, float]: Mapeo de valor par치metro -> WACC resultante.
    """
    if not hasattr(self.config, parameter):
        raise ValueError(f"Par치metro desconocido: {parameter}")

    results = {}
    original_value = getattr(self.config, parameter)

    try:
        for val in range_values:
            # Crear un objeto de configuraci칩n temporal es m치s seguro que mutar el original
            # Si FinancialConfig fuera inmutable (dataclass(frozen=True)), esto ser칤a trivial.
            # Para mantener compatibilidad, hacemos un truco de "deep copy" simple.
            import copy
            temp_config = copy.deepcopy(self.config)
            setattr(temp_config, parameter, val)
            
            # Calcular WACC sobre la copia. Los caches lru_cache no se rompen.
            temp_capm = CapitalAssetPricing(temp_config)
            results[val] = temp_capm.calculate_wacc()
            
    except Exception as e:
        logger.error(f"Error en an치lisis de sensibilidad: {e}")
        raise

    return results


### 2. Correcci칩n Fundamental: RealOptionsAnalyzer._binomial_valuation_

def _binomial_valuation(
    self,
    S: float,
    K: float,
    r: float,
    T: float,
    sigma: float,
    n: int,
    american: bool = True,
) -> Dict[str, float]:
    """
    Implementaci칩n robusta del modelo Binomial CRR.

    Calcula correctamente el valor de la opci칩n, el delta y rastrea
    los nodos de ejercicio anticipado para an치lisis posterior.
    """
    dt = T / n
    u = exp(sigma * sqrt(dt))
    d = 1 / u
    p = (exp(r * dt) - d) / (u - d)

    # Validaci칩n robusta
    if not (0 < p < 1):
        logger.warning(f"Probabilidad 'p' fuera de rango ({p:.2f}). Ajustando modelo.")
        return {"option_value": 0.0, "error": "Invalid probability", "delta": 0.0}

    # Inicializaci칩n de estructuras para almacenar el 치rbol completo
    # prices[i][j]: precio subyacente en el paso i, nodo j
    # option_values[i][j]: valor de la opci칩n en el paso i, nodo j
    prices = [[0.0] * (i + 1) for i in range(n + 1)]
    option_values = [[0.0] * (i + 1) for i in range(n + 1)]

    # 1. Calcular todos los precios subyacentes
    prices[0][0] = S
    for i in range(1, n + 1):
        prices[i][0] = prices[i - 1][0] * d  # Rama baja
        for j in range(1, i + 1):
            prices[i][j] = prices[i][j - 1] * (u / d)  # Rama alta

    # 2. Calcular valores de opci칩n en el tiempo final (t=T)
    for j in range(n + 1):
        option_values[n][j] = max(prices[n][j] - K, 0)

    # 3. Inducci칩n hacia atr치s
    discount = exp(-r * dt)
    early_exercise_count = 0

    # Guardamos valores para delta
    option_value_up = None
    option_value_down = None

    for i in range(n - 1, -1, -1):
        for j in range(i + 1):
            # Valor de continuaci칩n
            continuation = discount * (p * option_values[i + 1][j + 1] + (1 - p) * option_values[i + 1][j])

            if american:
                s_node = prices[i][j]
                intrinsic = max(s_node - K, 0)
                if intrinsic > continuation + 1e-12:  # Epsilon para float comparison
                    option_values[i][j] = intrinsic
                    early_exercise_count += 1
                else:
                    option_values[i][j] = continuation
            else:
                option_values[i][j] = continuation
            
            # Guardar valores de t=1 para calcular delta
            if i == 1:
                if j == 0:
                    option_value_down = option_values[1][0]
                elif j == 1:
                    option_value_up = option_values[1][1]
    
    # 4. Calcular Delta de manera precisa
    delta = 0.0
    if option_value_up is not None and option_value_down is not None:
        s_up = prices[1][1]
        s_down = prices[1][0]
        delta = (option_value_up - option_value_down) / (s_up - s_down)

    # Clamping delta a [0, 1] para opciones call est치ndar
    delta = max(0.0, min(1.0, delta))

    option_value = option_values[0][0]
    intrinsic_value = max(S - K, 0)

    return {
        "option_value": option_value,
        "model": f"Binomial CRR ({'Americana' if american else 'Europea'})",
        "intrinsic_value": intrinsic_value,
        "time_value": max(0, option_value - intrinsic_value),
        "early_exercise_nodes": early_exercise_count,
        "delta": delta,
    }


### 3. Optimizaci칩n de la F칤sica Unificada: FinancialEngine._calculate_thermo_structural_volatility_

def _calculate_thermo_structural_volatility(
    self,
    base_volatility: float,
    stability_psi: float,
    system_temperature: float,
) -> Tuple[float, Dict[str, float]]:
    """
    Implementa la Ecuaci칩n Unificada de F칤sica del Costo.
    Returns a tuple of (unified_volatility, breakdown_dict).

    Args:
        base_volatility (픢): Volatilidad est치ndar del mercado (ej. 0.20).
        stability_psi (풛): 칈ndice de estabilidad piramidal (Topolog칤a).
        system_temperature (T): Temperatura del sistema en 춿C (Termodin치mica).

    Returns:
        Tuple[float, Dict[str, float]]: Volatilidad ajustada y desglose de factores.
    """
    # 1. Factor de Pir치mide Invertida (Topolog칤a)
    structural_factor = 0.0
    if stability_psi < 1.0:
        structural_factor = (1.0 - stability_psi) * 2.0
    elif stability_psi < 1.5:
        structural_factor = (1.5 - stability_psi) * 0.5

    # 2. Factor de Estr칠s T칠rmico (Termodin치mica)
    thermal_factor = 0.0
    if system_temperature > 30.0:
        thermal_factor = (system_temperature - 30.0) * 0.005

    # 3. C치lculo final
    unified_volatility = base_volatility * (1.0 + structural_factor + thermal_factor)

    # Devolver el desglose para fines de diagn칩stico
    breakdown = {
        "structural_factor": structural_factor,
        "thermal_factor": thermal_factor,
    }

    # Logging mejorado
    if structural_factor > 0 or thermal_factor > 0:
        logger.warning(
            f"游댠 F칤sica del Costo Activada: Volatilidad Base ({base_volatility:.2%}) "
            f"-> Ajustada ({unified_volatility:.2%}). "
            f"Desglose: Fragilidad Estructural (+{structural_factor:.2%}), "
            f"Estr칠s T칠rmico (+{thermal_factor:.2%})"
        )

    return unified_volatility, breakdown


### 4. Integraci칩n Refinada: FinancialEngine.analyze_project

# (Esta es la porci칩n refinada de `analyze_project` que hace uso del nuevo m칠todo)

        effective_volatility = vol
        thermodynamics_breakdown = {"structural_factor": 0.0, "thermal_factor": 0.0}

        # 1. Aplicar la Ecuaci칩n Unificada si hay datos topol칩gicos
        if pyramid_stability is not None:
            temp = system_temperature if system_temperature is not None else 25.0
            effective_volatility, thermodynamics_breakdown = self._calculate_thermo_structural_volatility(
                vol, pyramid_stability, temp
            )
        elif topology_report and topology_report.get("synergy_risk", {}).get("synergy_detected", False):
            penalty = 1.2
            effective_volatility *= penalty
            thermodynamics_breakdown["synergy_penalty"] = penalty - 1.0
            logger.warning(
                f"Sinergia Topol칩gica detectada. Volatilidad ajustada: {vol:.2%} -> {effective_volatility:.2%}"
            )

        # ... (resto del m칠todo sigue igual, pero ahora con access a thermodynamics_breakdown)

        return {
            # ... (otras claves)
            "volatility_base": vol,
            "volatility_structural": effective_volatility,
            "volatility": effective_volatility,
            "physics_adjustment": effective_volatility > vol,
            "thermodynamics": {
                "financial_inertia": inertia,
                "liquidity_ratio": liq,
                "fixed_contracts_ratio": fcr,
                "breakdown": thermodynamics_breakdown, # 춰Nuevo! Muy 칰til para el Consejo.
            },
        }

