"""
Procesador APU con gramática no ambigua y parser robusto.
Versión final con conflictos de gramática resueltos.
"""
import re
import logging
from typing import List, Optional, Dict, Any
from enum import Enum
from functools import lru_cache
from lark import Lark, Transformer, v_args, Token
from .utils import normalize_text, parse_number
from .schemas import (
    ManoDeObra, Equipo, Transporte, 
    Suministro, InsumoProcesado, OtroInsumo
)

logger = logging.getLogger(__name__)


class TipoInsumo(Enum):
    """Enumeración de tipos de insumo válidos."""
    MANO_DE_OBRA = "MANO_DE_OBRA"
    EQUIPO = "EQUIPO"
    TRANSPORTE = "TRANSPORTE"
    SUMINISTRO = "SUMINISTRO"
    OTRO = "OTRO"


class FormatoLinea(Enum):
    """Enumeración de formatos de línea detectados."""
    MO_COMPLETA = "MO_COMPLETA"
    INSUMO_BASICO = "INSUMO_BASICO"
    DESCONOCIDO = "DESCONOCIDO"


# ============================================================================
# GRAMÁTICA NO AMBIGUA - SOLUCIÓN DEFINITIVA
# ============================================================================

APU_GRAMMAR = r"""
    ?start: lines
    
    // Un documento es una secuencia de líneas
    lines: line+
    
    // CAMBIO CRÍTICO: Una línea DEBE tener al menos un campo
    // Esto elimina la ambigüedad que causaba los conflictos Reduce/Reduce
    line: field (SEP field)* NEWLINE?
    
    // Un campo puede estar vacío (para manejar ;;)
    field: FIELD_VALUE?
    
    // Contenido del campo: cualquier cosa excepto separadores
    FIELD_VALUE: /[^;\r\n\t]+/
    
    // Separador con espacios opcionales
    SEP: /\s*;\s*/
    
    // Nueva línea
    NEWLINE: /[\r\n]+/
    
    // Importar y ignorar espacios en blanco generales
    %import common.WS
    %ignore WS
"""

# Versión alternativa más simple si la anterior aún da problemas
APU_GRAMMAR_SIMPLE = r"""
    ?start: lines
    
    lines: line*
    
    // Línea no vacía con al menos un campo
    line: fields NEWLINE
    
    // Lista de campos separados por punto y coma
    fields: field (";" field)*
    
    // Campo que puede estar vacío
    field: /[^;\r\n]*/
    
    // Nueva línea explícita
    NEWLINE: /\r?\n/
"""


# ============================================================================
# TRANSFORMER OPTIMIZADO PARA LA NUEVA GRAMÁTICA
# ============================================================================

@v_args(inline=False)  # Cambiado a False para manejar mejor las listas
class APUTransformer(Transformer):
    """
    Transformador optimizado para la gramática no ambigua.
    """
    
    # Constantes de ruido
    NOISE_KEYWORDS = [
        "SUBTOTAL", "TOTAL", "COSTO DIRECTO", "COSTO INDIRECTO",
        "RESUMEN", "TOTALES", "ACUMULADO", "SUMA", "GRAN TOTAL"
    ]
    
    HEADER_KEYWORDS = [
        "DESCRIPCION", "DESCRIPCIÓN", "UND", "UNIDAD", 
        "CANT", "CANTIDAD", "PRECIO", "VALOR", "DESP", 
        "RENDIMIENTO", "JORNAL", "CODIGO", "ITEM"
    ]
    
    CATEGORY_KEYWORDS = [
        "MATERIALES", "EQUIPO", "EQUIPOS", "TRANSPORTE",
        "MANO DE OBRA", "HERRAMIENTAS", "OTROS", "SERVICIOS"
    ]

    def __init__(self, apu_context: Dict[str, Any], config: Dict[str, Any], keyword_cache: Any):
        self.apu_context = apu_context or {}
        self.config = config or {}
        self.keyword_cache = keyword_cache
        self.thresholds = self._load_validation_thresholds()
        self.processed_items = []  # Almacenar items procesados
        super().__init__()

    def _load_validation_thresholds(self) -> Dict[str, Any]:
        """Carga los umbrales de validación."""
        mo_config = self.config.get("validation_thresholds", {}).get("MANO_DE_OBRA", {})
        return {
            "min_jornal": mo_config.get("min_jornal", 50000),
            "max_jornal": mo_config.get("max_jornal", 10000000),
            "min_rendimiento": mo_config.get("min_rendimiento", 0.001),
            "max_rendimiento": mo_config.get("max_rendimiento", 1000),
            "min_cantidad": 0.001,
            "max_cantidad": 1000000,
            "min_precio": 0.01,
            "max_precio": 1e9
        }

    def _extract_value(self, item) -> str:
        """Extrae el valor de string de un token o string."""
        if item is None:
            return ""
        if isinstance(item, Token):
            return str(item.value).strip()
        if isinstance(item, str):
            return item.strip()
        return str(item).strip()

    # ============================================================================
    # MÉTODOS DE TRANSFORMACIÓN PARA LA NUEVA GRAMÁTICA
    # ============================================================================

    def lines(self, items):
        """Procesa todas las líneas del documento."""
        result = []
        for item in items:
            if item is not None:
                result.append(item)
        return result

    def line(self, args):
        """Procesa una línea individual con la nueva estructura."""
        # args contendrá los campos de la línea
        fields = []
        
        for arg in args:
            if isinstance(arg, list):
                # Si es una lista (de field), procesarla
                fields.extend(arg)
            elif arg is not None and not isinstance(arg, Token):
                # Si es un campo procesado, agregarlo
                fields.append(arg)
        
        # Limpiar campos
        clean_fields = [self._extract_value(f) for f in fields if f is not None]
        clean_fields = self._filter_trailing_empty(clean_fields)
        
        if not clean_fields or not clean_fields[0]:
            return None
        
        # Detectar y procesar formato
        formato = self._detect_format(clean_fields)
        
        if formato == FormatoLinea.DESCONOCIDO:
            return None
        
        return self._dispatch_builder(formato, clean_fields)

    def field(self, args):
        """Procesa un campo individual."""
        if not args:
            return ""
        # Si hay un FIELD_VALUE, retornarlo
        return self._extract_value(args[0]) if args else ""

    def fields(self, args):
        """Procesa una lista de campos (para gramática alternativa)."""
        return [self._extract_value(arg) for arg in args]

    # ============================================================================
    # MÉTODOS DE PROCESAMIENTO (sin cambios de la versión anterior)
    # ============================================================================

    def _filter_trailing_empty(self, tokens: List[str]) -> List[str]:
        """Elimina campos vacíos al final."""
        if not tokens:
            return []
        
        last_idx = -1
        for i in range(len(tokens) - 1, -1, -1):
            if tokens[i]:
                last_idx = i
                break
        
        return tokens[:last_idx + 1] if last_idx >= 0 else []

    def _dispatch_builder(self, formato: FormatoLinea, tokens: List[str]) -> Optional[InsumoProcesado]:
        """Despacha al constructor apropiado."""
        try:
            if formato == FormatoLinea.MO_COMPLETA:
                return self._build_mo_completa(tokens)
            elif formato == FormatoLinea.INSUMO_BASICO:
                return self._build_insumo_basico(tokens)
            return None
        except Exception as e:
            logger.error(f"Error construyendo {formato.value}: {e}")
            return None

    def _detect_format(self, fields: List[str]) -> FormatoLinea:
        """Detecta el formato con filtro de ruido mejorado."""
        if not fields or not fields[0]:
            return FormatoLinea.DESCONOCIDO

        descripcion = fields[0].strip().upper()
        num_fields = len(fields)

        # Filtro de ruido
        if any(keyword in descripcion for keyword in self.NOISE_KEYWORDS):
            logger.debug(f"Línea de resumen ignorada: {fields[0][:30]}...")
            return FormatoLinea.DESCONOCIDO
        
        header_count = sum(1 for kw in self.HEADER_KEYWORDS if kw in descripcion)
        if header_count >= 2:
            logger.debug(f"Línea de encabezado ignorada: {fields[0][:30]}...")
            return FormatoLinea.DESCONOCIDO
        
        if num_fields <= 2 and any(cat in descripcion for cat in self.CATEGORY_KEYWORDS):
            logger.debug(f"Línea de categoría ignorada: {fields[0]}")
            return FormatoLinea.DESCONOCIDO
        
        if num_fields < 3:
            return FormatoLinea.DESCONOCIDO

        # Clasificación de formato
        tipo_probable = self._classify_insumo(fields[0])
        
        if num_fields >= 5 and tipo_probable == TipoInsumo.MANO_DE_OBRA:
            if self._validate_mo_format(fields):
                logger.debug(f"MO_COMPLETA detectado: {fields[0][:30]}...")
                return FormatoLinea.MO_COMPLETA
        
        if num_fields >= 4:
            logger.debug(f"INSUMO_BASICO detectado: {fields[0][:30]}...")
            return FormatoLinea.INSUMO_BASICO

        return FormatoLinea.DESCONOCIDO

    def _validate_mo_format(self, fields: List[str]) -> bool:
        """Valida formato MO con búsqueda flexible."""
        if len(fields) < 5:
            return False

        try:
            numeric_values = []
            for i in range(2, len(fields)):
                val = self._safe_parse_number(fields[i])
                if val is not None and val > 0:
                    numeric_values.append((i, val))
            
            if len(numeric_values) < 2:
                return False
            
            jornal_found = False
            rendimiento_found = False
            
            for idx, val in numeric_values:
                if self.thresholds["min_jornal"] <= val <= self.thresholds["max_jornal"]:
                    jornal_found = True
                if self.thresholds["min_rendimiento"] <= val <= self.thresholds["max_rendimiento"] and val < 100:
                    rendimiento_found = True
            
            return jornal_found and rendimiento_found
            
        except Exception as e:
            logger.debug(f"Error validando MO: {e}")
            return False

    def _build_mo_completa(self, tokens: List[str]) -> Optional[ManoDeObra]:
        """Construye objeto ManoDeObra."""
        try:
            descripcion = tokens[0]
            unidad = tokens[1] if len(tokens) > 1 else "JOR"
            
            jornal = None
            rendimiento = None
            
            numeric_values = []
            for i in range(2, len(tokens)):
                val = self._safe_parse_number(tokens[i])
                if val is not None and val > 0:
                    numeric_values.append((i, val))
            
            for idx, val in numeric_values:
                if jornal is None and self.thresholds["min_jornal"] <= val <= self.thresholds["max_jornal"]:
                    jornal = val
                elif rendimiento is None and self.thresholds["min_rendimiento"] <= val <= 100:
                    rendimiento = val
            
            if jornal is None or rendimiento is None or rendimiento <= 0:
                return None
            
            cantidad = 1.0 / rendimiento
            valor_total = cantidad * jornal
            
            if cantidad <= 0 or valor_total <= 0:
                return None
            
            return ManoDeObra(
                descripcion_insumo=descripcion,
                unidad_insumo=unidad,
                cantidad=round(cantidad, 6),
                precio_unitario=round(jornal, 2),
                valor_total=round(valor_total, 2),
                rendimiento=round(rendimiento, 6),
                formato_origen="MO_COMPLETA",
                tipo_insumo="MANO_DE_OBRA",
                normalized_desc=normalize_text(descripcion),
                **self.apu_context
            )
            
        except Exception as e:
            logger.error(f"Error construyendo MO_COMPLETA: {e}")
            return None

    def _build_insumo_basico(self, tokens: List[str]) -> Optional[InsumoProcesado]:
        """Construye insumo básico."""
        try:
            if len(tokens) < 4:
                return None
            
            descripcion = tokens[0]
            unidad = tokens[1] if len(tokens) > 1 else "UND"
            
            cantidad = None
            precio_unitario = None
            valor_total = None
            
            numeric_values = []
            for i in range(2, len(tokens)):
                if '%' not in tokens[i]:
                    val = self._safe_parse_number(tokens[i])
                    if val is not None and val >= 0:
                        numeric_values.append(val)
            
            if len(numeric_values) >= 3:
                cantidad = numeric_values[0]
                precio_unitario = numeric_values[1]
                valor_total = numeric_values[2]
            elif len(numeric_values) == 2:
                cantidad = numeric_values[0]
                valor_total = numeric_values[1]
                if cantidad > 0:
                    precio_unitario = valor_total / cantidad
            elif len(numeric_values) == 1:
                cantidad = 1.0
                precio_unitario = numeric_values[0]
                valor_total = precio_unitario
            else:
                return None
            
            if cantidad is None or cantidad <= 0:
                cantidad = 1.0
            
            if precio_unitario is None or precio_unitario < 0:
                if valor_total and valor_total > 0 and cantidad > 0:
                    precio_unitario = valor_total / cantidad
                else:
                    return None
            
            if valor_total is None or valor_total <= 0:
                if cantidad > 0 and precio_unitario > 0:
                    valor_total = cantidad * precio_unitario
                else:
                    return None
            
            tipo_insumo = self._classify_insumo(descripcion)
            InsumoClass = self._get_insumo_class(tipo_insumo)
            
            return InsumoClass(
                descripcion_insumo=descripcion,
                unidad_insumo=unidad,
                cantidad=round(cantidad, 6),
                precio_unitario=round(precio_unitario, 2),
                valor_total=round(valor_total, 2),
                rendimiento=round(cantidad, 6),
                formato_origen="INSUMO_BASICO",
                tipo_insumo=tipo_insumo.value,
                normalized_desc=normalize_text(descripcion),
                **self.apu_context
            )
            
        except Exception as e:
            logger.error(f"Error construyendo INSUMO_BASICO: {e}")
            return None

    def _safe_parse_number(self, value: str) -> Optional[float]:
        """Parseo seguro de números."""
        if not value or not isinstance(value, str):
            return None
        
        try:
            clean_value = value.strip()
            if ',' in clean_value and '.' not in clean_value:
                return parse_number(clean_value, decimal_separator="comma")
            else:
                return parse_number(clean_value, decimal_separator="dot")
        except:
            return None

    @lru_cache(maxsize=2048)
    def _classify_insumo(self, descripcion: str) -> TipoInsumo:
        """Clasifica tipo de insumo."""
        if not descripcion:
            return TipoInsumo.OTRO
        
        desc_upper = descripcion.upper()
        
        special_cases = {
            "HERRAMIENTA MENOR": TipoInsumo.EQUIPO,
            "HERRAMIENTA (% MO)": TipoInsumo.EQUIPO,
            "EQUIPO Y HERRAMIENTA": TipoInsumo.EQUIPO,
            "MANO DE OBRA": TipoInsumo.MANO_DE_OBRA,
            "MANO OBRA": TipoInsumo.MANO_DE_OBRA,
            "MO ": TipoInsumo.MANO_DE_OBRA,
        }
        
        for case, tipo in special_cases.items():
            if case in desc_upper:
                return tipo
        
        if self.keyword_cache:
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'mo_keywords', [])):
                return TipoInsumo.MANO_DE_OBRA
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'equipo_keywords', [])):
                return TipoInsumo.EQUIPO
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'transporte_keywords', [])):
                return TipoInsumo.TRANSPORTE
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'suministro_keywords', [])):
                return TipoInsumo.SUMINISTRO
        
        return TipoInsumo.OTRO

    def _get_insumo_class(self, tipo_insumo: TipoInsumo):
        """Obtiene la clase apropiada para el tipo."""
        class_mapping = {
            TipoInsumo.MANO_DE_OBRA: ManoDeObra,
            TipoInsumo.EQUIPO: Equipo,
            TipoInsumo.TRANSPORTE: Transporte,
            TipoInsumo.SUMINISTRO: Suministro,
            TipoInsumo.OTRO: OtroInsumo
        }
        return class_mapping.get(tipo_insumo, OtroInsumo)


# ============================================================================
# CLASE PRINCIPAL DEL PROCESADOR
# ============================================================================

class APUProcessor:
    """
    Procesador principal con la gramática corregida.
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.keyword_cache = self._load_keyword_cache()
        self.parser = self._create_parser()
    
    def _load_keyword_cache(self):
        """Carga el cache de palabras clave."""
        # Implementar según tu lógica actual
        return None
    
    def _create_parser(self):
        """Crea el parser Lark con la gramática no ambigua."""
        try:
            return Lark(
                APU_GRAMMAR,
                parser='lalr',  # LALR es más estricto y detecta ambigüedades
                transformer=None,  # Lo aplicamos después
                debug=True  # Activar para debugging
            )
        except Exception as e:
            logger.warning(f"Error con gramática principal, usando alternativa: {e}")
            # Si hay problemas, usar la gramática simplificada
            return Lark(
                APU_GRAMMAR_SIMPLE,
                parser='lalr',
                transformer=None,
                debug=True
            )
    
    def process_line(self, line: str, apu_context: Dict[str, Any] = None) -> Optional[InsumoProcesado]:
        """Procesa una línea individual."""
        if not line or not line.strip():
            return None
        
        try:
            # Parsear la línea
            tree = self.parser.parse(line)
            
            # Aplicar el transformer
            transformer = APUTransformer(
                apu_context or {},
                self.config,
                self.keyword_cache
            )
            
            result = transformer.transform(tree)
            
            # El resultado puede ser una lista si hay múltiples líneas
            if isinstance(result, list) and result:
                return result[0]
            return result
            
        except Exception as e:
            logger.debug(f"Error procesando línea: {e}")
            return None
    
    def process_lines(self, lines: List[str], apu_context: Dict[str, Any] = None) -> List[InsumoProcesado]:
        """Procesa múltiples líneas."""
        results = []
        for line in lines:
            result = self.process_line(line, apu_context)
            if result:
                results.append(result)
        return results