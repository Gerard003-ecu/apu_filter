"""
Procesador APU con gramática no ambigua y parser robusto.
Versión refinada con mejoras de robustez.
"""
import re
import logging
from typing import List, Optional, Dict, Any, Tuple
from enum import Enum
from functools import lru_cache
from lark import Lark, Transformer, v_args, Token
from lark.exceptions import LarkError, ParseError
from .utils import normalize_text, parse_number
from .schemas import (
    ManoDeObra, Equipo, Transporte, 
    Suministro, InsumoProcesado, OtroInsumo
)

logger = logging.getLogger(__name__)


class TipoInsumo(Enum):
    """Enumeración de tipos de insumo válidos."""
    MANO_DE_OBRA = "MANO_DE_OBRA"
    EQUIPO = "EQUIPO"
    TRANSPORTE = "TRANSPORTE"
    SUMINISTRO = "SUMINISTRO"
    OTRO = "OTRO"


class FormatoLinea(Enum):
    """Enumeración de formatos de línea detectados."""
    MO_COMPLETA = "MO_COMPLETA"
    INSUMO_BASICO = "INSUMO_BASICO"
    DESCONOCIDO = "DESCONOCIDO"


# ============================================================================
# GRAMÁTICA SIMPLIFICADA PARA LÍNEA INDIVIDUAL
# ============================================================================

# MEJORA 1: Usar solo gramática simple para líneas individuales
APU_GRAMMAR = r"""
    ?start: line
    
    // Una línea es una secuencia de campos separados por punto y coma
    line: field (SEP field)*
    
    // Un campo puede estar vacío
    field: FIELD_VALUE?
    
    // Contenido del campo: cualquier cosa excepto separadores
    FIELD_VALUE: /[^;\r\n\t]+/
    
    // Separador con espacios opcionales
    SEP: /\s*;\s*/
    
    // Ignorar espacios en blanco al inicio y final
    %import common.WS
    %ignore WS
"""


# ============================================================================
# TRANSFORMER OPTIMIZADO
# ============================================================================

@v_args(inline=False)
class APUTransformer(Transformer):
    """
    Transformador optimizado con mejoras de robustez.
    """
    
    # MEJORA 2: Constantes centralizadas para fácil configuración
    # Umbrales típicos para rendimiento
    MAX_RENDIMIENTO_TIPICO = 100
    
    # Palabras clave de ruido
    NOISE_KEYWORDS = [
        "SUBTOTAL", "TOTAL", "COSTO DIRECTO", "COSTO INDIRECTO",
        "RESUMEN", "TOTALES", "ACUMULADO", "SUMA", "GRAN TOTAL",
        "SUB TOTAL", "SUB-TOTAL"  # MEJORA: Variaciones comunes
    ]
    
    HEADER_KEYWORDS = [
        "DESCRIPCION", "DESCRIPCIÓN", "DESC", "UND", "UNIDAD", 
        "CANT", "CANTIDAD", "PRECIO", "VALOR", "DESP", "DESPERDICIO",
        "RENDIMIENTO", "REND", "JORNAL", "JORN", "CODIGO", "COD", "ITEM"
    ]
    
    CATEGORY_KEYWORDS = [
        "MATERIALES", "MATERIAL", "EQUIPO", "EQUIPOS", "TRANSPORTE",
        "MANO DE OBRA", "HERRAMIENTAS", "HERRAMIENTA", "OTROS", "SERVICIOS"
    ]

    def __init__(self, apu_context: Dict[str, Any], config: Dict[str, Any], keyword_cache: Any):
        self.apu_context = apu_context or {}
        self.config = config or {}
        self.keyword_cache = keyword_cache
        self.thresholds = self._load_validation_thresholds()
        super().__init__()

    def _load_validation_thresholds(self) -> Dict[str, Any]:
        """Carga los umbrales de validación con valores por defecto robustos."""
        mo_config = self.config.get("validation_thresholds", {}).get("MANO_DE_OBRA", {})
        return {
            "min_jornal": mo_config.get("min_jornal", 50000),
            "max_jornal": mo_config.get("max_jornal", 10000000),
            "min_rendimiento": mo_config.get("min_rendimiento", 0.001),
            "max_rendimiento": mo_config.get("max_rendimiento", 1000),
            "max_rendimiento_tipico": mo_config.get("max_rendimiento_tipico", self.MAX_RENDIMIENTO_TIPICO),
            "min_cantidad": 0.001,
            "max_cantidad": 1000000,
            "min_precio": 0.01,
            "max_precio": 1e9
        }

    def _extract_value(self, item) -> str:
        """Extrae el valor de string de un token o string con manejo robusto."""
        if item is None:
            return ""
        
        # MEJORA 3: Manejo más robusto de tipos
        if isinstance(item, Token):
            return str(item.value).strip() if item.value else ""
        if isinstance(item, (str, bytes)):
            value = item.decode('utf-8') if isinstance(item, bytes) else item
            return value.strip()
        
        # Intentar convertir a string cualquier otro tipo
        try:
            return str(item).strip()
        except:
            return ""

    # ============================================================================
    # MÉTODO DE TRANSFORMACIÓN PRINCIPAL
    # ============================================================================

    def line(self, args):
        """Procesa una línea individual."""
        # Extraer todos los campos
        fields = []
        
        for arg in args:
            if isinstance(arg, list):
                fields.extend([self._extract_value(f) for f in arg])
            else:
                fields.append(self._extract_value(arg))
        
        # Filtrar y limpiar
        clean_fields = self._filter_trailing_empty(fields)
        
        if not clean_fields or not clean_fields[0]:
            return None
        
        # MEJORA 4: Logging más informativo
        logger.debug(f"Procesando línea con {len(clean_fields)} campos: {clean_fields[0][:30]}...")
        
        # Detectar y procesar formato
        formato = self._detect_format(clean_fields)
        
        if formato == FormatoLinea.DESCONOCIDO:
            logger.debug(f"Formato desconocido, campos: {clean_fields}")
            return None
        
        return self._dispatch_builder(formato, clean_fields)

    def field(self, args):
        """Procesa un campo individual."""
        if not args:
            return ""
        return self._extract_value(args[0]) if args else ""

    # ============================================================================
    # MÉTODOS DE PROCESAMIENTO MEJORADOS
    # ============================================================================

    def _filter_trailing_empty(self, tokens: List[str]) -> List[str]:
        """Elimina campos vacíos al final preservando campos vacíos intermedios."""
        if not tokens:
            return []
        
        # MEJORA 5: Preservar campos vacíos intermedios (importante para formatos con campos opcionales)
        last_non_empty = -1
        for i in range(len(tokens) - 1, -1, -1):
            if tokens[i]:
                last_non_empty = i
                break
        
        if last_non_empty == -1:
            return []
        
        return tokens[:last_non_empty + 1]

    def _dispatch_builder(self, formato: FormatoLinea, tokens: List[str]) -> Optional[InsumoProcesado]:
        """Despacha al constructor apropiado con mejor manejo de errores."""
        try:
            if formato == FormatoLinea.MO_COMPLETA:
                result = self._build_mo_completa(tokens)
                if result:
                    logger.info(f"MO construida: {tokens[0][:30]}...")
                return result
            elif formato == FormatoLinea.INSUMO_BASICO:
                result = self._build_insumo_basico(tokens)
                if result:
                    logger.info(f"Insumo construido: {tokens[0][:30]}...")
                return result
        except Exception as e:
            logger.error(f"Error construyendo {formato.value}: {e}", exc_info=True)
        
        return None

    def _detect_format(self, fields: List[str]) -> FormatoLinea:
        """Detecta el formato con lógica mejorada."""
        if not fields or not fields[0]:
            return FormatoLinea.DESCONOCIDO

        descripcion = fields[0].strip()
        descripcion_upper = descripcion.upper()
        num_fields = len(fields)

        # MEJORA 6: Filtro de ruido más inteligente
        # Verificar primero si es ruido obvio
        if self._is_noise_line(descripcion_upper, num_fields):
            return FormatoLinea.DESCONOCIDO
        
        # Validación mínima de campos
        if num_fields < 3:
            return FormatoLinea.DESCONOCIDO

        # Clasificación de formato
        tipo_probable = self._classify_insumo(descripcion)
        
        # MEJORA 7: Lógica de detección más flexible
        # Intentar MO_COMPLETA si parece mano de obra y tiene suficientes campos
        if tipo_probable == TipoInsumo.MANO_DE_OBRA and num_fields >= 5:
            if self._validate_mo_format(fields):
                logger.debug(f"MO_COMPLETA detectado: {descripcion[:30]}...")
                return FormatoLinea.MO_COMPLETA
        
        # Para cualquier línea con al menos 4 campos numéricos válidos
        if num_fields >= 4 and self._has_minimum_numeric_fields(fields, 2):
            logger.debug(f"INSUMO_BASICO detectado: {descripcion[:30]}...")
            return FormatoLinea.INSUMO_BASICO

        return FormatoLinea.DESCONOCIDO

    def _is_noise_line(self, descripcion_upper: str, num_fields: int) -> bool:
        """Detecta líneas de ruido con lógica mejorada."""
        # Líneas de resumen/total
        if any(keyword in descripcion_upper for keyword in self.NOISE_KEYWORDS):
            logger.debug(f"Línea de resumen ignorada")
            return True
        
        # Encabezados de tabla (múltiples palabras clave)
        header_count = sum(1 for kw in self.HEADER_KEYWORDS if kw in descripcion_upper)
        if header_count >= 2:
            logger.debug(f"Línea de encabezado ignorada")
            return True
        
        # Categorías (pocas columnas + palabra clave de categoría)
        if num_fields <= 2 and any(cat in descripcion_upper for cat in self.CATEGORY_KEYWORDS):
            logger.debug(f"Línea de categoría ignorada")
            return True
        
        return False

    def _has_minimum_numeric_fields(self, fields: List[str], minimum: int) -> bool:
        """Verifica si hay al menos 'minimum' campos numéricos válidos."""
        count = 0
        for i in range(1, len(fields)):  # Empezar desde 1 (saltar descripción)
            if self._safe_parse_number(fields[i]) is not None:
                count += 1
                if count >= minimum:
                    return True
        return False

    def _validate_mo_format(self, fields: List[str]) -> bool:
        """Valida formato MO con lógica robusta."""
        if len(fields) < 5:
            return False

        try:
            # MEJORA 8: Búsqueda más inteligente de valores
            valores_candidatos = self._extract_numeric_values_with_index(fields, start_from=2)
            
            if len(valores_candidatos) < 2:
                return False
            
            # Buscar jornal y rendimiento por características
            jornal_candidato = self._find_jornal_candidate(valores_candidatos)
            rendimiento_candidato = self._find_rendimiento_candidate(valores_candidatos)
            
            return jornal_candidato is not None and rendimiento_candidato is not None
            
        except Exception as e:
            logger.debug(f"Error validando MO: {e}")
            return False

    def _extract_numeric_values_with_index(self, fields: List[str], start_from: int = 0) -> List[Tuple[int, float]]:
        """Extrae valores numéricos con sus índices."""
        valores = []
        for i in range(start_from, len(fields)):
            val = self._safe_parse_number(fields[i])
            if val is not None and val > 0:
                valores.append((i, val))
        return valores

    def _find_jornal_candidate(self, valores: List[Tuple[int, float]]) -> Optional[float]:
        """Encuentra el mejor candidato para jornal."""
        for idx, val in valores:
            if self.thresholds["min_jornal"] <= val <= self.thresholds["max_jornal"]:
                return val
        return None

    def _find_rendimiento_candidate(self, valores: List[Tuple[int, float]]) -> Optional[float]:
        """Encuentra el mejor candidato para rendimiento."""
        for idx, val in valores:
            if (self.thresholds["min_rendimiento"] <= val <= 
                self.thresholds["max_rendimiento_tipico"]):
                return val
        return None

    def _build_mo_completa(self, tokens: List[str]) -> Optional[ManoDeObra]:
        """Construye objeto ManoDeObra con validación mejorada."""
        try:
            # MEJORA 9: Validación temprana
            if len(tokens) < 5:
                logger.debug("Insuficientes tokens para MO_COMPLETA")
                return None
            
            descripcion = tokens[0]
            unidad = self._extract_unit_or_default(tokens, 1, "JOR")
            
            # Extraer valores numéricos
            valores = self._extract_numeric_values_with_index(tokens, start_from=2)
            
            if len(valores) < 2:
                logger.debug("Insuficientes valores numéricos para MO")
                return None
            
            # Identificar jornal y rendimiento
            jornal = self._find_jornal_candidate(valores)
            rendimiento = self._find_rendimiento_candidate(valores)
            
            # MEJORA 10: Si no encuentra con la primera estrategia, intentar heurística alternativa
            if jornal is None or rendimiento is None:
                jornal, rendimiento = self._identify_mo_values_heuristic(valores)
            
            if jornal is None or rendimiento is None or rendimiento <= 0:
                logger.debug(f"No se pudo identificar jornal o rendimiento válidos")
                return None
            
            # Cálculos con validación
            cantidad = 1.0 / rendimiento if rendimiento > 0 else 0
            valor_total = cantidad * jornal
            
            # Validación de coherencia
            if cantidad <= 0 or valor_total <= 0:
                logger.warning(f"Valores calculados inválidos: cantidad={cantidad}, valor={valor_total}")
                return None
            
            return ManoDeObra(
                descripcion_insumo=descripcion,
                unidad_insumo=unidad,
                cantidad=round(cantidad, 6),
                precio_unitario=round(jornal, 2),
                valor_total=round(valor_total, 2),
                rendimiento=round(rendimiento, 6),
                formato_origen="MO_COMPLETA",
                tipo_insumo="MANO_DE_OBRA",
                normalized_desc=normalize_text(descripcion),
                **self.apu_context
            )
            
        except Exception as e:
            logger.error(f"Error construyendo MO_COMPLETA: {e}", exc_info=True)
            return None

    def _identify_mo_values_heuristic(self, valores: List[Tuple[int, float]]) -> Tuple[Optional[float], Optional[float]]:
        """Heurística alternativa para identificar jornal y rendimiento."""
        if len(valores) < 2:
            return None, None
        
        # Ordenar por valor
        valores_ordenados = sorted(valores, key=lambda x: x[1], reverse=True)
        
        # El valor más grande que sea >= min_jornal es probablemente el jornal
        jornal = None
        for idx, val in valores_ordenados:
            if val >= self.thresholds["min_jornal"]:
                jornal = val
                break
        
        # El valor más pequeño que sea un rendimiento válido
        rendimiento = None
        for idx, val in reversed(valores_ordenados):
            if (val != jornal and 
                self.thresholds["min_rendimiento"] <= val <= self.thresholds["max_rendimiento_tipico"]):
                rendimiento = val
                break
        
        return jornal, rendimiento

    def _build_insumo_basico(self, tokens: List[str]) -> Optional[InsumoProcesado]:
        """Construye insumo básico con validación mejorada."""
        try:
            # Validación temprana
            if len(tokens) < 4:
                logger.debug("Insuficientes tokens para insumo básico")
                return None
            
            descripcion = tokens[0]
            unidad = self._extract_unit_or_default(tokens, 1, "UND")
            
            # MEJORA 11: Extracción más inteligente de valores
            valores_numericos = self._extract_insumo_values(tokens[2:])
            
            if not valores_numericos:
                logger.debug("No se encontraron valores numéricos válidos")
                return None
            
            # Interpretar valores según cantidad encontrada
            cantidad, precio_unitario, valor_total = self._interpret_insumo_values(valores_numericos)
            
            # Validación y corrección
            cantidad, precio_unitario, valor_total = self._validate_and_correct_values(
                cantidad, precio_unitario, valor_total
            )
            
            if valor_total <= 0:
                logger.debug(f"Valor total inválido: {valor_total}")
                return None
            
            # Clasificar y construir
            tipo_insumo = self._classify_insumo(descripcion)
            InsumoClass = self._get_insumo_class(tipo_insumo)
            
            return InsumoClass(
                descripcion_insumo=descripcion,
                unidad_insumo=unidad,
                cantidad=round(cantidad, 6),
                precio_unitario=round(precio_unitario, 2),
                valor_total=round(valor_total, 2),
                rendimiento=round(cantidad, 6),
                formato_origen="INSUMO_BASICO",
                tipo_insumo=tipo_insumo.value,
                normalized_desc=normalize_text(descripcion),
                **self.apu_context
            )
            
        except Exception as e:
            logger.error(f"Error construyendo INSUMO_BASICO: {e}", exc_info=True)
            return None

    def _extract_unit_or_default(self, tokens: List[str], index: int, default: str) -> str:
        """Extrae unidad de manera segura o retorna default."""
        if index < len(tokens) and tokens[index]:
            return tokens[index]
        return default

    def _extract_insumo_values(self, value_tokens: List[str]) -> List[float]:
        """Extrae valores numéricos ignorando porcentajes de desperdicio."""
        valores = []
        for token in value_tokens:
            # Ignorar tokens con porcentaje (desperdicio)
            if token and '%' not in token:
                val = self._safe_parse_number(token)
                if val is not None and val >= 0:
                    valores.append(val)
        return valores

    def _interpret_insumo_values(self, valores: List[float]) -> Tuple[float, float, float]:
        """Interpreta los valores según la cantidad encontrada."""
        cantidad = 1.0
        precio = 0.0
        total = 0.0
        
        if len(valores) >= 3:
            # Formato completo: cantidad, precio, total
            cantidad = valores[0]
            precio = valores[1]
            total = valores[2]
        elif len(valores) == 2:
            # Formato reducido: cantidad, total
            cantidad = valores[0]
            total = valores[1]
            precio = total / cantidad if cantidad > 0 else 0
        elif len(valores) == 1:
            # Solo un valor: asumir es el precio unitario
            precio = valores[0]
            cantidad = 1.0
            total = precio
        
        return cantidad, precio, total

    def _validate_and_correct_values(self, cantidad: float, precio: float, total: float) -> Tuple[float, float, float]:
        """Valida y corrige valores de insumo."""
        # Asegurar cantidad positiva
        if cantidad <= 0:
            cantidad = 1.0
        
        # Calcular valores faltantes
        if precio <= 0 and total > 0 and cantidad > 0:
            precio = total / cantidad
        elif total <= 0 and cantidad > 0 and precio > 0:
            total = cantidad * precio
        
        # Verificar coherencia (con tolerancia del 5%)
        if cantidad > 0 and precio > 0 and total > 0:
            expected = cantidad * precio
            if abs(total - expected) / expected > 0.05:
                # Confiar en cantidad y total, recalcular precio
                precio = total / cantidad
        
        return cantidad, precio, total

    def _safe_parse_number(self, value: str) -> Optional[float]:
        """Parseo seguro y robusto de números."""
        if not value or not isinstance(value, str):
            return None
        
        try:
            # MEJORA 12: Limpieza más robusta
            clean = value.strip()
            
            # Remover espacios internos
            clean = clean.replace(' ', '')
            
            # Manejar signos negativos (aunque generalmente no esperamos negativos)
            is_negative = clean.startswith('-')
            if is_negative:
                clean = clean[1:]
            
            # Detectar y manejar separador decimal
            if ',' in clean and '.' not in clean:
                # Solo comas: probablemente separador decimal
                result = parse_number(clean, decimal_separator="comma")
            elif '.' in clean and ',' not in clean:
                # Solo puntos: separador decimal estándar
                result = parse_number(clean, decimal_separator="dot")
            elif ',' in clean and '.' in clean:
                # Ambos presentes: determinar cuál es el decimal
                # Si la coma viene después del punto, es decimal
                if clean.rindex(',') > clean.rindex('.'):
                    clean = clean.replace('.', '')  # Remover separador de miles
                    result = parse_number(clean, decimal_separator="comma")
                else:
                    clean = clean.replace(',', '')  # Remover separador de miles
                    result = parse_number(clean, decimal_separator="dot")
            else:
                # Sin separadores: número entero
                result = float(clean) if clean else None
            
            return -result if is_negative and result else result
            
        except (ValueError, TypeError, AttributeError):
            return None

    @lru_cache(maxsize=2048)
    def _classify_insumo(self, descripcion: str) -> TipoInsumo:
        """Clasifica tipo de insumo con caché."""
        if not descripcion:
            return TipoInsumo.OTRO
        
        desc_upper = descripcion.upper()
        
        # Casos especiales primero
        special_cases = {
            "HERRAMIENTA MENOR": TipoInsumo.EQUIPO,
            "HERRAMIENTA (% MO)": TipoInsumo.EQUIPO,
            "EQUIPO Y HERRAMIENTA": TipoInsumo.EQUIPO,
            "MANO DE OBRA": TipoInsumo.MANO_DE_OBRA,
            "MANO OBRA": TipoInsumo.MANO_DE_OBRA,
            "MO ": TipoInsumo.MANO_DE_OBRA,
        }
        
        for case, tipo in special_cases.items():
            if case in desc_upper:
                return tipo
        
        # Usar keyword cache si está disponible
        if self.keyword_cache:
            if hasattr(self.keyword_cache, 'mo_keywords'):
                if any(kw.upper() in desc_upper for kw in self.keyword_cache.mo_keywords):
                    return TipoInsumo.MANO_DE_OBRA
            if hasattr(self.keyword_cache, 'equipo_keywords'):
                if any(kw.upper() in desc_upper for kw in self.keyword_cache.equipo_keywords):
                    return TipoInsumo.EQUIPO
            if hasattr(self.keyword_cache, 'transporte_keywords'):
                if any(kw.upper() in desc_upper for kw in self.keyword_cache.transporte_keywords):
                    return TipoInsumo.TRANSPORTE
            if hasattr(self.keyword_cache, 'suministro_keywords'):
                if any(kw.upper() in desc_upper for kw in self.keyword_cache.suministro_keywords):
                    return TipoInsumo.SUMINISTRO
        
        # Keywords por defecto si no hay cache
        if any(kw in desc_upper for kw in ["OFICIAL", "PEON", "AYUDANTE", "MAESTRO", "OBRERO"]):
            return TipoInsumo.MANO_DE_OBRA
        if any(kw in desc_upper for kw in ["VIBRADOR", "MEZCLADORA", "COMPACTADOR", "HERRAMIENTA"]):
            return TipoInsumo.EQUIPO
        if any(kw in desc_upper for kw in ["CAMION", "VOLQUETA", "TRANSPORTE", "ACARREO"]):
            return TipoInsumo.TRANSPORTE
        if any(kw in desc_upper for kw in ["CEMENTO", "ARENA", "GRAVA", "HIERRO", "CONCRETO"]):
            return TipoInsumo.SUMINISTRO
        
        return TipoInsumo.OTRO

    def _get_insumo_class(self, tipo_insumo: TipoInsumo):
        """Obtiene la clase apropiada para el tipo."""
        class_mapping = {
            TipoInsumo.MANO_DE_OBRA: ManoDeObra,
            TipoInsumo.EQUIPO: Equipo,
            TipoInsumo.TRANSPORTE: Transporte,
            TipoInsumo.SUMINISTRO: Suministro,
            TipoInsumo.OTRO: OtroInsumo
        }
        return class_mapping.get(tipo_insumo, OtroInsumo)


# ============================================================================
# CLASE PRINCIPAL DEL PROCESADOR
# ============================================================================

class APUProcessor:
    """
    Procesador principal con manejo robusto de errores.
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.keyword_cache = self._load_keyword_cache()
        self.parser = self._create_parser()
    
    def _load_keyword_cache(self):
        """Carga el cache de palabras clave si existe."""
        # TODO: Implementar según tu lógica de cache
        return None
    
    def _create_parser(self):
        """Crea el parser Lark con manejo robusto de errores."""
        try:
            parser = Lark(
                APU_GRAMMAR,
                parser='lalr',
                transformer=None,
                debug=False  # MEJORA 13: Desactivar debug en producción
            )
            logger.info("Parser Lark creado exitosamente")
            return parser
        except LarkError as e:
            logger.error(f"Error creando parser Lark: {e}")
            raise
        except Exception as e:
            logger.error(f"Error inesperado creando parser: {e}")
            raise
    
    def process_line(self, line: str, apu_context: Dict[str, Any] = None) -> Optional[InsumoProcesado]:
        """Procesa una línea individual con manejo robusto."""
        if not line or not line.strip():
            return None
        
        try:
            # MEJORA 14: Normalizar la línea antes de parsear
            normalized_line = line.strip()
            
            # Si la línea no termina con punto y coma, agregarla puede ayudar
            # (algunos formatos la esperan)
            if not normalized_line.endswith(';'):
                normalized_line = normalized_line.rstrip(';')
            
            # Parsear la línea
            tree = self.parser.parse(normalized_line)
            
            # Crear y aplicar el transformer
            transformer = APUTransformer(
                apu_context or {},
                self.config,
                self.keyword_cache
            )
            
            result = transformer.transform(tree)
            
            # Manejar resultado
            if isinstance(result, list):
                return result[0] if result else None
            return result
            
        except ParseError as e:
            logger.debug(f"Error de parseo en línea: {line[:50]}... - {e}")
            return None
        except Exception as e:
            logger.debug(f"Error procesando línea: {line[:50]}... - {e}")
            return None
    
    def process_lines(self, lines: List[str], apu_context: Dict[str, Any] = None) -> List[InsumoProcesado]:
        """Procesa múltiples líneas con progreso."""
        results = []
        total_lines = len(lines)
        
        for i, line in enumerate(lines):
            if line and line.strip():
                result = self.process_line(line, apu_context)
                if result:
                    results.append(result)
                
                # MEJORA 15: Log de progreso para debugging
                if (i + 1) % 100 == 0:
                    logger.info(f"Procesadas {i + 1}/{total_lines} líneas, {len(results)} válidas")
        
        logger.info(f"Procesamiento completado: {len(results)} líneas válidas de {total_lines} totales")
        return results