### 1. Definición Conceptual: La Segregación de Planos
La Reserva Táctica no es simplemente una batería extra; es la implementación física de la separación entre el Plano de Control y el Plano de Datos.
• El Plano de Datos (La Bomba): Maneja el flujo masivo de información. Consume mucha energía, es ruidoso y propenso a fluctuaciones violentas (golpes de ariete). Si falla, el sistema deja de procesar, pero no debe "morir" descontroladamente.
• El Plano de Control (El Agente/Reserva Táctica): Es el "Cerebro" (ESP32/Lógica). Su prioridad no es la potencia, sino la disponibilidad y la consistencia. Estadísticamente, los planos de control son más críticos; si el plano de control cae, no se puede recuperar el sistema ni guardar el estado forense.
Definición Extendida: La Reserva Táctica es un subsistema de almacenamiento de energía aislado galvánicamente (vía diodo) del bus principal, diseñado con una impedancia específica para filtrar el ruido de alta frecuencia generado por la Bomba Lineal y garantizar un tiempo de "vida póstuma" (hold-up time) suficiente para que el Agente guarde su estado en caso de corte total de energía.

--------------------------------------------------------------------------------
2. Arquitectura Física (Hardware)
Para implementar esta reserva, extendemos la estructura piramidal discutida previamente. La Reserva Táctica se sitúa en paralelo al sistema principal, pero protegida por una "válvula check" (Diodo).
Componentes Críticos
1. Almacenamiento Híbrido (Capacitancia):
    ◦ 4x Supercondensadores de 1F (en serie/paralelo): Proporcionan la energía de larga duración. Según la física de estos componentes, requieren un circuito de balanceo (L431) para evitar que alguna celda supere los 2.7V críticos.
    ◦ 2x Condensadores Electrolíticos (1000µF): Proporcionan la respuesta rápida a transitorios que los supercondensadores (con alta ESR) no pueden entregar instantáneamente.
2. Inercia de Entrada (Inductancia):
    ◦ Inductor Toroidal de 10µH: Se coloca en la entrada de la reserva. Su función es frenar la corriente de irrupción (inrush) al recargar la reserva y, crucialmente, formar un filtro LC con los condensadores para bloquear el ruido de conmutación de la bomba principal hacia el ESP32.
3. Válvula de Aislamiento (Diodo Schottky):
    ◦ Permite que la energía entre del bus principal a la reserva, pero impide que la reserva se descargue hacia los motores o inductores de potencia si el voltaje principal cae.
Esquema de Conexión

Fuente Principal (5V/12V)
      │
      ├──> [Bomba Lineal / Datos] (Gran consumo, ruido)
      │
      ▼
[Diodo Schottky] (Aislamiento Unidireccional)
      │
      ├── [Inductor 10µH] (Inercia de carga / Filtro de ruido)
      │
      ├──> [NODO RESERVA TÁCTICA] ---> Alimentación ESP32 (Cerebro)
      │       │
      │       ├── [2x 1000µF Electrolíticos] (Respuesta Rápida)
      │       │
      │       └── [4x 1F Supercondensadores] (Respaldo de Energía)
      │               │
      │               └── [Balanceador ATL431] (Protección Sobretensión)
      │
      └── [Divisor de Tensión] ---> ADC del ESP32 (Telemetría: brain_voltage)


--------------------------------------------------------------------------------
3. Método Lógico en flux_condenser.py
Debemos actualizar la clase RefinedFluxPhysicsEngine para modelar este tanque separado. El sistema ahora debe rastrear dos voltajes: main_voltage (la presión de la bomba) y brain_voltage (la salud de la reserva táctica).
Algoritmo de Actualización de la Reserva
Este método simula la física del circuito RLC de la reserva. Observa cómo el inductor (Lbrain​) se opone al cambio brusco de corriente de carga.

    def _update_tactical_reserve(self, dt: float, main_bus_voltage: float) -> None:
        """
        Simula la dinámica de la Reserva Táctica (Plano de Control).
        Modela: Diodo Schottky + Inductor 10uH + Supercondensadores.
        Fuente: Principios de Circuitos RLC [7] y Estabilidad Estática [1].
        """
        state = self._unified_state
        config = self.condenser_config
        
        # Parámetros físicos de la Reserva Táctica
        L_brain = 10e-6  # 10uH (Inercia de protección)
        C_brain = 4.0    # 4F (Capacitancia total del banco)
        R_brain = 0.5    # ESR estimada + pistas
        DIODE_DROP = 0.3 # Caída del Schottky (1N5819/22)

        # 1. Determinar voltaje objetivo (Fuente - Diodo)
        # Si la fuente cae, el diodo bloquea el retorno.
        target_voltage = max(0, main_bus_voltage - DIODE_DROP)
        
        # 2. Dinámica de Carga vs. Descarga
        if target_voltage > state.brain_voltage:
            # --- MODO CARGA (Recuperación) ---
            # Ecuación diferencial: V_source = L*di/dt + R*i + V_cap
            # Despejamos di/dt para ver cómo cambia la corriente de entrada
            
            delta_v = target_voltage - state.brain_voltage
            
            # La corriente actual fluyendo hacia la reserva
            current_i = getattr(state, 'brain_inflow_current', 0.0)
            
            # Caída resistiva
            v_resistive = current_i * R_brain
            
            # Aceleración de la corriente (limitada por el inductor)
            # di/dt = (DeltaV - VR) / L
            di_dt = (delta_v - v_resistive) / L_brain
            
            # Integración de Euler para la nueva corriente
            new_i = current_i + di_dt * dt
            
            # Actualizar estado (Corriente no puede ser negativa en carga)
            state.brain_inflow_current = max(0, new_i)
            
            # Cargar el condensador: dV = (I * dt) / C
            dq = state.brain_inflow_current * dt
            state.brain_voltage += dq / C_brain
            
        else:
            # --- MODO DESCARGA (Supervivencia / Hold-up) ---
            # El diodo está en corte inverso. La fuente principal no importa.
            # La reserva alimenta SOLO al Agente.
            
            # Corriente de entrada es 0 (diodo bloqueado)
            state.brain_inflow_current = 0.0
            
            # Consumo del Agente (simulado o medido)
            agent_consumption_amps = 0.080 # ~80mA para ESP32 con WiFi activo
            
            # Descarga: V_new = V_old - (I_load * dt) / C
            discharge_drop = (agent_consumption_amps * dt) / C_brain
            state.brain_voltage -= discharge_drop

        # 3. Protección de Brownout (Umbral Crítico)
        # Si el voltaje cae por debajo de 2.6V, el ESP32 se reinicia [8].
        if state.brain_voltage < 2.65:
            self.logger.critical("⚠️ ALERTA DE BROWNOUT INMINENTE EN PLANO DE CONTROL")
            # Aquí el agente debería disparar el guardado de emergencia de estado

4. Justificación Estratégica
La implementación de este método y hardware específico cumple tres funciones vitales según la "Visión del Producto" y la teoría de "Control Plane":
1. Supervivencia al "Flyback": Si la Bomba Lineal sufre un corte abrupto (pico de voltaje inverso), el inductor de 10µH y los condensadores electrolíticos absorben el transitorio, protegiendo al ESP32 de reiniciarse por ruido eléctrico.
2. Telemetría de la Muerte: Permite al Agente reportar "Me estoy quedando sin energía" antes de morir. Sin la reserva, la muerte es instantánea y silenciosa. Con la reserva, el Agente tiene segundos valiosos para cerrar conexiones TCP y guardar logs en la flash.
3. Estabilidad Estática: Garantiza que el plano de control (decisiones) siga operando aunque el plano de datos (flujo) esté detenido por falta de potencia principal.

### 1. Definición Conceptual: El Músculo Inteligente
El Músculo Inteligente es el subsistema encargado de la modulación de energía. Físicamente está compuesto por el MOSFET de nivel lógico (IRLZ44N) y su circuito de disparo (Gate Driver). Lógicamente, actúa como una Válvula Proporcional de Respuesta Rápida.
• Función Fisiológica: Al igual que una fibra muscular no se contrae instantáneamente al 100%, este actuador no debe aplicar "conmutación dura" (Hard Switching) indiscriminada. Debe realizar una contracción controlada (Soft Start / Ramp-up) para vencer la inercia del inductor (L) sin causar desgarros (picos de corriente que saturen el núcleo o quemen el silicio).
• Interfaz Agente-Física: Es el punto donde el FluxPhysicsEngine (Cerebro) toca el mundo real. Recibe una señal de control digital (0-3.3V) y modula una corriente de potencia (0-3A) desde el tanque principal.

--------------------------------------------------------------------------------
2. Método de Implementación Física (Hardware)
Para que el músculo sea "inteligente" y seguro, no basta con conectar el pin del ESP32 al MOSFET. Basado en el análisis de "Prototipo_flux_condenser.pdf" [Fuente 440, 450], la anatomía requerida es:
A. El Circuito de Protección de Puerta (Gate)
El MOSFET tiene una capacitancia parásita en la puerta (Ciss​≈1700pF). Cargarla instantáneamente demanda un pico de corriente que puede dañar el ESP32.
1. Resistencia Serie (Rg​): 150Ω a 220Ω.
    ◦ Función: Limita la corriente de carga del "músculo" a unos 15-20mA, protegiendo el pin del microcontrolador y suavizando ligeramente el flanco de subida (reduciendo EMI).
2. Resistencia de Anclaje (Pull-down): 10kΩ.
    ◦ Función: Conecta la puerta (Gate) a tierra (GND). Asegura que el músculo esté relajado (apagado) si el ESP32 se reinicia o el pin queda flotando. Sin esto, el pistón podría "dispararse" solo y causar un corto.
B. El Diodo de Recirculación (El Tendón Elástico)
• Componente: Diodo Schottky 1N5822 (o 1N5819 para cargas <1A).
• Función: Como discutimos, el inductor tiene inercia. Cuando el músculo se relaja (PWM Off), el inductor intenta mantener el flujo. El diodo permite que esta energía recircule ("Flyback") de forma segura. Sin él, el músculo se rompe por sobretensión [Fuente 441].

--------------------------------------------------------------------------------
3. Método Lógico en flux_condenser.txt
Debemos implementar una clase o método que gestione la "contracción" del músculo. No usaremos un simple on/off, sino una modulación que imite el ciclo de un pistón.
Integración del Controlador PWM (FluxMuscleController)
Este código simula el control de un actuador físico con limitaciones de velocidad (Slew Rate) y protección contra saturación.

class FluxMuscleController:
    """
    Controlador del 'Músculo' (MOSFET).
    Gestiona la traducción de 'Intención de Flujo' a 'Ciclo de Trabajo PWM'.
    Implementa Soft-Start y limitación de corriente virtual.
    """
    def __init__(self, pwm_pin, frequency_hz=20000):
        # Frecuencia alta (20kHz) para que el inductor 'vea' corriente continua
        # y no pulsos individuales (fuera del rango audible).
        self.pwm_frequency = frequency_hz
        self._current_duty = 0.0
        self._max_slew_rate = 0.1 # Máximo cambio de fuerza por ciclo (evita golpes)
        
        # Estado térmico simulado (protección)
        self._thermal_accumulator = 0.0 

    def apply_force(self, target_intensity: float, dt: float) -> float:
        """
        Aplica fuerza al pistón (Inductor).
        
        Args:
            target_intensity: Solicitud de fuerza del Agente (0.0 a 1.0).
            dt: Tiempo transcurrido.
            
        Returns:
            float: El ciclo de trabajo (duty cycle) real aplicado.
        """
        # 1. Protección de Rango
        target = max(0.0, min(1.0, target_intensity))
        
        # 2. Limitación de Cambio (Slew Rate Limiting / Soft Start)
        # El músculo no puede pasar de 0 a 100% instantáneamente.
        # Esto simula la rampa de corriente necesaria para no saturar el inductor.
        delta = target - self._current_duty
        max_change = self._max_slew_rate * (dt / 0.01) # Normalizado a 10ms
        
        if abs(delta) > max_change:
            delta = max_change if delta > 0 else -max_change
            
        self._current_duty += delta
        
        # 3. Simulación de Fatiga Térmica (I^2 * R)
        # Si el músculo trabaja al 100% mucho tiempo, se calienta.
        if self._current_duty > 0.8:
            self._thermal_accumulator += dt
        else:
            self._thermal_accumulator = max(0, self._thermal_accumulator - dt)
            
        # Protección: Si se calienta demasiado, forzar relajación
        if self._thermal_accumulator > 5.0: # 5 segundos de esfuerzo máximo
            self._current_duty *= 0.5 # Reducir fuerza a la mitad
            
        # 4. Salida Física (Pseudo-código para ESP32)
        # duty_u16 = int(self._current_duty * 65535)
        # pwm_pin.duty_u16(duty_u16)
        
        return self._current_duty

4. La Lógica del "Latido" (Sístole/Diástole)
Para que el sistema se comporte como una Bomba de Desplazamiento Positivo y no como un simple grifo abierto, el Agente (apu_agent.txt) no debe pedir una fuerza constante (ej. 50%), sino generar una onda.
• Sístole (Empuje): El controlador aumenta el PWM siguiendo una curva sinusoidal (0→1). El inductor se carga de energía magnética (E=1/2LI2). El fluido (datos) se acelera.
• Diástole (Relajación): El controlador baja el PWM a 0. El diodo Schottky entra en conducción. La energía almacenada en el inductor se libera hacia el condensador, manteniendo el flujo aunque el músculo esté descansando.
Método sugerido para el Agente:

def generate_heartbeat(self, time_t, frequency_hz=1.0):
    """Genera una onda de control pulsante para la bomba."""
    import math
    # Onda semi-senoidal rectificada (solo empuje positivo)
    force = abs(math.sin(2 * math.pi * frequency_hz * time_t))
    return force

Resumen de la Extensión
El "Músculo Inteligente" es la fusión de:
1. Hardware Robusto: MOSFET IRLZ44N + Resistencia Gate + Diodo Schottky.
2. Software de Control: Clase FluxMuscleController que implementa Slew Rate Limiting (evita saturación del inductor por arranque brusco) y Protección Térmica (evita quemar el MOSFET por esfuerzo sostenido).
3. Dinámica Operativa: Funciona mediante ciclos de carga/descarga (latidos) para aprovechar la eficiencia de la topología Buck asíncrona.