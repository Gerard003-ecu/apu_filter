# ═══════════════════════════════════════════════════════════════════════════
# ClassificationRule - Métodos Refinados
# ═══════════════════════════════════════════════════════════════════════════

_ALLOWED_VARS: ClassVar[frozenset] = frozenset({"porcentaje_materiales", "porcentaje_mo_eq"})
_CONDITION_PATTERN: ClassVar[re.Pattern] = re.compile(
    r"^(?:[\d\s\.\(\)><=!]|porcentaje_materiales|porcentaje_mo_eq|and|or|not)+$"
)

def __post_init__(self):
    """Normaliza y valida la condición al instanciar (thread-safe)."""
    self.condition = self._normalize_condition(self.condition)
    self._validate_syntax()

def _validate_syntax(self) -> None:
    """Valida sintaxis mediante análisis léxico exhaustivo."""
    test_expr = self.condition
    
    for var in ClassificationRule._ALLOWED_VARS:
        test_expr = test_expr.replace(var, " ")
    
    test_expr = re.sub(r"\b\d+\.?\d*\b", " ", test_expr)
    
    for token in (">=", "<=", "==", "!=", ">", "<", "and", "or", "not", "(", ")"):
        test_expr = test_expr.replace(token, " ")
    
    remaining = test_expr.strip()
    if remaining:
        raise ValueError(f"Condición contiene elementos no permitidos: '{remaining}'")
    
    try:
        compile(self.condition, "<condition>", "eval")
    except SyntaxError as e:
        raise ValueError(f"Sintaxis inválida en condición: {e}") from e

def get_coverage_bounds(self) -> Tuple[Tuple[float, float], Tuple[float, float]]:
    """
    Extrae bounds del espacio de cobertura diferenciando operadores estrictos.
    
    Aplica ε-offset para operadores estrictos (>, <) preservando la topología
    del conjunto abierto vs cerrado en el espacio [0,1]².
    """
    mat_min, mat_max = 0.0, 1.0
    mo_min, mo_max = 0.0, 1.0
    epsilon = 1e-6
    
    bound_patterns = (
        (r"porcentaje_materiales\s*>=\s*(\d+\.?\d*)", "mat", "min", 0.0),
        (r"porcentaje_materiales\s*>\s*(\d+\.?\d*)",  "mat", "min", epsilon),
        (r"porcentaje_materiales\s*<=\s*(\d+\.?\d*)", "mat", "max", 0.0),
        (r"porcentaje_materiales\s*<\s*(\d+\.?\d*)",  "mat", "max", -epsilon),
        (r"porcentaje_mo_eq\s*>=\s*(\d+\.?\d*)",      "mo",  "min", 0.0),
        (r"porcentaje_mo_eq\s*>\s*(\d+\.?\d*)",       "mo",  "min", epsilon),
        (r"porcentaje_mo_eq\s*<=\s*(\d+\.?\d*)",      "mo",  "max", 0.0),
        (r"porcentaje_mo_eq\s*<\s*(\d+\.?\d*)",       "mo",  "max", -epsilon),
    )
    
    for pattern, var_type, bound_type, offset in bound_patterns:
        match = re.search(pattern, self.condition)
        if match:
            value = np.clip(float(match.group(1)) / 100.0 + offset, 0.0, 1.0)
            if var_type == "mat":
                if bound_type == "min":
                    mat_min = max(mat_min, value)
                else:
                    mat_max = min(mat_max, value)
            else:
                if bound_type == "min":
                    mo_min = max(mo_min, value)
                else:
                    mo_max = min(mo_max, value)
    
    return ((mat_min, mat_max), (mo_min, mo_max))


# ═══════════════════════════════════════════════════════════════════════════
# APUClassifier - Métodos Refinados  
# ═══════════════════════════════════════════════════════════════════════════

def _create_vectorized_function(self, condition: str) -> callable:
    """
    Compila condición a función NumPy vectorizada con traducción de operadores.
    
    Transforma operadores lógicos Python (and/or/not) a operadores bitwise
    NumPy (&/|/~) para broadcasting correcto sobre arrays.
    """
    np_condition = re.sub(r"\band\b", "&", condition)
    np_condition = re.sub(r"\bor\b", "|", np_condition)
    np_condition = re.sub(r"\bnot\s+", "~", np_condition)
    
    code = compile(np_condition, "<vectorized_rule>", "eval")
    
    def rule_func(x: np.ndarray, y: np.ndarray) -> np.ndarray:
        local_ns = {
            "porcentaje_materiales": np.asarray(x) * 100.0,
            "porcentaje_mo_eq": np.asarray(y) * 100.0
        }
        try:
            result = eval(code, {"__builtins__": {}}, local_ns)
            return np.asarray(result, dtype=bool)
        except Exception:
            return np.zeros_like(x, dtype=bool)
    
    return rule_func

def _sample_uncovered_regions(self, grid_size: int = 50) -> List[Tuple[float, float]]:
    """
    Muestrea cobertura del simplex [0,1]² mediante evaluación tensorizada.
    
    Complejidad: O(R) donde R = número de reglas (vs O(n²·R) anterior).
    La medida de Lebesgue del conjunto descubierto ≈ len(result) / grid_size².
    """
    x = np.linspace(0, 1, grid_size)
    y = np.linspace(0, 1, grid_size)
    X, Y = np.meshgrid(x, y)
    X_flat, Y_flat = X.ravel(), Y.ravel()
    
    covered = np.zeros(X_flat.shape, dtype=bool)
    
    for rule in self.rules:
        if rule.rule_type in self._rule_cache:
            try:
                covered |= self._rule_cache[rule.rule_type](X_flat, Y_flat)
            except Exception:
                pass
    
    remaining_uncovered = np.where(~covered)[0]
    if len(remaining_uncovered) > 0:
        for idx in remaining_uncovered:
            for rule in self.rules:
                if rule.evaluate(float(X_flat[idx]), float(Y_flat[idx])):
                    covered[idx] = True
                    break
    
    uncovered_mask = ~covered
    if not np.any(uncovered_mask):
        return []
    
    return list(zip(X_flat[uncovered_mask].tolist(), Y_flat[uncovered_mask].tolist()))

_analyze_coverage_voronoi = _sample_uncovered_regions

def classify_single(self, pct_materiales: float, pct_mo_eq: float, total_cost: float = 1.0) -> str:
    """
    Clasifica un APU escalar usando evaluación directa (sin overhead vectorial).
    """
    pct_materiales = float(np.clip(pct_materiales, 0.0, 1.0))
    pct_mo_eq = float(np.clip(pct_mo_eq, 0.0, 1.0))
    
    if total_cost <= 0 or np.isnan(total_cost):
        return self.zero_cost_type
    
    for rule in self.rules:
        if rule.evaluate(pct_materiales, pct_mo_eq):
            return rule.rule_type
    
    return self.default_type

def _classify_vectorized_optimized(
    self, totales: np.ndarray, pct_mat: np.ndarray, pct_mo: np.ndarray
) -> np.ndarray:
    """
    Clasificación vectorizada con asignación por prioridad mediante máscaras booleanas.
    
    Garantiza partición disjunta del espacio: cada punto pertenece a exactamente
    una categoría, respetando el orden topológico (prioridad).
    """
    n = len(totales)
    tipos = np.full(n, self.default_type, dtype=object)
    
    mask_sin_costo = (totales <= 0) | np.isnan(totales)
    tipos[mask_sin_costo] = self.zero_cost_type
    
    valid_mask = ~mask_sin_costo
    if not np.any(valid_mask):
        return tipos
    
    valid_idx = np.where(valid_mask)[0]
    mat_v = pct_mat[valid_mask]
    mo_v = pct_mo[valid_mask]
    
    sorted_rules = sorted(self.rules, key=lambda r: r.priority)
    
    rule_masks = {}
    for rule in sorted_rules:
        if rule.rule_type in self._rule_cache:
            try:
                rule_masks[rule.rule_type] = self._rule_cache[rule.rule_type](mat_v, mo_v)
            except Exception as e:
                logger.debug(f"Vectorización fallida para {rule.rule_type}: {e}")
                rule_masks[rule.rule_type] = np.array(
                    [rule.evaluate(m, mo) for m, mo in zip(mat_v, mo_v)], dtype=bool
                )
    
    assigned = np.zeros(len(valid_idx), dtype=bool)
    for rule in sorted_rules:
        if rule.rule_type not in rule_masks:
            continue
        
        candidates = rule_masks[rule.rule_type] & ~assigned
        if np.any(candidates):
            tipos[valid_idx[candidates]] = rule.rule_type
            assigned |= candidates
    
    return tipos

def _validate_rules(self) -> None:
    """Valida coherencia del sistema de reglas y cobertura topológica."""
    if not self.rules:
        raise ValueError("No hay reglas de clasificación definidas")
    
    type_counts = {}
    for rule in self.rules:
        type_counts[rule.rule_type] = type_counts.get(rule.rule_type, 0) + 1
    
    duplicates = {t for t, c in type_counts.items() if c > 1}
    if duplicates:
        logger.warning(f"⚠️ Tipos duplicados: {duplicates}")
    
    coverage_gaps = self._sample_uncovered_regions()
    if coverage_gaps:
        gap_ratio = len(coverage_gaps) / 2500.0
        logger.warning(
            f"⚠️ Reglas no cubren {gap_ratio:.1%} del espacio. "
            f"Puntos sin cobertura: {len(coverage_gaps)}"
        )
    else:
        logger.info("✓ Cobertura topológica completa validada.")


# ═══════════════════════════════════════════════════════════════════════════
# StructuralClassifier - Método Refinado
# ═══════════════════════════════════════════════════════════════════════════

def classify_by_structure(
    self, 
    insumos_del_apu: List[Dict], 
    min_support_threshold: float = 0.1
) -> Tuple[str, Dict[str, float]]:
    """
    Clasifica por topología de la red de insumos.
    
    Detecta componentes conexos en el grafo de composición:
    - SERVICIO_PURO: Componente MO dominante (≥90%)
    - SUMINISTRO_PURO: Componente MAT dominante (≥90%)
    - SUMINISTRO_AISLADO: MAT presente, MO ausente (isla topológica)
    - INSTALACION_AISLADA: MO presente, MAT ausente
    - ESTRUCTURA_MIXTA: Múltiples componentes con peso significativo
    """
    if not insumos_del_apu:
        return "ESTRUCTURA_VACIA", {}
    
    valores: Dict[str, float] = {}
    total = 0.0
    
    for insumo in insumos_del_apu:
        tipo = insumo.get("TIPO_INSUMO", "OTRO")
        valor = float(insumo.get("VALOR_TOTAL", 0.0))
        valores[tipo] = valores.get(tipo, 0.0) + valor
        total += valor
    
    if total <= 0:
        return "SIN_VALOR_ESTRUCTURAL", valores
    
    pcts = {k: v / total for k, v in valores.items()}
    
    mo_pct = pcts.get("MANO_DE_OBRA", 0.0)
    mat_pct = pcts.get("SUMINISTRO", 0.0)
    eq_pct = pcts.get("EQUIPO", 0.0)
    
    umbral_dominancia = 0.9
    umbral_presencia = min_support_threshold
    
    if mo_pct >= umbral_dominancia:
        return "SERVICIO_PURO", pcts
    
    if mat_pct >= umbral_dominancia:
        return "SUMINISTRO_PURO", pcts
    
    mo_presente = mo_pct >= umbral_presencia
    mat_presente = mat_pct >= umbral_presencia
    eq_presente = eq_pct >= umbral_presencia
    
    if mat_presente and not mo_presente and not eq_presente:
        return "SUMINISTRO_AISLADO", pcts
    
    if mo_presente and not mat_presente:
        return "INSTALACION_AISLADA", pcts
    
    return "ESTRUCTURA_MIXTA", pcts