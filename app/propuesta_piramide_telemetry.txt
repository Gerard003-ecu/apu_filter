1. ¬øEs coherente una Telemetr√≠a Jer√°rquica?
Totalmente. En la arquitectura de software moderna (observabilidad distribuida), esto se conoce como Tracing (Trazas y Spans), donde una operaci√≥n padre contiene operaciones hijas.
Aplicar esto a telemetry.txt alinea el sistema con el principio de Isomorfismo Estructural:
‚Ä¢ Nivel 0 (Ra√≠z): Salud del Proyecto (Ej. "Viabilidad Global").
‚Ä¢ Nivel 1 (Ramas): Salud de los Procesos/Cap√≠tulos (Ej. "Ingesta de Datos", "C√°lculo de Estructura").
‚Ä¢ Nivel 2 (Hojas): Salud de los √Åtomos (Ej. "Validaci√≥n del Insumo X", "C√°lculo del APU Y").
Si la telemetr√≠a es plana, un error en un insumo se ve igual que un error en el c√°lculo del ROI global. Al jerarquizarla, el sistema entiende que "100 errores en insumos" significan "1 Cap√≠tulo en riesgo", no "100 problemas aislados".

--------------------------------------------------------------------------------
2. Implementaci√≥n en telemetry.txt: El Stack de Contexto
Actualmente, TelemetryContext en telemetry.txt maneja una lista plana de steps
. Para volverla piramidal, debemos introducir el concepto de "Scope Stack" (Pila de Alcance).
Cambios propuestos para telemetry.txt:
Debemos modificar TelemetryContext para que start_step y end_step manejen profundidad.

# En app/telemetry.py

@dataclass
class TelemetrySpan:
    """Representa un bloque jer√°rquico de ejecuci√≥n (un nivel de la pir√°mide)."""
    name: str
    level: int
    parent_id: Optional[str]
    start_time: float
    metrics: Dict[str, Any] = field(default_factory=dict)
    children: List['TelemetrySpan'] = field(default_factory=list) # Estructura recursiva

@dataclass
class TelemetryContext:
    # ... atributos existentes ...
    _scope_stack: List[str] = field(default_factory=list) # Pila de IDs de padres activos

    @contextmanager
    def span(self, name: str, metadata: Dict = None):
        """
        Crea un contexto jer√°rquico (Nivel de Pir√°mide).
        Uso:
            with telemetry.span("Procesar Cap√≠tulo Cimentaci√≥n"):
                with telemetry.span("Analizar APU Concreto"):
                    ...
        """
        parent_id = self._scope_stack[-1] if self._scope_stack else None
        span_id = str(uuid.uuid4())
        
        # Registrar inicio (Push a la pir√°mide)
        self._scope_stack.append(span_id)
        current_level = len(self._scope_stack)
        
        try:
            yield self # Ejecuci√≥n del bloque
        finally:
            # Registrar fin (Pop de la pir√°mide)
            self._scope_stack.pop()
            # Aqu√≠ se agregan las m√©tricas agregadas al padre

Esto permite que, si falla un c√°lculo en el nivel 3 (Insumo), la telemetr√≠a sepa exactamente a qu√© APU (Nivel 2) y a qu√© Cap√≠tulo (Nivel 1) atribuir el impacto.

3. Implementaci√≥n en telemetry_narrative.py: La Pir√°mide Narrativa
Aqu√≠ es donde la l√≥gica se vuelve poderosa para el usuario. No queremos que el "Consejo de Sabios" le lea al usuario 5,000 l√≠neas de logs. Queremos que le cuente una historia jerarquizada.
Aplicaremos la l√≥gica DIKW (Datos ‚Üí Informaci√≥n ‚Üí Conocimiento ‚Üí Sabidur√≠a)
 a la narrativa.
Nueva L√≥gica para TelemetryNarrator:
En lugar de traducir m√©tricas aisladas, el narrador debe agregar y sintetizar bas√°ndose en la jerarqu√≠a definida en el punto anterior.

# En app/telemetry_narrative.py

class NarrativePyramid:
    def summarize_context(self, telemetry_tree: Dict) -> str:
        """
        Convierte el √°rbol de telemetr√≠a en una narrativa ejecutiva piramidal.
        """
        narrative = []
        
        # 1. C√öSPIDE (Sabidur√≠a): Veredicto del Proyecto
        # Si hay errores cr√≠ticos en niveles inferiores, la c√∫spide colapsa.
        if telemetry_tree['critical_errors'] > 0:
            narrative.append("üõë **VEREDICTO: PROYECTO EN RIESGO CR√çTICO**")
            narrative.append("La estructura no es viable debido a fallos en los cimientos.")
        
        # 2. NIVEL MEDIO (Conocimiento): An√°lisis de Cap√≠tulos/Fases
        # Agrupamos los errores por su nodo padre (ej. "Ingesta", "C√°lculo")
        for phase, stats in telemetry_tree['children'].items():
            if stats['error_rate'] > 0.1:
                narrative.append(f"  ‚ö†Ô∏è **Fase {phase}**: Inestable.")
                narrative.append(f"     -> El {stats['error_rate']:.1%} de los componentes fallaron.")
            elif stats['warning_count'] > 5:
                 narrative.append(f"  ‚ÑπÔ∏è **Fase {phase}**: Requiere revisi√≥n (Alta fricci√≥n detectada).")

        # 3. BASE (Datos/Informaci√≥n): Evidencia Forense (Solo lo m√°s relevante)
        # Solo mostramos los errores espec√≠ficos si son la causa ra√≠z de un fallo superior.
        top_errors = self._get_root_cause_errors(telemetry_tree)
        if top_errors:
            narrative.append("\nüîç **EVIDENCIA FORENSE (Causa Ra√≠z):**")
            for err in top_errors[:3]: # Solo los top 3 para no saturar
                narrative.append(f"  - {err['message']} (en {err['location']})")
                
        return "\n".join(narrative)

4. Resultado: Coherencia Total
Al implementar esto, logramos la siguiente alineaci√≥n en el ecosistema:
1. La Realidad (Datos): Es jer√°rquica (Presupuesto/APU/Insumo).
2. El Sensor (Telemetr√≠a): Es jer√°rquico (Span Padre/Hijo).
3. La Voz (Narrativa): Es jer√°rquica (Veredicto/Diagn√≥stico/Evidencia).
Ejemplo de Salida con Pir√°mide Narrativa:
DE: Consejo de Sabios ASUNTO: Informe de Estabilidad del Proyecto
1. VEREDICTO (C√∫spide): ‚ö†Ô∏è ESTABILIDAD COMPROMETIDA El proyecto presenta riesgos estructurales que impiden su aprobaci√≥n autom√°tica.
2. DIAGN√ìSTICO POR FASES (Nivel Medio):
‚Ä¢ Cimentaci√≥n (Datos): ‚ùå Cr√≠tico. La calidad de los datos de insumos es insuficiente (Alta Entrop√≠a).
‚Ä¢ Estructura (L√≥gica): ‚úÖ Estable. No se detectaron ciclos l√≥gicos, pero el c√°lculo es incierto debido a los datos de la base.
3. EVIDENCIA FORENSE (Base):
‚Ä¢ Causa Ra√≠z: El archivo insumos.csv contiene 450 filas con costo $0 en la categor√≠a "Acero".
‚Ä¢ Impacto: Esto genera una "Fricci√≥n" de 50W en el FluxCondenser, distorsionando el presupuesto total en un estimado del 15%.
Esta estructura permite al usuario leer solo la C√∫spide para tomar una decisi√≥n r√°pida, o bajar a la Base si necesita arreglar el problema, cumpliendo la promesa de "De los Datos a la Sabidur√≠a".
