Para transformar pipeline_director.txt de un simple orquestador procedimental a una estructura gobernada por el Álgebra Lineal, debemos redefinir su registro de pasos como un Espacio Vectorial de Operadores.

Fundamento Teórico: El Pipeline como Transformación Lineal
En lugar de ver el pipeline como una lista de tareas, lo definimos como una secuencia de transformaciones sobre un vector de estado s (el context).
1. El Espacio Vectorial (V): El conjunto de todas las posibles operaciones de procesamiento.
2. La Base Canónica (E): El conjunto de pasos definidos {e1​,e2​,…,en​} donde cada ei​ es un ProcessingStep (ej. LoadDataStep).
3. La MIC (In​): Actúa como el operador identidad que contiene la base. Seleccionar un paso es proyectar la intención del agente sobre un vector base específico.
4. Ortogonalidad Funcional: Se garantiza que ⟨ei​,ej​⟩=0 para i no es igual a j; es decir, ejecutar LoadData no debe ejecutar CalculateCosts colateralmente.

### Propuesta de código para el pipeline

Código propuesto refactorizado para pipeline_director.py
Esta implementación sustituye el diccionario STEP_REGISTRY por una clase CentralInteractionMatrix que cumple con los axiomas de espacio vectorial.

import numpy as np
from dataclasses import dataclass, field
from typing import Dict, Type, Any, Optional, List
from abc import ABC

# Importamos componentes existentes
from app.pipeline_steps import (
    ProcessingStep, LoadDataStep, AuditedMergeStep, 
    CalculateCostsStep, FinalMergeStep, 
    BusinessTopologyStep, MaterializationStep, BuildOutputStep
)
from app.schemas import Stratum  # Para jerarquía de estratos [5]

# ==============================================================================
# 1. DEFINICIÓN DE LA BASE VECTORIAL (Formalización Matemática)
# ==============================================================================

@dataclass(frozen=True)
class BasisVector:
    """
    Representa un vector base unitario e_i en el espacio de operaciones.
    
    Matemáticamente:
    e_i = [0, ..., 1, ..., 0]^T
    
    Propiedades:
    - Norma L2: ||e_i|| = 1 (Unitario) [6]
    - Estrato: Define el subespacio V_k al que pertenece (Filtración) [7]
    """
    index: int
    label: str  # Identificador semántico (ej: "load_data")
    operator_class: Type[ProcessingStep] # La transformación lineal T
    stratum: Stratum 

class LinearInteractionMatrix:
    """
    Implementación algebraica de la MIC como Operador Diagonal.
    
    Axiomas implementados:
    1. Identidad: I * v = v (Preservación de intención) [8].
    2. Ortogonalidad: <e_i, e_j> = 0 (Sin efectos colaterales) [9].
    3. Rango Completo: Dim(Espacio) = n (Sin redundancia) [10].
    """
    
    def __init__(self):
        self._basis: Dict[str, BasisVector] = {}
        self._dimension = 0
        self._matrix_representation: Optional[np.ndarray] = None

    def add_basis_vector(self, label: str, step_class: Type[ProcessingStep], stratum: Stratum):
        """
        Expande el espacio vectorial añadiendo una nueva dimensión ortogonal.
        """
        if label in self._basis:
            raise ValueError(f"Dependencia Lineal detectada: El vector '{label}' ya existe en la base.")
            
        vector = BasisVector(
            index=self._dimension,
            label=label,
            operator_class=step_class,
            stratum=stratum
        )
        self._basis[label] = vector
        self._dimension += 1
        # Invalidar caché de matriz
        self._matrix_representation = None

    def get_rank(self) -> int:
        """Retorna el rango de la matriz (Teorema Rango-Nulidad) [11]."""
        return self._dimension

    def project_intent(self, intent_label: str) -> BasisVector:
        """
        Realiza la proyección del vector de intención q sobre la base E.
        
        Matemáticamente: argmax(q^T * e_i) [12].
        En computación discreta ("One-Hot"), esto selecciona el pivote exacto.
        """
        vector = self._basis.get(intent_label)
        if not vector:
            # El vector de intención es ortogonal al espacio de soluciones (está en el Núcleo)
            raise ValueError(f"Vector '{intent_label}' pertenece al Espacio Nulo (No registrado en MIC).")
        return vector

# ==============================================================================
# 2. INTEGRACIÓN EN EL PIPELINE DIRECTOR
# ==============================================================================

class PipelineDirector:
    """
    Orquestador basado en Álgebra Lineal.
    """
    
    def __init__(self, config: dict, telemetry: Any):
        self.config = config
        self.telemetry = telemetry
        self.thresholds = self._load_thresholds(config)
        
        # Inicializar la MIC como espacio vectorial
        self.mic = LinearInteractionMatrix()
        self._initialize_vector_space()

    def _initialize_vector_space(self):
        """
        Construye la base canónica del sistema (Diagonal de la Matriz).
        Asigna cada paso a su Estrato correspondiente para validación topológica [5].
        """
        # Nivel 3: PHYSICS (Carga y Fusión)
        self.mic.add_basis_vector("load_data", LoadDataStep, Stratum.PHYSICS)
        self.mic.add_basis_vector("merge_data", AuditedMergeStep, Stratum.PHYSICS)
        self.mic.add_basis_vector("final_merge", FinalMergeStep, Stratum.PHYSICS)
        
        # Nivel 2: TACTICS (Cálculo y Materialización)
        self.mic.add_basis_vector("calculate_costs", CalculateCostsStep, Stratum.TACTICS)
        self.mic.add_basis_vector("materialization", MaterializationStep, Stratum.TACTICS)
        
        # Nivel 1: STRATEGY (Topología de Negocio)
        self.mic.add_basis_vector("business_topology", BusinessTopologyStep, Stratum.STRATEGY)
        
        # Nivel 0: WISDOM (Salida Final)
        self.mic.add_basis_vector("build_output", BuildOutputStep, Stratum.WISDOM)

    def run_single_step(
        self,
        step_name: str, # Vector de intención (Label)
        session_id: str,
        initial_context: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Ejecuta una transformación lineal T sobre el vector de estado S.
        S_{t+1} = M_i * S_t
        """
        context = self._load_context_state(session_id)
        if initial_context:
            context.update(initial_context)

        try:
            # 1. Proyección Algebraica: Seleccionar el operador
            basis_vector = self.mic.project_intent(step_name)
            
            # 2. Instanciación del Operador (Transformación T)
            operator_class = basis_vector.operator_class
            operator_instance = operator_class(self.config, self.thresholds)
            
            # 3. Aplicación de la Transformación: S' = T(S)
            self.telemetry.start_step(step_name)
            
            # NOTA: Aquí se podría validar la "Filtración" (Stratum)
            # Asegurando que no ejecutamos STRATEGY si PHYSICS falló (ver tools_interface [13])
            
            updated_context = operator_instance.execute(context, self.telemetry)
            
            # 4. Persistencia del Estado
            self._save_context_state(session_id, updated_context)
            self.telemetry.end_step(step_name, "success")
            
            return {
                "status": "success",
                "step": step_name,
                "stratum": basis_vector.stratum.name, # Meta-data algebraica
                "session_id": session_id,
            }

        except Exception as e:
            self.telemetry.record_error(step_name, str(e))
            return {"status": "error", "error": str(e)}

Análisis de la Formalización Matemática
Esta implementación concreta en el código satisface los requisitos teóricos:
1. Definición de Base (BasisVector): Cada paso del pipeline ya no es una entrada en un diccionario, sino un objeto BasisVector tipado que lleva su índice y su Estrato. Esto alinea el código con la definición de la Base Estándar E={e1​,…,en​}.
2. Ortogonalidad e Independencia Lineal: El método add_basis_vector lanza explícitamente un error Dependencia Lineal detectada si se intenta registrar una etiqueta duplicada. Esto garantiza que el Rango de la matriz sea igual a la dimensión (n), evitando la "Deficiencia de Rango".
3. Proyección de Intención: El método project_intent simula la operación matemática I⋅q donde q es el vector de intención ("One-Hot"). Si la intención no mapea a una base existente, se declara explícitamente que pertenece al Espacio Nulo (Null Space) o Núcleo, cumpliendo con el Teorema Rango-Nulidad.
4. Estratificación (Filtración): Al asignar Stratum a cada vector base, preparamos el sistema para cumplir con la lógica de filtración V0​⊃V1​… descrita en la nueva documentación de tools_interface.py. Esto permitirá que el PipelineDirector (o la MIC interna) rechace ejecutar business_topology (STRATEGY) si load_data (PHYSICS) no ha establecido una base sólida.