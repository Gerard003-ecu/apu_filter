"""
Procesador APU simplificado con lógica directa y robusta.
Versión final que prioriza simplicidad y confiabilidad sobre complejidad.
"""
import re
import logging
from typing import List, Optional, Tuple, Dict, Any
from enum import Enum
from functools import lru_cache
from lark import Transformer, v_args
from .utils import normalize_text, parse_number
from .schemas import (
    ManoDeObra, Equipo, Transporte, 
    Suministro, InsumoProcesado, OtroInsumo
)

logger = logging.getLogger(__name__)


class TipoInsumo(Enum):
    """Enumeración de tipos de insumo válidos."""
    MANO_DE_OBRA = "MANO_DE_OBRA"
    EQUIPO = "EQUIPO"
    TRANSPORTE = "TRANSPORTE"
    SUMINISTRO = "SUMINISTRO"
    OTRO = "OTRO"


class FormatoLinea(Enum):
    """Enumeración de formatos de línea detectados."""
    MO_COMPLETA = "MO_COMPLETA"
    INSUMO_BASICO = "INSUMO_BASICO"
    DESCONOCIDO = "DESCONOCIDO"


# Gramática Lark para parsing de líneas
APU_GRAMMAR = r"""
    ?start: line
    line: (field (SEP field)*)? NEWLINE?
    field: FIELD_VALUE
    FIELD_VALUE: /[^;\r\n\t]+/
    SEP: /\s*[;]\s*/
    NEWLINE: /[\r\n]+/
    %import common.WS
    %ignore WS
"""


# ============================================================================
# TRANSFORMER SIMPLIFICADO Y DIRECTO
# ============================================================================

@v_args(inline=True)
class APUTransformer(Transformer):
    """
    Transformador Lark que convierte líneas de texto en objetos InsumoProcesado.
    Versión simplificada con lógica directa y robusta.
    """
    
    # Palabras clave de ruido que deben ignorarse
    NOISE_KEYWORDS = [
        "SUBTOTAL", "TOTAL", "COSTO DIRECTO", "COSTO INDIRECTO",
        "RESUMEN", "TOTALES", "ACUMULADO", "SUMA"
    ]
    
    # Palabras clave de encabezados de tabla
    HEADER_KEYWORDS = [
        "DESCRIPCION", "DESCRIPCIÓN", "UND", "UNIDAD", 
        "CANT", "CANTIDAD", "PRECIO", "VALOR", "DESP", 
        "RENDIMIENTO", "JORNAL"
    ]
    
    # Categorías típicas (líneas de una sola palabra generalmente)
    CATEGORY_KEYWORDS = [
        "MATERIALES", "EQUIPO", "EQUIPOS", "TRANSPORTE",
        "MANO DE OBRA", "HERRAMIENTAS", "OTROS"
    ]

    def __init__(self, apu_context: Dict[str, Any], config: Dict[str, Any], keyword_cache: Any):
        self.apu_context = apu_context or {}
        self.config = config or {}
        self.keyword_cache = keyword_cache
        self.thresholds = self._load_validation_thresholds()
        super().__init__()

    def _load_validation_thresholds(self) -> Dict[str, Any]:
        """Carga los umbrales de validación desde la configuración."""
        mo_config = self.config.get("validation_thresholds", {}).get("MANO_DE_OBRA", {})
        return {
            "min_jornal": mo_config.get("min_jornal", 50000),
            "max_jornal": mo_config.get("max_jornal", 10000000),
            "min_rendimiento": mo_config.get("min_rendimiento", 0.001),
            "max_rendimiento": mo_config.get("max_rendimiento", 1000),
            "min_cantidad": 0.001,
            "max_cantidad": 1000000,
            "min_precio": 0.01,
            "max_precio": 1e9
        }

    def _clean_token(self, token) -> str:
        """Limpia y extrae el valor de un token."""
        if token is None: 
            return ""
        value = getattr(token, 'value', str(token))
        return value.strip() if value else ""

    def line(self, *fields) -> Optional[InsumoProcesado]:
        """Punto de entrada principal del transformer."""
        # Limpiar tokens
        tokens = [self._clean_token(f) for f in fields if f is not None]
        
        # Filtrar campos vacíos al final
        tokens = self._filter_trailing_empty(tokens)
        
        # Validación básica
        if not tokens or not tokens[0]:
            return None

        # Detectar formato y construir objeto
        formato = self._detect_format(tokens)
        
        if formato == FormatoLinea.DESCONOCIDO:
            logger.debug(f"Formato desconocido para: {tokens[:3]}...")
            return None

        return self._dispatch_builder(formato, tokens)

    def _filter_trailing_empty(self, tokens: List[str]) -> List[str]:
        """Elimina campos vacíos al final de la lista."""
        if not tokens:
            return []
        
        # Encontrar último campo no vacío
        last_idx = -1
        for i in range(len(tokens) - 1, -1, -1):
            if tokens[i]:
                last_idx = i
                break
        
        return tokens[:last_idx + 1] if last_idx >= 0 else []

    def _dispatch_builder(self, formato: FormatoLinea, tokens: List[str]) -> Optional[InsumoProcesado]:
        """Despacha al constructor apropiado según el formato."""
        try:
            if formato == FormatoLinea.MO_COMPLETA:
                return self._build_mo_completa(tokens)
            elif formato == FormatoLinea.INSUMO_BASICO:
                return self._build_insumo_basico(tokens)
            return None
        except Exception as e:
            logger.error(f"Error construyendo {formato.value}: {e}")
            return None

    ### ======================================================= ###
    ### MÉTODOS DE DETECCIÓN Y VALIDACIÓN SIMPLIFICADOS        ###
    ### ======================================================= ###

    def _detect_format(self, fields: List[str]) -> FormatoLinea:
        """
        Detecta el formato de la línea con lógica simplificada y directa.
        """
        if not fields or not fields[0]:
            return FormatoLinea.DESCONOCIDO

        descripcion = fields[0].strip().upper()
        num_fields = len(fields)

        # === FILTRO DE RUIDO SIMPLE Y EFECTIVO ===
        
        # 1. Descarta líneas de resumen/total
        if any(keyword in descripcion for keyword in self.NOISE_KEYWORDS):
            logger.debug(f"Línea de resumen ignorada: {fields[0][:30]}...")
            return FormatoLinea.DESCONOCIDO
        
        # 2. Descarta encabezados de tabla (múltiples palabras clave de columna)
        header_count = sum(1 for kw in self.HEADER_KEYWORDS if kw in descripcion)
        if header_count >= 2:  # Si tiene 2+ palabras de encabezado, es un header
            logger.debug(f"Línea de encabezado ignorada: {fields[0][:30]}...")
            return FormatoLinea.DESCONOCIDO
        
        # 3. Descarta categorías (líneas de 1-2 campos con palabras clave específicas)
        if num_fields <= 2 and any(cat in descripcion for cat in self.CATEGORY_KEYWORDS):
            logger.debug(f"Línea de categoría ignorada: {fields[0]}")
            return FormatoLinea.DESCONOCIDO
        
        # 4. Descarta líneas con muy pocos campos
        if num_fields < 3:
            return FormatoLinea.DESCONOCIDO

        # === CLASIFICACIÓN DE FORMATO ===
        
        # Determinar tipo de insumo
        tipo_probable = self._classify_insumo(fields[0])
        
        # Detectar MO_COMPLETA: necesita al menos 5 campos y ser tipo MO
        if num_fields >= 5 and tipo_probable == TipoInsumo.MANO_DE_OBRA:
            if self._validate_mo_format(fields):
                logger.debug(f"MO_COMPLETA detectado: {fields[0][:30]}...")
                return FormatoLinea.MO_COMPLETA
        
        # Para cualquier línea con suficientes campos, intentar como insumo básico
        if num_fields >= 4:
            logger.debug(f"INSUMO_BASICO detectado: {fields[0][:30]}...")
            return FormatoLinea.INSUMO_BASICO

        return FormatoLinea.DESCONOCIDO

    def _validate_mo_format(self, fields: List[str]) -> bool:
        """
        Valida si los campos corresponden a formato MO_COMPLETA.
        Busca patrones típicos de Mano de Obra con lógica flexible.
        """
        if len(fields) < 5:
            return False

        try:
            # Estrategia: buscar valores que parezcan jornal y rendimiento
            # El jornal es típicamente un valor grande (>50000)
            # El rendimiento es típicamente un valor pequeño (<100)
            
            # Convertir todos los campos numéricos
            numeric_values = []
            for i in range(2, len(fields)):  # Empezar desde el índice 2 (después de desc y unidad)
                val = self._safe_parse_number(fields[i])
                if val is not None and val > 0:
                    numeric_values.append((i, val))
            
            if len(numeric_values) < 2:
                return False
            
            # Buscar candidatos para jornal y rendimiento
            jornal_found = False
            rendimiento_found = False
            
            for idx, val in numeric_values:
                # Verificar si es un posible jornal
                if self.thresholds["min_jornal"] <= val <= self.thresholds["max_jornal"]:
                    jornal_found = True
                # Verificar si es un posible rendimiento
                if self.thresholds["min_rendimiento"] <= val <= self.thresholds["max_rendimiento"] and val < 100:
                    rendimiento_found = True
            
            return jornal_found and rendimiento_found
            
        except Exception as e:
            logger.debug(f"Error validando MO format: {e}")
            return False

    ### ======================================================= ###
    ### MÉTODOS DE CONSTRUCCIÓN SIMPLIFICADOS                  ###
    ### ======================================================= ###

    def _build_mo_completa(self, tokens: List[str]) -> Optional[ManoDeObra]:
        """
        Construye un objeto ManoDeObra con lógica adaptativa.
        """
        try:
            descripcion = tokens[0]
            unidad = tokens[1] if len(tokens) > 1 else "JOR"
            
            # Buscar jornal y rendimiento en los campos numéricos
            jornal = None
            rendimiento = None
            
            # Estrategia 1: Posiciones típicas (puede variar según el formato)
            # Formato común 1: [Desc, JOR, Rendimiento, , Jornal, Total]
            # Formato común 2: [Desc, JOR, Cantidad, Jornal, Rendimiento, Total]
            
            # Extraer todos los valores numéricos con sus posiciones
            numeric_values = []
            for i in range(2, len(tokens)):
                val = self._safe_parse_number(tokens[i])
                if val is not None and val > 0:
                    numeric_values.append((i, val))
            
            # Identificar jornal y rendimiento por sus rangos típicos
            for idx, val in numeric_values:
                if jornal is None and self.thresholds["min_jornal"] <= val <= self.thresholds["max_jornal"]:
                    jornal = val
                elif rendimiento is None and self.thresholds["min_rendimiento"] <= val <= 100:
                    # Rendimiento típicamente < 100
                    rendimiento = val
            
            # Validación
            if jornal is None or rendimiento is None or rendimiento <= 0:
                logger.debug(f"No se pudo identificar jornal o rendimiento válidos")
                return None
            
            # Cálculos
            cantidad = 1.0 / rendimiento if rendimiento > 0 else 0
            valor_total = cantidad * jornal
            
            # Validación de coherencia
            if cantidad <= 0 or valor_total <= 0:
                logger.warning(f"Valores calculados inválidos: cantidad={cantidad}, valor={valor_total}")
                return None
            
            logger.info(f"MO construida: {descripcion[:30]}... -> cant={cantidad:.4f}, jornal={jornal:,.0f}")
            
            return ManoDeObra(
                descripcion_insumo=descripcion,
                unidad_insumo=unidad,
                cantidad=round(cantidad, 6),
                precio_unitario=round(jornal, 2),
                valor_total=round(valor_total, 2),
                rendimiento=round(rendimiento, 6),
                formato_origen="MO_COMPLETA",
                tipo_insumo="MANO_DE_OBRA",
                normalized_desc=normalize_text(descripcion),
                **self.apu_context
            )
            
        except Exception as e:
            logger.error(f"Error construyendo MO_COMPLETA: {e}")
            return None

    def _build_insumo_basico(self, tokens: List[str]) -> Optional[InsumoProcesado]:
        """
        Construye un insumo básico con manejo flexible de formatos.
        """
        try:
            if len(tokens) < 4:
                return None
            
            descripcion = tokens[0]
            unidad = tokens[1] if len(tokens) > 1 else "UND"
            
            # Detectar estructura del formato
            # Puede ser: [Desc, Und, Cant, Precio, Total]
            # O: [Desc, Und, Cant, Desp%, Precio, Total]
            
            cantidad = None
            precio_unitario = None
            valor_total = None
            
            # Extraer valores numéricos significativos (ignorando porcentajes de desperdicio)
            numeric_values = []
            for i in range(2, len(tokens)):
                # Ignorar campos que sean claramente porcentajes
                if '%' not in tokens[i]:
                    val = self._safe_parse_number(tokens[i])
                    if val is not None and val >= 0:
                        numeric_values.append(val)
            
            # Asignar valores según la cantidad encontrada
            if len(numeric_values) >= 3:
                # Formato completo: cantidad, precio, total
                cantidad = numeric_values[0]
                precio_unitario = numeric_values[1]
                valor_total = numeric_values[2]
            elif len(numeric_values) == 2:
                # Formato reducido: cantidad, total (calcular precio)
                cantidad = numeric_values[0]
                valor_total = numeric_values[1]
                if cantidad > 0:
                    precio_unitario = valor_total / cantidad
            elif len(numeric_values) == 1:
                # Solo un valor, asumir cantidad = 1
                cantidad = 1.0
                precio_unitario = numeric_values[0]
                valor_total = precio_unitario
            else:
                return None
            
            # Validación y corrección
            if cantidad is None or cantidad <= 0:
                cantidad = 1.0
            
            if precio_unitario is None or precio_unitario < 0:
                if valor_total and valor_total > 0 and cantidad > 0:
                    precio_unitario = valor_total / cantidad
                else:
                    precio_unitario = 0
            
            if valor_total is None or valor_total <= 0:
                if cantidad > 0 and precio_unitario > 0:
                    valor_total = cantidad * precio_unitario
                else:
                    valor_total = 0
            
            # Validación final
            if valor_total <= 0:
                logger.debug(f"Valor total inválido: {valor_total}")
                return None
            
            # Determinar tipo de insumo y crear objeto
            tipo_insumo = self._classify_insumo(descripcion)
            InsumoClass = self._get_insumo_class(tipo_insumo)
            
            return InsumoClass(
                descripcion_insumo=descripcion,
                unidad_insumo=unidad,
                cantidad=round(cantidad, 6),
                precio_unitario=round(precio_unitario, 2),
                valor_total=round(valor_total, 2),
                rendimiento=round(cantidad, 6),  # Para insumos básicos, rendimiento = cantidad
                formato_origen="INSUMO_BASICO",
                tipo_insumo=tipo_insumo.value,
                normalized_desc=normalize_text(descripcion),
                **self.apu_context
            )
            
        except Exception as e:
            logger.error(f"Error construyendo INSUMO_BASICO: {e}")
            return None

    ### ======================================================= ###
    ### MÉTODOS AUXILIARES                                     ###
    ### ======================================================= ###

    def _safe_parse_number(self, value: str) -> Optional[float]:
        """Parsea un número de forma segura, retornando None si falla."""
        if not value or not isinstance(value, str):
            return None
        
        try:
            # Detectar separador decimal
            clean_value = value.strip()
            if ',' in clean_value and '.' not in clean_value:
                # Probablemente usa coma como separador decimal
                return parse_number(clean_value, decimal_separator="comma")
            else:
                # Usa punto como separador decimal
                return parse_number(clean_value, decimal_separator="dot")
        except:
            return None

    @lru_cache(maxsize=2048)
    def _classify_insumo(self, descripcion: str) -> TipoInsumo:
        """
        Clasifica el tipo de insumo basado en palabras clave.
        """
        if not descripcion:
            return TipoInsumo.OTRO
        
        desc_upper = descripcion.upper()
        
        # Casos especiales y explícitos primero
        special_cases = {
            "HERRAMIENTA MENOR": TipoInsumo.EQUIPO,
            "HERRAMIENTA (% MO)": TipoInsumo.EQUIPO,
            "EQUIPO Y HERRAMIENTA": TipoInsumo.EQUIPO,
            "MANO DE OBRA": TipoInsumo.MANO_DE_OBRA,
            "MANO OBRA": TipoInsumo.MANO_DE_OBRA,
            "MO ": TipoInsumo.MANO_DE_OBRA,
        }
        
        for case, tipo in special_cases.items():
            if case in desc_upper:
                return tipo
        
        # Usar keyword cache si está disponible
        if self.keyword_cache:
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'mo_keywords', [])):
                return TipoInsumo.MANO_DE_OBRA
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'equipo_keywords', [])):
                return TipoInsumo.EQUIPO
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'transporte_keywords', [])):
                return TipoInsumo.TRANSPORTE
            if any(kw.upper() in desc_upper for kw in getattr(self.keyword_cache, 'suministro_keywords', [])):
                return TipoInsumo.SUMINISTRO
        
        # Clasificación por palabras clave básicas si no hay cache
        if any(word in desc_upper for word in ["OFICIAL", "PEON", "AYUDANTE", "MAESTRO", "OBRERO", "JORNAL"]):
            return TipoInsumo.MANO_DE_OBRA
        if any(word in desc_upper for word in ["VIBRADOR", "MEZCLADORA", "COMPACTADOR", "RETROEXCAVADORA"]):
            return TipoInsumo.EQUIPO
        if any(word in desc_upper for word in ["CAMION", "VOLQUETA", "TRANSPORTE", "ACARREO"]):
            return TipoInsumo.TRANSPORTE
        if any(word in desc_upper for word in ["CEMENTO", "ARENA", "GRAVA", "HIERRO", "ACERO", "MADERA"]):
            return TipoInsumo.SUMINISTRO
        
        return TipoInsumo.OTRO

    def _get_insumo_class(self, tipo_insumo: TipoInsumo):
        """Retorna la clase apropiada para el tipo de insumo."""
        class_mapping = {
            TipoInsumo.MANO_DE_OBRA: ManoDeObra,
            TipoInsumo.EQUIPO: Equipo,
            TipoInsumo.TRANSPORTE: Transporte,
            TipoInsumo.SUMINISTRO: Suministro,
            TipoInsumo.OTRO: OtroInsumo
        }
        return class_mapping.get(tipo_insumo, OtroInsumo)