import re
import logging
import numpy as np
import pandas as pd
from typing import Tuple, Optional, Dict, List
from dataclasses import dataclass

logger = logging.getLogger(__name__)


class APUCostCalculator:
    """
    Calculador de costos APU con clasificaci√≥n robusta.
    
    CORRECCIONES APLICADAS:
    - Diagn√≥stico exhaustivo de TIPO_INSUMO antes del groupby
    - Mapeo can√≥nico ANTES del groupby (no despu√©s del unstack)
    - Fallback heur√≠stico basado en descripci√≥n del insumo
    - Validaci√≥n de resultados post-agregaci√≥n
    """
    
    def __init__(self, config: dict, thresholds: 'ProcessingThresholds'):
        self.config = config
        self.thresholds = thresholds
        
        # Mapeo can√≥nico de tipos de insumo ‚Üí categor√≠as de costo
        self._tipo_to_categoria = {
            # Materiales/Suministros
            InsumoTypes.SUMINISTRO: ColumnNames.MATERIALES,
            "MATERIAL": ColumnNames.MATERIALES,
            "MATERIALES": ColumnNames.MATERIALES,
            "SUMINISTRO": ColumnNames.MATERIALES,
            "SUMINISTROS": ColumnNames.MATERIALES,
            
            # Mano de obra
            InsumoTypes.MANO_DE_OBRA: ColumnNames.MANO_DE_OBRA,
            "MANO DE OBRA": ColumnNames.MANO_DE_OBRA,
            "MANO_DE_OBRA": ColumnNames.MANO_DE_OBRA,
            "M.O.": ColumnNames.MANO_DE_OBRA,
            "MO": ColumnNames.MANO_DE_OBRA,
            "CUADRILLA": ColumnNames.MANO_DE_OBRA,
            
            # Equipos
            InsumoTypes.EQUIPO: ColumnNames.EQUIPO,
            "EQUIPO": ColumnNames.EQUIPO,
            "EQUIPOS": ColumnNames.EQUIPO,
            "HERRAMIENTA": ColumnNames.EQUIPO,
            "HERRAMIENTAS": ColumnNames.EQUIPO,
            "MAQUINARIA": ColumnNames.EQUIPO,
            
            # Otros
            InsumoTypes.TRANSPORTE: ColumnNames.OTROS,
            "TRANSPORTE": ColumnNames.OTROS,
            "TRANSPORTES": ColumnNames.OTROS,
            InsumoTypes.OTRO: ColumnNames.OTROS,
            "OTRO": ColumnNames.OTROS,
            "OTROS": ColumnNames.OTROS,
            "INDEFINIDO": ColumnNames.OTROS,
        }

    def calculate(
        self, df_merged: pd.DataFrame
    ) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
        """Punto de entrada principal."""
        if df_merged is None or df_merged.empty:
            logger.error("‚ùå DataFrame merged vac√≠o o None")
            return pd.DataFrame(), pd.DataFrame(), pd.DataFrame()
        
        # NUEVO: Pre-procesamiento de TIPO_INSUMO
        df_merged = self._normalize_tipo_insumo(df_merged)
        
        df_apu_costos = self._aggregate_costs(df_merged)
        df_apu_costos = self._calculate_unit_values(df_apu_costos)
        df_apu_costos = self._classify_apus(df_apu_costos)
        df_tiempo = self._calculate_time(df_merged)
        df_rendimiento = self._calculate_performance(df_merged)
        
        return df_apu_costos, df_tiempo, df_rendimiento

    def _normalize_tipo_insumo(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        NUEVO: Normaliza TIPO_INSUMO ANTES del groupby para asegurar
        categor√≠as can√≥nicas consistentes.
        """
        df = df.copy()
        
        if ColumnNames.TIPO_INSUMO not in df.columns:
            logger.warning(f"‚ö†Ô∏è Columna '{ColumnNames.TIPO_INSUMO}' no existe, creando...")
            df[ColumnNames.TIPO_INSUMO] = InsumoTypes.OTRO
        
        # Diagn√≥stico inicial
        tipo_counts_before = df[ColumnNames.TIPO_INSUMO].value_counts(dropna=False)
        logger.info(f"üêõ DIAG: Distribuci√≥n TIPO_INSUMO PRE-normalizaci√≥n:\n{tipo_counts_before.head(10)}")
        
        # Normalizar texto
        df[ColumnNames.TIPO_INSUMO] = (
            df[ColumnNames.TIPO_INSUMO]
            .astype(str)
            .str.strip()
            .str.upper()
            .replace({"NAN": None, "NONE": None, "": None})
        )
        
        # Mapear a categor√≠a can√≥nica de costo
        df["_CATEGORIA_COSTO"] = df[ColumnNames.TIPO_INSUMO].map(self._tipo_to_categoria)
        
        # Fallback: Inferencia heur√≠stica desde descripci√≥n del insumo
        mask_sin_categoria = df["_CATEGORIA_COSTO"].isna()
        if mask_sin_categoria.any():
            logger.info(f"üîß Aplicando inferencia heur√≠stica a {mask_sin_categoria.sum()} registros sin categor√≠a")
            df.loc[mask_sin_categoria, "_CATEGORIA_COSTO"] = df.loc[
                mask_sin_categoria
            ].apply(self._infer_categoria_from_description, axis=1)
        
        # Diagn√≥stico final
        categoria_counts = df["_CATEGORIA_COSTO"].value_counts(dropna=False)
        logger.info(f"üêõ DIAG: Distribuci√≥n _CATEGORIA_COSTO POST-normalizaci√≥n:\n{categoria_counts}")
        
        # Validar que no haya demasiados NaN
        pct_na = df["_CATEGORIA_COSTO"].isna().mean() * 100
        if pct_na > 20:
            logger.warning(f"‚ö†Ô∏è {pct_na:.1f}% de registros sin categor√≠a de costo asignada")
        
        return df

    def _infer_categoria_from_description(self, row: pd.Series) -> str:
        """
        NUEVO: Infiere la categor√≠a de costo a partir de la descripci√≥n del insumo.
        Fallback cuando TIPO_INSUMO no est√° disponible o no es reconocido.
        """
        # Intentar obtener descripci√≥n desde m√∫ltiples fuentes
        desc = None
        for col in [ColumnNames.DESCRIPCION_INSUMO, ColumnNames.NORMALIZED_DESC, 
                    ColumnNames.DESCRIPCION_INSUMO_APU]:
            if col in row.index and pd.notna(row.get(col)):
                desc = str(row[col]).upper()
                break
        
        if not desc:
            return ColumnNames.OTROS
        
        # Patrones de identificaci√≥n
        patterns_mo = [
            r'\bOFICIAL\b', r'\bAYUDANTE\b', r'\bPEON\b', r'\bOBRERO\b',
            r'\bCUADRILLA\b', r'\bMAESTRO\b', r'\bM\.?O\.?\b',
            r'\bINGENIERO\b', r'\bTECNICO\b', r'\bTOPOGRAFO\b'
        ]
        
        patterns_equipo = [
            r'\bEQUIPO\b', r'\bHERRAMIENTA\b', r'\bMAQUINARIA\b',
            r'\bRETROEXCAVADOR', r'\bVOLQUETA\b', r'\bVIBRADOR',
            r'\bCOMPACTADOR', r'\bBOMBA\b', r'\bMEZCLADOR',
            r'\bANDAMIO\b', r'\bFORMALETA\b', r'\bCIMBRA\b'
        ]
        
        patterns_material = [
            r'\bCONCRETO\b', r'\bCEMENTO\b', r'\bAGREGADO\b',
            r'\bARINA\b', r'\bGRAVA\b', r'\bACERO\b', r'\bVARILLA\b',
            r'\bALAMBRE\b', r'\bLADRILLO\b', r'\bBLOQUE\b',
            r'\bTUBO\b', r'\bTUBERIA\b', r'\bPINTURA\b',
            r'\bMATERIAL\b', r'\bINSUMO\b', r'\bSUMINISTRO\b'
        ]
        
        patterns_transporte = [
            r'\bTRANSPORTE\b', r'\bACARREO\b', r'\bFLETE\b'
        ]
        
        # Evaluar patrones en orden de prioridad
        for pattern in patterns_mo:
            if re.search(pattern, desc):
                return ColumnNames.MANO_DE_OBRA
        
        for pattern in patterns_equipo:
            if re.search(pattern, desc):
                return ColumnNames.EQUIPO
        
        for pattern in patterns_transporte:
            if re.search(pattern, desc):
                return ColumnNames.OTROS
        
        for pattern in patterns_material:
            if re.search(pattern, desc):
                return ColumnNames.MATERIALES
        
        # Default: Si tiene prefijo conocido
        if desc.startswith(("M.O.", "MO ", "CUAD")):
            return ColumnNames.MANO_DE_OBRA
        elif desc.startswith(("EQ ", "EQUIPO", "HERR")):
            return ColumnNames.EQUIPO
        elif desc.startswith(("TRANS", "ACARR")):
            return ColumnNames.OTROS
        
        # Default final: Asumir material (es lo m√°s com√∫n)
        return ColumnNames.MATERIALES

    def _aggregate_costs(self, df_merged: pd.DataFrame) -> pd.DataFrame:
        """
        Agrega costos por tipo de insumo usando la categor√≠a normalizada.
        
        CORREGIDO:
        - Usa _CATEGORIA_COSTO (ya normalizada) en lugar de TIPO_INSUMO
        - Diagn√≥stico mejorado
        - Validaci√≥n de resultados
        """
        df = df_merged.copy()
        
        # Asegurar columna de costo num√©rica
        if ColumnNames.COSTO_INSUMO_EN_APU not in df.columns:
            logger.error(f"‚ùå Columna '{ColumnNames.COSTO_INSUMO_EN_APU}' no existe")
            return pd.DataFrame()
        
        df[ColumnNames.COSTO_INSUMO_EN_APU] = pd.to_numeric(
            df[ColumnNames.COSTO_INSUMO_EN_APU], errors="coerce"
        ).fillna(0)
        
        # Usar la categor√≠a normalizada (calculada en _normalize_tipo_insumo)
        categoria_col = "_CATEGORIA_COSTO"
        if categoria_col not in df.columns:
            logger.warning("‚ö†Ô∏è _CATEGORIA_COSTO no existe, usando TIPO_INSUMO directo")
            categoria_col = ColumnNames.TIPO_INSUMO
            df[categoria_col] = df[categoria_col].fillna(ColumnNames.OTROS)
        
        # Diagn√≥stico pre-agregaci√≥n
        logger.info(f"üêõ DIAG: Agregando costos para {df[ColumnNames.CODIGO_APU].nunique()} APUs √∫nicos")
        logger.info(f"üêõ DIAG: Total costo a distribuir: {df[ColumnNames.COSTO_INSUMO_EN_APU].sum():,.2f}")
        
        # Agrupar por APU y Categor√≠a de Costo
        costs = (
            df.groupby([ColumnNames.CODIGO_APU, categoria_col])[
                ColumnNames.COSTO_INSUMO_EN_APU
            ]
            .sum()
            .unstack(fill_value=0)
            .reset_index()
        )
        
        # Diagn√≥stico post-unstack
        logger.info(f"üêõ DIAG: Columnas despu√©s de unstack: {list(costs.columns)}")
        logger.info(f"üêõ DIAG: Filas (APUs) en costs: {len(costs)}")
        
        # Asegurar columnas can√≥nicas
        canonical_cols = [
            ColumnNames.MATERIALES,
            ColumnNames.MANO_DE_OBRA,
            ColumnNames.EQUIPO,
            ColumnNames.OTROS,
        ]
        
        for col in canonical_cols:
            if col not in costs.columns:
                costs[col] = 0.0
            else:
                costs[col] = pd.to_numeric(costs[col], errors='coerce').fillna(0.0)
        
        # Diagn√≥stico de distribuci√≥n final
        cost_summary = {col: costs[col].sum() for col in canonical_cols}
        logger.info(f"üìä Distribuci√≥n de costos totales: {cost_summary}")
        
        items_per_category = {col: (costs[col] > 0).sum() for col in canonical_cols}
        logger.info(f"üìä APUs con costos por categor√≠a: {items_per_category}")
        
        # Validaci√≥n
        total_original = df[ColumnNames.COSTO_INSUMO_EN_APU].sum()
        total_agregado = sum(cost_summary.values())
        
        if abs(total_original - total_agregado) > 0.01:
            logger.warning(
                f"‚ö†Ô∏è Discrepancia en totales: Original={total_original:,.2f}, "
                f"Agregado={total_agregado:,.2f}, Diff={total_original - total_agregado:,.2f}"
            )
        
        # Seleccionar solo columnas necesarias
        result = costs[[ColumnNames.CODIGO_APU] + canonical_cols].copy()
        
        return result

    def _calculate_unit_values(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calcula valores unitarios consolidados."""
        if df.empty:
            return df
            
        df = df.copy()
        
        # Asegurar columnas existen
        for col in [ColumnNames.MATERIALES, ColumnNames.MANO_DE_OBRA, 
                    ColumnNames.EQUIPO, ColumnNames.OTROS]:
            if col not in df.columns:
                df[col] = 0.0
        
        df[ColumnNames.VALOR_SUMINISTRO_UN] = df[ColumnNames.MATERIALES]
        df[ColumnNames.VALOR_INSTALACION_UN] = (
            df[ColumnNames.MANO_DE_OBRA] + df[ColumnNames.EQUIPO]
        )
        df[ColumnNames.VALOR_CONSTRUCCION_UN] = (
            df[ColumnNames.VALOR_SUMINISTRO_UN]
            + df[ColumnNames.VALOR_INSTALACION_UN]
            + df[ColumnNames.OTROS]
        )
        
        return df

    def _classify_apus(self, df: pd.DataFrame) -> pd.DataFrame:
        """Clasifica APUs seg√∫n proporci√≥n de costos."""
        if df is None or df.empty:
            return pd.DataFrame()

        df = df.copy()

        # Asegurar columnas de costos
        cost_columns = [
            ColumnNames.VALOR_CONSTRUCCION_UN,
            ColumnNames.VALOR_SUMINISTRO_UN,
            ColumnNames.VALOR_INSTALACION_UN,
        ]

        for col in cost_columns:
            if col not in df.columns:
                df[col] = 0.0
            else:
                df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0.0)

        # Calcular porcentajes
        total_cost = df[ColumnNames.VALOR_CONSTRUCCION_UN].replace(0, np.nan)

        df["_pct_materiales"] = (
            df[ColumnNames.VALOR_SUMINISTRO_UN] / total_cost * 100
        ).fillna(0)

        df["_pct_mo_eq"] = (
            df[ColumnNames.VALOR_INSTALACION_UN] / total_cost * 100
        ).fillna(0)

        # Inicializar
        df[ColumnNames.TIPO_APU] = APUTypes.INDEFINIDO

        # Aplicar reglas desde thresholds
        th = self.thresholds

        # Instalaci√≥n: alto % mano de obra + equipo
        mask_instalacion = df["_pct_mo_eq"] >= th.instalacion_mo_threshold
        df.loc[mask_instalacion, ColumnNames.TIPO_APU] = APUTypes.INSTALACION

        # Suministro: alto % materiales, bajo % MO
        mask_suministro = (
            (df["_pct_materiales"] >= th.suministro_mat_threshold) &
            (df["_pct_mo_eq"] <= th.suministro_mo_max)
        )
        df.loc[mask_suministro, ColumnNames.TIPO_APU] = APUTypes.SUMINISTRO

        # Suministro Prefabricado
        mask_prefab = (
            (df["_pct_materiales"] >= th.prefabricado_mat_threshold) &
            (df["_pct_mo_eq"] >= th.prefabricado_mo_min) &
            (df["_pct_mo_eq"] < th.instalacion_mo_threshold)
        )
        df.loc[mask_prefab, ColumnNames.TIPO_APU] = APUTypes.SUMINISTRO_PREFABRICADO

        # Obra Completa: resto con costos v√°lidos
        mask_obra_completa = (
            (df[ColumnNames.TIPO_APU] == APUTypes.INDEFINIDO) &
            (total_cost.notna()) &
            (total_cost > 0)
        )
        df.loc[mask_obra_completa, ColumnNames.TIPO_APU] = APUTypes.OBRA_COMPLETA

        # Diagn√≥stico
        tipo_dist = df[ColumnNames.TIPO_APU].value_counts()
        logger.info(f"üìä Distribuci√≥n de tipos de APU:\n{tipo_dist}")

        # Limpieza
        df.drop(columns=["_pct_materiales", "_pct_mo_eq"], inplace=True, errors="ignore")

        return df

    def _calculate_time(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calcula tiempo de instalaci√≥n por APU."""
        # Usar _CATEGORIA_COSTO si existe, sino TIPO_INSUMO
        filter_col = "_CATEGORIA_COSTO" if "_CATEGORIA_COSTO" in df.columns else ColumnNames.TIPO_INSUMO
        
        mask_mo = df[filter_col].isin([
            ColumnNames.MANO_DE_OBRA, 
            InsumoTypes.MANO_DE_OBRA,
            "MANO DE OBRA",
            "MANO_DE_OBRA"
        ])
        
        if not mask_mo.any():
            logger.warning("‚ö†Ô∏è No se encontraron registros de mano de obra para calcular tiempo")
            return pd.DataFrame(columns=[ColumnNames.CODIGO_APU, ColumnNames.TIEMPO_INSTALACION])
        
        return (
            df[mask_mo]
            .groupby(ColumnNames.CODIGO_APU)[ColumnNames.CANTIDAD_APU]
            .sum()
            .reset_index()
            .rename(columns={ColumnNames.CANTIDAD_APU: ColumnNames.TIEMPO_INSTALACION})
        )

    def _calculate_performance(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calcula rendimiento por APU."""
        if ColumnNames.RENDIMIENTO not in df.columns:
            return pd.DataFrame(columns=[ColumnNames.CODIGO_APU, ColumnNames.RENDIMIENTO_DIA])
        
        filter_col = "_CATEGORIA_COSTO" if "_CATEGORIA_COSTO" in df.columns else ColumnNames.TIPO_INSUMO
        
        mask_mo = df[filter_col].isin([
            ColumnNames.MANO_DE_OBRA,
            InsumoTypes.MANO_DE_OBRA,
            "MANO DE OBRA",
            "MANO_DE_OBRA"
        ])
        
        if not mask_mo.any():
            return pd.DataFrame(columns=[ColumnNames.CODIGO_APU, ColumnNames.RENDIMIENTO_DIA])
        
        return (
            df[mask_mo]
            .groupby(ColumnNames.CODIGO_APU)[ColumnNames.RENDIMIENTO]
            .sum()
            .reset_index()
            .rename(columns={ColumnNames.RENDIMIENTO: ColumnNames.RENDIMIENTO_DIA})
        )


class DataMerger:
    """
    Fusionador de datos con asignaci√≥n robusta de TIPO_INSUMO.
    
    CORRECCIONES:
    - Mapeo can√≥nico consistente con APUCostCalculator
    - Diagn√≥stico detallado del resultado del merge
    - Inferencia heur√≠stica cuando el merge no cruza
    """
    
    def __init__(self, thresholds: 'ProcessingThresholds'):
        self.thresholds = thresholds or ProcessingThresholds()
        
        # Mapeo can√≥nico GRUPO_INSUMO ‚Üí TIPO_INSUMO
        self._group_to_tipo = {
            # Materiales
            "MATERIALES": InsumoTypes.SUMINISTRO,
            "MATERIAL": InsumoTypes.SUMINISTRO,
            "SUMINISTRO": InsumoTypes.SUMINISTRO,
            "SUMINISTROS": InsumoTypes.SUMINISTRO,
            
            # Mano de obra
            "MANO DE OBRA": InsumoTypes.MANO_DE_OBRA,
            "MANO_DE_OBRA": InsumoTypes.MANO_DE_OBRA,
            "M.O.": InsumoTypes.MANO_DE_OBRA,
            "MO": InsumoTypes.MANO_DE_OBRA,
            
            # Equipos
            "EQUIPO": InsumoTypes.EQUIPO,
            "EQUIPOS": InsumoTypes.EQUIPO,
            "HERRAMIENTA": InsumoTypes.EQUIPO,
            "HERRAMIENTAS": InsumoTypes.EQUIPO,
            "MAQUINARIA": InsumoTypes.EQUIPO,
            
            # Transporte
            "TRANSPORTE": InsumoTypes.TRANSPORTE,
            "TRANSPORTES": InsumoTypes.TRANSPORTE,
        }

    def merge_apus_with_insumos(
        self, df_apus: pd.DataFrame, df_insumos: pd.DataFrame
    ) -> pd.DataFrame:
        """Fusiona APUs con insumos con asignaci√≥n robusta de tipos."""
        # Validaciones
        if df_apus is None or not isinstance(df_apus, pd.DataFrame) or df_apus.empty:
            logger.error("‚ùå df_apus inv√°lido o vac√≠o")
            return pd.DataFrame()

        if df_insumos is None or df_insumos.empty:
            logger.warning("‚ö†Ô∏è df_insumos vac√≠o, aplicando inferencia heur√≠stica")
            return self._apply_heuristic_types(df_apus.copy())

        df_apus = df_apus.copy()
        df_insumos = df_insumos.copy()

        # Preparar columnas normalizadas
        if ColumnNames.NORMALIZED_DESC not in df_apus.columns:
            df_apus[ColumnNames.NORMALIZED_DESC] = self._prepare_normalized_desc(
                df_apus[ColumnNames.DESCRIPCION_INSUMO]
            )

        if ColumnNames.DESCRIPCION_INSUMO_NORM not in df_insumos.columns:
            df_insumos[ColumnNames.DESCRIPCION_INSUMO_NORM] = normalize_text_series(
                df_insumos.get(ColumnNames.DESCRIPCION_INSUMO, pd.Series(dtype=str))
            )

        # Diagn√≥stico pre-merge
        logger.info(f"üêõ DIAG: df_apus: {len(df_apus)} filas")
        logger.info(f"üêõ DIAG: df_insumos: {len(df_insumos)} filas")
        
        # Ejecutar merge
        try:
            df_merged = pd.merge(
                df_apus,
                df_insumos,
                left_on=ColumnNames.NORMALIZED_DESC,
                right_on=ColumnNames.DESCRIPCION_INSUMO_NORM,
                how="left",
                suffixes=("_apu", "_insumo"),
                indicator=True  # NUEVO: Para diagn√≥stico
            )
        except Exception as e:
            logger.error(f"‚ùå Error en merge: {e}")
            return self._apply_heuristic_types(df_apus)

        # Diagn√≥stico de match
        match_stats = df_merged["_merge"].value_counts()
        logger.info(f"üêõ DIAG: Resultado del merge:\n{match_stats}")
        
        pct_matched = (df_merged["_merge"] == "both").mean() * 100
        logger.info(f"üìä Porcentaje de match: {pct_matched:.1f}%")
        
        if pct_matched < 50:
            logger.warning(f"‚ö†Ô∏è Bajo porcentaje de match ({pct_matched:.1f}%), se usar√° inferencia heur√≠stica")

        # Asignar TIPO_INSUMO
        df_merged = self._assign_tipo_insumo(df_merged)
        
        # Limpiar columna de indicador
        df_merged.drop(columns=["_merge"], errors="ignore", inplace=True)
        
        # Consolidar columnas duplicadas
        df_merged = self._consolidate_columns(df_merged)

        logger.info(f"‚úÖ Merge completado: {len(df_merged)} filas")
        return df_merged

    def _prepare_normalized_desc(self, series: pd.Series) -> pd.Series:
        """Prepara descripciones normalizadas eliminando prefijos."""
        def clean_prefixes(text):
            if pd.isna(text):
                return ""
            text = str(text)
            patterns = r'^(?:M\.?O\.?|MANO\s+DE\s+OBRA|EQUIPO|TRANSPORTE|MATERIAL|SUMINISTRO)\s+'
            return re.sub(patterns, '', text, flags=re.IGNORECASE).strip()
        
        cleaned = series.apply(clean_prefixes)
        return normalize_text_series(cleaned)

    def _assign_tipo_insumo(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Asigna TIPO_INSUMO con estrategia de fallbacks:
        1. GRUPO_INSUMO del maestro (si cruz√≥)
        2. CATEGORIA del APU (fallback)
        3. Inferencia heur√≠stica desde descripci√≥n
        4. Default: OTRO
        """
        df = df.copy()
        
        # Inicializar columna
        df[ColumnNames.TIPO_INSUMO] = None
        
        # 1. Desde GRUPO_INSUMO (registros que cruzaron)
        if ColumnNames.GRUPO_INSUMO in df.columns:
            df[ColumnNames.TIPO_INSUMO] = (
                df[ColumnNames.GRUPO_INSUMO]
                .astype(str)
                .str.strip()
                .str.upper()
                .map(self._group_to_tipo)
            )
            
            assigned_from_grupo = df[ColumnNames.TIPO_INSUMO].notna().sum()
            logger.info(f"üìä Asignados desde GRUPO_INSUMO: {assigned_from_grupo}")
        
        # 2. Fallback a CATEGORIA
        mask_sin_tipo = df[ColumnNames.TIPO_INSUMO].isna()
        if mask_sin_tipo.any() and ColumnNames.CATEGORIA in df.columns:
            df.loc[mask_sin_tipo, ColumnNames.TIPO_INSUMO] = (
                df.loc[mask_sin_tipo, ColumnNames.CATEGORIA]
                .astype(str)
                .str.strip()
                .str.upper()
                .map(self._group_to_tipo)
            )
            
            assigned_from_cat = (
                mask_sin_tipo.sum() - df[ColumnNames.TIPO_INSUMO].isna().sum()
            )
            logger.info(f"üìä Asignados desde CATEGORIA: {assigned_from_cat}")
        
        # 3. Inferencia heur√≠stica
        mask_sin_tipo = df[ColumnNames.TIPO_INSUMO].isna()
        if mask_sin_tipo.any():
            logger.info(f"üîß Aplicando inferencia heur√≠stica a {mask_sin_tipo.sum()} registros")
            df.loc[mask_sin_tipo, ColumnNames.TIPO_INSUMO] = df.loc[
                mask_sin_tipo
            ].apply(self._infer_tipo_from_row, axis=1)
        
        # 4. Default final
        df[ColumnNames.TIPO_INSUMO] = df[ColumnNames.TIPO_INSUMO].fillna(InsumoTypes.OTRO)
        
        # Diagn√≥stico final
        tipo_dist = df[ColumnNames.TIPO_INSUMO].value_counts()
        logger.info(f"üìä Distribuci√≥n TIPO_INSUMO final:\n{tipo_dist}")
        
        return df

    def _infer_tipo_from_row(self, row: pd.Series) -> str:
        """Infiere tipo de insumo desde la descripci√≥n."""
        # Buscar descripci√≥n en m√∫ltiples columnas
        desc = None
        for col in [ColumnNames.DESCRIPCION_INSUMO, f"{ColumnNames.DESCRIPCION_INSUMO}_apu",
                    ColumnNames.NORMALIZED_DESC]:
            if col in row.index and pd.notna(row.get(col)):
                desc = str(row[col]).upper()
                break
        
        if not desc:
            return InsumoTypes.OTRO
        
        # Patrones de detecci√≥n
        if re.search(r'\b(OFICIAL|AYUDANTE|PEON|OBRERO|CUADRILLA|M\.?O\.?)\b', desc):
            return InsumoTypes.MANO_DE_OBRA
        elif re.search(r'\b(EQUIPO|HERRAMIENTA|MAQUINA|RETROEXCAVADORA|VOLQUETA)\b', desc):
            return InsumoTypes.EQUIPO
        elif re.search(r'\b(TRANSPORTE|ACARREO|FLETE)\b', desc):
            return InsumoTypes.TRANSPORTE
        else:
            # Por defecto, asumir material (m√°s com√∫n)
            return InsumoTypes.SUMINISTRO

    def _apply_heuristic_types(self, df: pd.DataFrame) -> pd.DataFrame:
        """Aplica inferencia heur√≠stica cuando no hay merge posible."""
        df = df.copy()
        df[ColumnNames.TIPO_INSUMO] = df.apply(self._infer_tipo_from_row, axis=1)
        return df

    def _consolidate_columns(self, df: pd.DataFrame) -> pd.DataFrame:
        """Consolida columnas duplicadas post-merge."""
        df = df.copy()
        
        # Consolidar descripciones
        desc_apu = f"{ColumnNames.DESCRIPCION_INSUMO}_apu"
        desc_insumo = f"{ColumnNames.DESCRIPCION_INSUMO}_insumo"
        
        if desc_insumo in df.columns:
            if ColumnNames.DESCRIPCION_INSUMO not in df.columns:
                df[ColumnNames.DESCRIPCION_INSUMO] = df[desc_insumo].fillna(
                    df.get(desc_apu, "")
                )
            df.drop(columns=[desc_apu, desc_insumo], errors='ignore', inplace=True)
        
        # Consolidar unidades
        unidad_apu = f"{ColumnNames.UNIDAD_INSUMO}_apu"
        unidad_insumo = f"{ColumnNames.UNIDAD_INSUMO}_insumo"
        
        if unidad_apu in df.columns:
            if ColumnNames.UNIDAD_INSUMO not in df.columns:
                df[ColumnNames.UNIDAD_INSUMO] = df.get(unidad_apu)
            df.drop(columns=[unidad_apu, unidad_insumo], errors='ignore', inplace=True)
        
        return df

    def merge_with_presupuesto(
        self, df_presupuesto: pd.DataFrame, df_apu_costos: pd.DataFrame
    ) -> pd.DataFrame:
        """Fusiona presupuesto con costos APU."""
        # (Mismo c√≥digo que antes, sin cambios necesarios)
        ...

### Esto deber√≠a resolver el problema de clasificaci√≥n y mostrar logs como:

üìä Distribuci√≥n TIPO_INSUMO final:
SUMINISTRO       320
MANO_DE_OBRA     180
EQUIPO            84
TRANSPORTE        20
