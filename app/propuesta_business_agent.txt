### 1. _validate_dataframes - Validaci√≥n Robusta con Tipado Estructural

def _validate_dataframes(
    self, df_presupuesto: Optional[pd.DataFrame], df_apus_detail: Optional[pd.DataFrame]
) -> Tuple[bool, str]:
    """
    Validaci√≥n estructural de DataFrames con verificaci√≥n de tipos y dominios.
    
    Implementa:
    1. Verificaci√≥n de existencia y no-vac√≠o
    2. Validaci√≥n de esquema de columnas con mapeo de compatibilidad
    3. Verificaci√≥n de tipos de datos num√©ricos en columnas cr√≠ticas
    4. Detecci√≥n de valores at√≠picos en distribuciones presupuestarias
    
    Args:
        df_presupuesto: DataFrame del presupuesto general.
        df_apus_detail: DataFrame con detalle de APUs mergeado.
        
    Returns:
        Tupla (es_v√°lido, mensaje_de_error) con diagn√≥stico detallado.
    """
    # 1. Existencia b√°sica
    if df_presupuesto is None:
        return False, "DataFrame 'df_presupuesto' no disponible"
    
    if df_apus_detail is None:
        return False, "DataFrame 'df_merged' no disponible"
    
    if df_presupuesto.empty:
        return False, "DataFrame 'df_presupuesto' est√° vac√≠o"
    
    if df_apus_detail.empty:
        return False, "DataFrame 'df_merged' est√° vac√≠o"
    
    # 2. Validaci√≥n de esquema con mapeo algebraico
    # Definir espacios vectoriales de columnas requeridas
    budget_space = {
        ColumnNames.CODIGO_APU: {"type": "categorical", "required": True},
        ColumnNames.DESCRIPCION_APU: {"type": "string", "required": True},
        ColumnNames.VALOR_TOTAL: {"type": "numeric", "required": False, "min": 0}
    }
    
    detail_space = {
        "item_code": {"type": "categorical", "required": True},
        "resource": {"type": "string", "required": True},
        "quantity": {"type": "numeric", "required": True, "min": 0},
        "unit_cost": {"type": "numeric", "required": True, "min": 0}
    }
    
    # Mapeo de compatibilidad hist√≥rica
    legacy_mappings = {
        "item": ColumnNames.CODIGO_APU,
        "descripcion": ColumnNames.DESCRIPCION_APU,
        "total": ColumnNames.VALOR_TOTAL
    }
    
    # Validar espacio presupuestario
    for modern_col, spec in budget_space.items():
        if spec["required"]:
            if modern_col not in df_presupuesto.columns:
                # Buscar en mapeo hist√≥rico
                found = False
                for legacy, modern in legacy_mappings.items():
                    if modern == modern_col and legacy in df_presupuesto.columns:
                        found = True
                        break
                
                if not found:
                    return False, f"Columna requerida '{modern_col}' no encontrada"
    
    # 3. Validaci√≥n de tipos y dominios
    numeric_columns = [col for col, spec in budget_space.items() 
                      if spec.get("type") == "numeric" and col in df_presupuesto.columns]
    
    for col in numeric_columns:
        if col in df_presupuesto.columns:
            # Verificar que sea num√©rico
            if not pd.api.types.is_numeric_dtype(df_presupuesto[col]):
                return False, f"Columna '{col}' debe ser num√©rica"
            
            # Verificar dominio (valores no negativos)
            if spec.get("min") is not None:
                if (df_presupuesto[col] < spec["min"]).any():
                    return False, f"Columna '{col}' contiene valores menores a {spec['min']}"
    
    # 4. Detecci√≥n de anomal√≠as distribucionales
    if ColumnNames.VALOR_TOTAL in df_presupuesto.columns:
        values = df_presupuesto[ColumnNames.VALOR_TOTAL]
        if len(values) > 10:  # Solo si hay suficiente datos
            q1, q3 = values.quantile(0.25), values.quantile(0.75)
            iqr = q3 - q1
            outliers = values[(values < (q1 - 1.5 * iqr)) | (values > (q3 + 1.5 * iqr))]
            if len(outliers) > 0.1 * len(values):  # M√°s del 10% son outliers
                logger.warning(f"Presupuesto contiene {len(outliers)} valores at√≠picos significativos")
    
    return True, "Validaci√≥n estructural exitosa"


### 2. _build_topological_model - Con Verificaci√≥n de Homolog√≠a


def _build_topological_model(
    self, df_presupuesto: pd.DataFrame, df_apus_detail: pd.DataFrame
) -> TopologicalMetricsBundle:
    """
    Construye el modelo topol√≥gico con verificaci√≥n de homolog√≠a persistente.
    
    Teorema: Un presupuesto viable debe tener Œ≤‚ÇÄ = 1 (conexo) y Œ≤‚ÇÅ ‚â§ n/2 
    donde n es el n√∫mero de partidas, para evitar ciclos patol√≥gicos.
    
    Args:
        df_presupuesto: DataFrame del presupuesto.
        df_apus_detail: DataFrame con detalle de APUs.
        
    Returns:
        TopologicalMetricsBundle con m√©tricas validadas.
        
    Raises:
        TopologicalAnomalyError: Si la estructura viola teoremas de viabilidad.
    """
    logger.info("üèóÔ∏è  Construyendo topolog√≠a del presupuesto con verificaci√≥n homol√≥gica...")
    
    try:
        # Construcci√≥n del complejo simplicial
        graph = self.graph_builder.build(df_presupuesto, df_apus_detail)
        
        # Teorema 1: Verificar conectividad
        if not nx.is_connected(graph):
            logger.warning("‚ö†Ô∏è  El grafo presupuestario no es conexo (Œ≤‚ÇÄ > 1)")
            # Esto no es fatal pero afecta la coherencia estructural
        
        # C√°lculo de invariantes algebraicos
        betti_numbers = asdict(self.topological_analyzer.calculate_betti_numbers(graph))
        pyramid_stability = self.topological_analyzer.calculate_pyramid_stability(graph)
        
        # Teorema 2: L√≠mite superior para ciclos
        n_nodes = len(graph.nodes())
        beta_1 = betti_numbers.get("beta_1", 0)
        if beta_1 > n_nodes / 2:
            raise TopologicalAnomalyError(
                f"Demasiados ciclos independientes (Œ≤‚ÇÅ={beta_1} > n/2={n_nodes/2})"
            )
        
        # C√°lculo de homolog√≠a persistente (si est√° disponible)
        persistence = None
        try:
            if hasattr(self.topological_analyzer, 'calculate_persistence'):
                persistence = self.topological_analyzer.calculate_persistence(graph)
                # La vida de caracter√≠sticas debe ser > umbral
                if persistence and len(persistence) > 0:
                    min_lifetime = min(abs(death - birth) for birth, death in persistence)
                    if min_lifetime < 0.1:  # Caracter√≠sticas ef√≠meras
                        logger.warning("Homolog√≠a persistente revela caracter√≠sticas inestables")
        except AttributeError:
            pass
        
        logger.info(
            f"M√©tricas topol√≥gicas: Œ≤‚ÇÄ={betti_numbers.get('beta_0')}, "
            f"Œ≤‚ÇÅ={betti_numbers.get('beta_1')}, Œ®={pyramid_stability:.3f}, "
            f"Conectado={nx.is_connected(graph)}"
        )
        
        return TopologicalMetricsBundle(
            betti_numbers=betti_numbers,
            pyramid_stability=pyramid_stability,
            graph=graph,
            persistence_diagram=persistence
        )
        
    except TopologicalAnomalyError as e:
        logger.error(f"‚ùå Anomal√≠a topol√≥gica detectada: {e}")
        self.telemetry.record_error("business_agent.topology_anomaly", str(e))
        raise
    except Exception as e:
        raise RuntimeError(f"Error construyendo topolog√≠a: {e}") from e


### 3. _perform_financial_analysis - Con Inyecci√≥n Causal Propia


def _perform_financial_analysis(
    self,
    params: FinancialParameters,
    session_context: Dict[str, Any],
    topological_bundle: Optional[TopologicalMetricsBundle] = None,
    thermal_metrics: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Ejecuta an√°lisis financiero con inyecci√≥n causal de topolog√≠a y termodin√°mica.
    
    Implementa la proyecci√≥n: F(T, Œ¶, Œò) ‚Üí D donde:
    - T: Espacio topol√≥gico (Betti, Œ®)
    - Œ¶: Espacio financiero (par√°metros)
    - Œò: Espacio termodin√°mico (T_sys, entrop√≠a)
    - D: Espacio de decisi√≥n (m√©tricas enriquecidas)
    
    Args:
        params: Par√°metros financieros validados.
        session_context: Contexto de la sesi√≥n.
        topological_bundle: Datos topol√≥gicos para condicionamiento causal.
        thermal_metrics: Datos t√©rmicos para ajuste de volatilidad.
        
    Returns:
        Diccionario con m√©tricas financieras enriquecidas causalmente.
        
    Raises:
        FinancialProjectionError: Si la proyecci√≥n MIC falla o es inv√°lida.
    """
    logger.info("ü§ñ Proyectando vector financiero con inyecci√≥n causal...")
    
    # 1. Construir payload enriquecido con causalidad
    payload = {
        "amount": params.initial_investment,
        "std_dev": params.cost_std_dev,
        "time": len(params.cash_flows),
        "cash_flows": list(params.cash_flows),  # ¬°Usar los flujos reales!
        # Inyecci√≥n causal de topolog√≠a
        "topological_conditioning": {
            "structural_coherence": topological_bundle.structural_coherence if topological_bundle else 1.0,
            "beta_1_penalty": topological_bundle.betti_numbers.get("beta_1", 0) * 0.1 if topological_bundle else 0,
            "is_connected": nx.is_connected(topological_bundle.graph) if topological_bundle else True
        } if topological_bundle else {},
        # Inyecci√≥n causal de termodin√°mica
        "thermal_adjustment": {
            "system_temperature": thermal_metrics.get("system_temperature", 0.0) if thermal_metrics else 0.0,
            "volatility_multiplier": 1.0 + (thermal_metrics.get("system_temperature", 0.0) * 0.5) 
            if thermal_metrics else 1.0
        }
    }
    
    # 2. Validaci√≥n de estratos MIC con verificaci√≥n formal
    # Requerir que V_PHYSICS est√© cerrado antes de operar en V_STRATEGY
    validated_strata = session_context.get("validated_strata", set())
    required_strata = {"PHYSICS", "TACTICS"}
    
    missing_strata = required_strata - validated_strata
    if missing_strata:
        error_msg = f"Violaci√≥n de jerarqu√≠a MIC: Estratos {missing_strata} no validados"
        logger.error(f"‚õî {error_msg}")
        raise MICHierarchyViolationError(error_msg)
    
    mic_context = {
        "validated_strata": validated_strata,
        "session_id": session_context.get("session_id", "unknown"),
        "causal_injection": True  # Marcar que hay inyecci√≥n causal
    }
    
    # 3. Proyecci√≥n algebraica con manejo de errores espec√≠fico
    try:
        response = self.mic.project_intent("financial_analysis", payload, mic_context)
        
        if not response.get("success"):
            error = response.get("error", "Error desconocido en MIC")
            error_code = response.get("error_code", "UNKNOWN")
            
            # Clasificaci√≥n de errores MIC
            if error_code == "HIERARCHY_VIOLATION":
                raise MICHierarchyViolationError(f"MIC: {error}")
            elif error_code == "TOOL_UNAVAILABLE":
                raise FinancialToolError(f"Herramienta financiera no disponible: {error}")
            else:
                raise FinancialProjectionError(f"Error en proyecci√≥n financiera: {error}")
        
        results = response["results"]
        
        # 4. Enriquecimiento post-proyecci√≥n con factores estructurales
        if topological_bundle:
            # Ajustar VPN por coherencia estructural
            if "npv" in results:
                structural_factor = topological_bundle.structural_coherence
                results["npv_adjusted"] = results["npv"] * structural_factor
                results["structural_discount"] = 1.0 - structural_factor
            
            # Ajustar riesgo por ciclos topol√≥gicos
            if "var_95" in results:
                cycle_risk = topological_bundle.betti_numbers.get("beta_1", 0) * 0.05
                results["var_95"] = results["var_95"] * (1.0 + cycle_risk)
        
        logger.info(f"‚úÖ Proyecci√≥n financiera completada. VPN: {results.get('npv', 'N/A')}")
        return results
        
    except MICHierarchyViolationError:
        raise
    except FinancialToolError:
        raise
    except Exception as e:
        logger.error(f"‚õî Error inesperado en proyecci√≥n MIC: {e}", exc_info=True)
        raise FinancialProjectionError(f"Fallo catastr√≥fico en proyecci√≥n: {e}") from e


### 4. _compose_enriched_report - Con √Ålgebra de Decisiones

def _compose_enriched_report(
    self,
    topological_bundle: TopologicalMetricsBundle,
    financial_metrics: Dict[str, Any],
    thermal_metrics: Dict[str, Any],
    entropy: float = 0.5,
    exergy: float = 0.6,
) -> ConstructionRiskReport:
    """
    Genera reporte ejecutivo usando √°lgebra de decisiones multicriterio.
    
    Implementa: D = Œ±¬∑T ‚äï Œ≤¬∑F ‚äï Œ≥¬∑Œò donde:
    - T: Vector topol√≥gico (Œ≤‚ÇÄ, Œ≤‚ÇÅ, Œ®, coherencia)
    - F: Vector financiero (VPN, TIR, VaR)
    - Œò: Vector termodin√°mico (T_sys, S, Ex)
    - Œ±,Œ≤,Œ≥: Pesos determinados por reglas de negocio
    - ‚äï: Operador de fusi√≥n con propiedades de homomorfismo
    
    Args:
        topological_bundle: M√©tricas topol√≥gicas.
        financial_metrics: M√©tricas financieras.
        thermal_metrics: M√©tricas t√©rmicas.
        entropy: Entrop√≠a del sistema.
        exergy: Exerg√≠a del presupuesto.
        
    Returns:
        ConstructionRiskReport con √°lgebra de decisiones aplicada.
        
    Raises:
        SynthesisAlgebraError: Si los espacios vectoriales no son compatibles.
    """
    logger.info("üß† Integrando inteligencia con √°lgebra de decisiones...")
    
    # 1. Generar reporte base
    base_report = self.topological_analyzer.generate_executive_report(
        topological_bundle.graph, financial_metrics
    )
    
    if base_report is None:
        raise SynthesisAlgebraError("El espacio topol√≥gico gener√≥ vector nulo")
    
    # 2. Verificar compatibilidad de espacios vectoriales
    # Todos los vectores deben tener dimensi√≥n definida
    topo_vector = np.array([
        topological_bundle.structural_coherence,
        topological_bundle.pyramid_stability,
        1.0 / (topological_bundle.betti_numbers.get("beta_0", 1) + 1e-6),
        1.0 / (topological_bundle.betti_numbers.get("beta_1", 0) + 1e-6)
    ])
    
    # Extraer m√©tricas financieras clave
    financial_keys = ["npv", "irr", "payback_period", "sharpe_ratio"]
    finance_vector = np.array([
        financial_metrics.get(k, 0.0) if isinstance(financial_metrics.get(k), (int, float)) else 0.0
        for k in financial_keys
    ])
    
    # Normalizar dimensiones para √°lgebra
    if len(topo_vector) != len(finance_vector):
        # Proyecci√≥n a dimensi√≥n com√∫n (m√≠nima)
        common_dim = min(len(topo_vector), len(finance_vector))
        topo_vector = topo_vector[:common_dim]
        finance_vector = finance_vector[:common_dim]
    
    # 3. Aplicar √°lgebra de decisiones con pesos
    # Regla: La estructura pesa 40%, finanzas 40%, termo 20%
    alpha, beta, gamma = 0.4, 0.4, 0.2
    
    # Vector termodin√°mico
    thermo_vector = np.array([
        thermal_metrics.get("system_temperature", 0.0),
        1.0 - entropy,  # Neguentrop√≠a
        exergy,
        thermal_metrics.get("heat_capacity", 1.0)
    ])[:common_dim]
    
    # Fusi√≥n lineal con normalizaci√≥n
    topo_norm = topo_vector / (np.linalg.norm(topo_vector) + 1e-6)
    finance_norm = finance_vector / (np.linalg.norm(finance_vector) + 1e-6)
    thermo_norm = thermo_vector / (np.linalg.norm(thermo_vector) + 1e-6)
    
    decision_vector = alpha * topo_norm + beta * finance_norm + gamma * thermo_norm
    decision_magnitude = np.linalg.norm(decision_vector)
    
    # 4. Generar narrativa algebraica
    try:
        strategic_report = self.translator.compose_strategic_narrative(
            topological_metrics=topological_bundle.betti_numbers,
            financial_metrics=financial_metrics,
            stability=topological_bundle.pyramid_stability,
            synergy_risk=base_report.details.get("synergy_risk"),
            spectral=base_report.details.get("spectral_analysis"),
            thermal_metrics=thermal_metrics,
            # Nuevo: Incluir el vector de decisi√≥n
            decision_algebra={
                "vector": decision_vector.tolist(),
                "magnitude": float(decision_magnitude),
                "topo_contribution": float(alpha * np.linalg.norm(topo_norm)),
                "finance_contribution": float(beta * np.linalg.norm(finance_norm)),
                "thermo_contribution": float(gamma * np.linalg.norm(thermo_norm))
            }
        )
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Fallo en narrativa estrat√©gica: {e}, usando narrativa base")
        strategic_report = type('obj', (object,), {
            'raw_narrative': f"Reporte base con integridad {base_report.integrity_score:.2f}"
        })
    
    # 5. Construir reporte enriquecido
    enriched_details = {
        **base_report.details,
        "strategic_narrative": getattr(strategic_report, 'raw_narrative', ''),
        "financial_metrics": financial_metrics,
        "thermal_metrics": thermal_metrics,
        "thermodynamics": {
            "entropy": entropy,
            "exergy": exergy,
            "system_temperature": thermal_metrics.get("system_temperature", 0.0),
            "negentropy": 1.0 - entropy
        },
        "topological_invariants": {
            "betti_numbers": topological_bundle.betti_numbers,
            "pyramid_stability": topological_bundle.pyramid_stability,
            "structural_coherence": topological_bundle.structural_coherence,
            "is_connected": nx.is_connected(topological_bundle.graph)
        },
        "decision_algebra": {
            "vector": decision_vector.tolist(),
            "magnitude": float(decision_magnitude),
            "dimension": common_dim,
            "weights": {"alpha": alpha, "beta": beta, "gamma": gamma}
        }
    }
    
    # 6. Calcular puntuaci√≥n integrada usando el √°lgebra
    # Base: integridad topol√≥gica √ó salud financiera √ó calidad termodin√°mica
    financial_health = min(1.0, max(0.0, 
        (financial_metrics.get("npv", 0) / max(abs(financial_metrics.get("initial_investment", 1)), 1) + 1) / 2
    ))
    
    thermo_quality = min(1.0, max(0.0, 
        (exergy - entropy + 1) / 2  # En [-1, 1] ‚Üí [0, 1]
    ))
    
    integrated_score = (
        base_report.integrity_score * financial_health * thermo_quality
    ) ** (1/3)  # Media geom√©trica
    
    report = ConstructionRiskReport(
        integrity_score=float(integrated_score),
        waste_alerts=base_report.waste_alerts,
        circular_risks=base_report.circular_risks,
        complexity_level=base_report.complexity_level,
        financial_risk_level=base_report.financial_risk_level,
        details=enriched_details,
        strategic_narrative=getattr(strategic_report, 'raw_narrative', ''),
    )
    
    # 7. Aplicar auditor√≠a adversarial rigurosa
    audited_report = self.risk_challenger.challenge_verdict(report)
    
    # A√±adir verificaci√≥n de coherencia algebraica
    if not np.isfinite(integrated_score):
        logger.error("‚ùå Puntuaci√≥n integrada no es finita")
        self.telemetry.record_error("business_agent.non_finite_score", 
                                   f"Score: {integrated_score}")
    
    return audited_report


### 5. Clases de Excepci√≥n Especializadas (A√±adir al m√≥dulo)

class TopologicalAnomalyError(Exception):
    """Excepci√≥n para anomal√≠as en la estructura topol√≥gica."""
    pass

class MICHierarchyViolationError(Exception):
    """Excepci√≥n para violaciones de la jerarqu√≠a MIC."""
    pass

class FinancialProjectionError(Exception):
    """Excepci√≥n para errores en proyecci√≥n financiera."""
    pass

class FinancialToolError(Exception):
    """Excepci√≥n para herramientas financieras no disponibles."""
    pass

class SynthesisAlgebraError(Exception):
    """Excepci√≥n para errores en √°lgebra de s√≠ntesis."""
    pass