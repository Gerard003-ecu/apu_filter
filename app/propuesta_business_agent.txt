# -*- coding: utf-8 -*-
"""
Agente de Inteligencia de Negocio.

Este agente orquesta la evaluaci√≥n de viabilidad y riesgos de proyectos
desde una perspectiva de negocio, integrando an√°lisis topol√≥gico algebraico
(estructura del presupuesto como complejo simplicial) y financiero
(costos, riesgos, opciones reales).

La coherencia del an√°lisis se garantiza mediante invariantes topol√≥gicos
que verifican la consistencia estructural del modelo de negocio:
- N√∫meros de Betti (Œ≤‚ÇÄ, Œ≤‚ÇÅ, Œ≤‚ÇÇ) para caracterizar la conectividad
- Caracter√≠stica de Euler œá = Œ≤‚ÇÄ - Œ≤‚ÇÅ + Œ≤‚ÇÇ como invariante fundamental
- Estabilidad piramidal para jerarqu√≠as de costos
"""

from __future__ import annotations

import logging
import time
from contextlib import contextmanager
from dataclasses import dataclass, field
from enum import Enum, auto
from functools import cached_property
from typing import (
    Any,
    Dict,
    Final,
    Generator,
    List,
    Optional,
    Tuple,
    TypeAlias,
)

import pandas as pd

from agent.business_topology import (
    BudgetGraphBuilder,
    BusinessTopologicalAnalyzer,
    ConstructionRiskReport,
)
from app.financial_engine import FinancialConfig, FinancialEngine
from app.semantic_translator import SemanticTranslator
from app.telemetry import TelemetryContext


logger = logging.getLogger(__name__)


# =============================================================================
# CONSTANTES Y TIPOS
# =============================================================================

# Tipo para el grafo de presupuesto (ajustar seg√∫n implementaci√≥n real)
BudgetGraph: TypeAlias = Any

# Constantes de configuraci√≥n con sem√°ntica clara
class DefaultParams:
    """Par√°metros por defecto con documentaci√≥n expl√≠cita."""
    
    INITIAL_INVESTMENT: Final[float] = 1_000_000.0
    """Inversi√≥n inicial de referencia en unidades monetarias."""
    
    CASH_FLOW_PERIODS: Final[int] = 5
    """N√∫mero de per√≠odos para proyecci√≥n de flujos de caja."""
    
    CASH_FLOW_RATIO: Final[float] = 0.30
    """Ratio de retorno por per√≠odo respecto a inversi√≥n inicial."""
    
    COST_STD_DEV_RATIO: Final[float] = 0.15
    """Coeficiente de variaci√≥n (œÉ/Œº) para incertidumbre de costos."""
    
    PROJECT_VOLATILITY: Final[float] = 0.20
    """Volatilidad anualizada del proyecto para opciones reales."""
    
    MIN_COHERENCE_THRESHOLD: Final[float] = 0.70
    """Umbral m√≠nimo de coherencia topol√≥gica aceptable."""


# =============================================================================
# EXCEPCIONES ESPEC√çFICAS
# =============================================================================

class BusinessAgentError(Exception):
    """Excepci√≥n base para errores del BusinessAgent."""
    
    def __init__(self, message: str, phase: Optional[str] = None) -> None:
        self.phase = phase
        super().__init__(f"[{phase}] {message}" if phase else message)


class DataValidationError(BusinessAgentError):
    """Error de validaci√≥n de datos de entrada."""
    pass


class TopologicalCoherenceError(BusinessAgentError):
    """
    Error cuando las m√©tricas topol√≥gicas violan invariantes fundamentales.
    
    En topolog√≠a algebraica, ciertos invariantes deben satisfacerse:
    - Œ≤‚ÇÄ ‚â• 1 (al menos un componente conexo)
    - Œ≤·µ¢ ‚â• 0 para todo i
    - Consistencia de la caracter√≠stica de Euler
    """
    pass


class FinancialAnalysisError(BusinessAgentError):
    """Error en el an√°lisis financiero."""
    pass


# =============================================================================
# ENUMERACIONES
# =============================================================================

class EvaluationPhase(Enum):
    """Fases del pipeline de evaluaci√≥n con orden definido."""
    
    VALIDATION = auto()
    TOPOLOGY_CONSTRUCTION = auto()
    TOPOLOGICAL_ANALYSIS = auto()
    FINANCIAL_ANALYSIS = auto()
    REPORT_SYNTHESIS = auto()
    NARRATIVE_COMPOSITION = auto()
    
    @property
    def emoji(self) -> str:
        """Emoji descriptivo para logging."""
        emojis = {
            self.VALIDATION: "üîç",
            self.TOPOLOGY_CONSTRUCTION: "üèóÔ∏è",
            self.TOPOLOGICAL_ANALYSIS: "üî¨",
            self.FINANCIAL_ANALYSIS: "üí∞",
            self.REPORT_SYNTHESIS: "üìä",
            self.NARRATIVE_COMPOSITION: "üß†",
        }
        return emojis.get(self, "‚öôÔ∏è")


# =============================================================================
# DATACLASSES INMUTABLES
# =============================================================================

@dataclass(frozen=True, slots=True)
class EvaluationConfig:
    """
    Configuraci√≥n inmutable para la evaluaci√≥n de proyectos.
    
    Los par√°metros est√°n validados en construcci√≥n para garantizar
    consistencia durante toda la ejecuci√≥n.
    
    Attributes:
        default_initial_investment: Inversi√≥n inicial por defecto
        cash_flow_periods: N√∫mero de per√≠odos de flujo de caja
        cash_flow_ratio: Ratio de retorno por per√≠odo
        cost_std_dev_ratio: Ratio de desviaci√≥n est√°ndar de costos
        project_volatility: Volatilidad del proyecto
        enable_topological_validation: Habilitar validaci√≥n de invariantes
        min_coherence_threshold: Umbral m√≠nimo de coherencia
    """
    
    default_initial_investment: float = DefaultParams.INITIAL_INVESTMENT
    cash_flow_periods: int = DefaultParams.CASH_FLOW_PERIODS
    cash_flow_ratio: float = DefaultParams.CASH_FLOW_RATIO
    cost_std_dev_ratio: float = DefaultParams.COST_STD_DEV_RATIO
    project_volatility: float = DefaultParams.PROJECT_VOLATILITY
    enable_topological_validation: bool = True
    min_coherence_threshold: float = DefaultParams.MIN_COHERENCE_THRESHOLD
    
    def __post_init__(self) -> None:
        """Valida invariantes de configuraci√≥n."""
        validations = [
            (self.default_initial_investment > 0, 
             "La inversi√≥n inicial debe ser positiva"),
            (self.cash_flow_periods >= 1, 
             "Debe haber al menos un per√≠odo de flujo de caja"),
            (0 < self.cash_flow_ratio <= 1, 
             "El ratio de flujo debe estar en (0, 1]"),
            (0 < self.cost_std_dev_ratio < 1, 
             "El ratio de desviaci√≥n debe estar en (0, 1)"),
            (0 < self.project_volatility < 1, 
             "La volatilidad debe estar en (0, 1)"),
            (0 <= self.min_coherence_threshold <= 1, 
             "El umbral de coherencia debe estar en [0, 1]"),
        ]
        
        for condition, message in validations:
            if not condition:
                raise ValueError(message)


@dataclass(frozen=True, slots=True)
class TopologicalMetrics:
    """
    M√©tricas topol√≥gicas del an√°lisis de presupuesto.
    
    Desde la perspectiva de topolog√≠a algebraica, los n√∫meros de Betti
    caracterizan los "agujeros" en diferentes dimensiones:
    
    - Œ≤‚ÇÄ: Componentes conexas (clusters de costos independientes)
    - Œ≤‚ÇÅ: Ciclos independientes (dependencias circulares en el presupuesto)
    - Œ≤‚ÇÇ: Cavidades (estructuras 3D de interdependencia compleja)
    
    La caracter√≠stica de Euler œá = Œ≤‚ÇÄ - Œ≤‚ÇÅ + Œ≤‚ÇÇ es un invariante
    topol√≥gico fundamental que debe ser consistente.
    
    Attributes:
        betti_0: N√∫mero de componentes conexas (Œ≤‚ÇÄ ‚â• 1)
        betti_1: N√∫mero de 1-ciclos independientes (Œ≤‚ÇÅ ‚â• 0)
        betti_2: N√∫mero de 2-ciclos/cavidades (Œ≤‚ÇÇ ‚â• 0)
        pyramid_stability: Estabilidad de la jerarqu√≠a [0, 1]
        graph_density: Densidad del grafo [0, 1]
    """
    
    betti_0: int
    betti_1: int
    betti_2: int
    pyramid_stability: float
    graph_density: float = 0.0
    
    def __post_init__(self) -> None:
        """Valida invariantes topol√≥gicos fundamentales."""
        if self.betti_0 < 1:
            raise TopologicalCoherenceError(
                f"Œ≤‚ÇÄ debe ser ‚â• 1 (al menos un componente): {self.betti_0}",
                phase="TopologicalMetrics"
            )
        if self.betti_1 < 0 or self.betti_2 < 0:
            raise TopologicalCoherenceError(
                f"Los n√∫meros de Betti deben ser no negativos: "
                f"Œ≤‚ÇÅ={self.betti_1}, Œ≤‚ÇÇ={self.betti_2}",
                phase="TopologicalMetrics"
            )
    
    @cached_property
    def euler_characteristic(self) -> int:
        """
        Calcula la caracter√≠stica de Euler.
        
        œá = Œ≤‚ÇÄ - Œ≤‚ÇÅ + Œ≤‚ÇÇ
        
        Este invariante topol√≥gico es fundamental para verificar
        la consistencia del an√°lisis estructural.
        """
        return self.betti_0 - self.betti_1 + self.betti_2
    
    @cached_property
    def coherence_score(self) -> float:
        """
        Calcula el score de coherencia estructural.
        
        Un presupuesto bien estructurado exhibe:
        - Alto Œ≤‚ÇÄ: Componentes bien definidos y separados
        - Bajo Œ≤‚ÇÅ: M√≠nimas dependencias circulares
        - Alta estabilidad: Jerarqu√≠a piramidal robusta
        
        La f√≥rmula pondera estos factores seg√∫n su impacto
        en la calidad estructural del presupuesto.
        
        Returns:
            Score normalizado en [0, 1]
        """
        # Factor de penalizaci√≥n por ciclos (dependencias circulares)
        # Decae exponencialmente con Œ≤‚ÇÅ
        cycle_penalty_factor = 1.0 / (1.0 + self.betti_1)
        
        # Factor de conectividad normalizado
        # Asume que 10 componentes es un m√°ximo razonable
        connectivity_factor = min(1.0, self.betti_0 / 10.0)
        
        # Ponderaci√≥n: estabilidad (50%), ciclos (30%), conectividad (20%)
        score = (
            self.pyramid_stability * 0.50 +
            cycle_penalty_factor * 0.30 +
            connectivity_factor * 0.20
        )
        
        return round(score, 4)
    
    def to_dict(self) -> Dict[str, Any]:
        """Serializa las m√©tricas a diccionario."""
        return {
            "betti_0": self.betti_0,
            "betti_1": self.betti_1,
            "betti_2": self.betti_2,
            "euler_characteristic": self.euler_characteristic,
            "pyramid_stability": self.pyramid_stability,
            "graph_density": self.graph_density,
            "coherence_score": self.coherence_score,
        }


@dataclass(slots=True)
class EvaluationContext:
    """
    Contexto mutable para el proceso de evaluaci√≥n.
    
    Encapsula todos los datos necesarios para ejecutar
    el pipeline de evaluaci√≥n completo.
    """
    
    df_presupuesto: pd.DataFrame
    df_apus_detail: pd.DataFrame
    initial_investment: float
    cash_flows: List[float]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def validate(self) -> None:
        """
        Valida la integridad y consistencia del contexto.
        
        Raises:
            DataValidationError: Si los datos son inv√°lidos o inconsistentes.
        """
        # Validar DataFrames
        if self.df_presupuesto is None or self.df_presupuesto.empty:
            raise DataValidationError(
                "DataFrame de presupuesto vac√≠o o nulo",
                phase="Validation"
            )
        
        if self.df_apus_detail is None or self.df_apus_detail.empty:
            raise DataValidationError(
                "DataFrame de APUs vac√≠o o nulo",
                phase="Validation"
            )
        
        # Validar par√°metros financieros
        if self.initial_investment <= 0:
            raise DataValidationError(
                f"Inversi√≥n inicial debe ser positiva: {self.initial_investment}",
                phase="Validation"
            )
        
        if not self.cash_flows:
            raise DataValidationError(
                "Lista de flujos de caja vac√≠a",
                phase="Validation"
            )
        
        if any(cf < 0 for cf in self.cash_flows):
            raise DataValidationError(
                "Los flujos de caja no pueden ser negativos",
                phase="Validation"
            )


@dataclass(frozen=True, slots=True)
class PhaseResult:
    """Resultado de una fase de evaluaci√≥n con m√©tricas."""
    
    phase: EvaluationPhase
    duration_ms: float
    success: bool
    data: Any = None
    error: Optional[str] = None


# =============================================================================
# AGENTE PRINCIPAL
# =============================================================================

class BusinessAgent:
    """
    Orquesta la inteligencia de negocio para evaluar proyectos de construcci√≥n.
    
    Este agente integra an√°lisis topol√≥gico algebraico con m√©tricas financieras
    para proporcionar una evaluaci√≥n hol√≠stica del riesgo y viabilidad.
    
    La coherencia del an√°lisis se garantiza mediante:
    
    1. **Invariantes Topol√≥gicos**: Validaci√≥n de n√∫meros de Betti y œá
    2. **Consistencia Estructural**: Verificaci√≥n de jerarqu√≠as de costos
    3. **Integraci√≥n Sem√°ntica**: Narrativas estrat√©gicas coherentes
    
    Attributes:
        config: Configuraci√≥n global de la aplicaci√≥n
        eval_config: Configuraci√≥n espec√≠fica de evaluaci√≥n
        telemetry: Contexto para telemetr√≠a y m√©tricas
    
    Example:
        >>> config = {"financial_config": {"discount_rate": 0.10}}
        >>> agent = BusinessAgent(config)
        >>> context = {
        ...     "df_presupuesto": df_budget,
        ...     "df_merged": df_apus,
        ...     "initial_investment": 2_000_000.0
        ... }
        >>> report = agent.evaluate_project(context)
        >>> if report:
        ...     print(f"Riesgo: {report.risk_level}")
        ...     print(f"Coherencia: {report.details['coherence_score']:.2%}")
    """

    __slots__ = (
        "config",
        "eval_config", 
        "telemetry",
        "_graph_builder",
        "_topological_analyzer",
        "_translator",
        "_financial_engine",
        "_phase_results",
    )

    def __init__(
        self,
        config: Dict[str, Any],
        telemetry: Optional[TelemetryContext] = None,
        eval_config: Optional[EvaluationConfig] = None,
    ) -> None:
        """
        Inicializa el agente de negocio.

        Args:
            config: Configuraci√≥n global de la aplicaci√≥n.
            telemetry: Contexto para telemetr√≠a (usa default si None).
            eval_config: Configuraci√≥n de evaluaci√≥n (usa default si None).
            
        Raises:
            ValueError: Si la configuraci√≥n es inv√°lida.
            TypeError: Si los tipos de argumentos son incorrectos.
        """
        self._validate_init_params(config, telemetry, eval_config)
        
        self.config = config
        self.telemetry = telemetry or TelemetryContext()
        self.eval_config = eval_config or self._build_eval_config(config)
        
        # Componentes con inicializaci√≥n diferida (lazy)
        self._graph_builder: Optional[BudgetGraphBuilder] = None
        self._topological_analyzer: Optional[BusinessTopologicalAnalyzer] = None
        self._translator: Optional[SemanticTranslator] = None
        self._financial_engine: Optional[FinancialEngine] = None
        
        # Historial de resultados por fase
        self._phase_results: List[PhaseResult] = []

    @staticmethod
    def _validate_init_params(
        config: Dict[str, Any],
        telemetry: Optional[TelemetryContext],
        eval_config: Optional[EvaluationConfig],
    ) -> None:
        """Valida los par√°metros de inicializaci√≥n."""
        if not isinstance(config, dict):
            raise TypeError(
                f"config debe ser dict, recibido: {type(config).__name__}"
            )
        if telemetry is not None and not isinstance(telemetry, TelemetryContext):
            raise TypeError(
                f"telemetry debe ser TelemetryContext o None, "
                f"recibido: {type(telemetry).__name__}"
            )
        if eval_config is not None and not isinstance(eval_config, EvaluationConfig):
            raise TypeError(
                f"eval_config debe ser EvaluationConfig o None, "
                f"recibido: {type(eval_config).__name__}"
            )

    def _build_eval_config(self, config: Dict[str, Any]) -> EvaluationConfig:
        """Construye EvaluationConfig desde configuraci√≥n global."""
        eval_params = config.get("evaluation_config", {})
        try:
            return EvaluationConfig(**eval_params)
        except (TypeError, ValueError) as e:
            logger.warning(
                f"Configuraci√≥n de evaluaci√≥n inv√°lida, usando defaults: {e}"
            )
            return EvaluationConfig()

    # =========================================================================
    # PROPIEDADES LAZY-LOADED
    # =========================================================================
    
    @property
    def graph_builder(self) -> BudgetGraphBuilder:
        """Constructor de grafos de presupuesto (lazy-loaded)."""
        if self._graph_builder is None:
            self._graph_builder = BudgetGraphBuilder()
        return self._graph_builder

    @property
    def topological_analyzer(self) -> BusinessTopologicalAnalyzer:
        """Analizador topol√≥gico (lazy-loaded)."""
        if self._topological_analyzer is None:
            self._topological_analyzer = BusinessTopologicalAnalyzer(self.telemetry)
        return self._topological_analyzer

    @property
    def translator(self) -> SemanticTranslator:
        """Traductor sem√°ntico (lazy-loaded)."""
        if self._translator is None:
            self._translator = SemanticTranslator()
        return self._translator

    @property
    def financial_engine(self) -> FinancialEngine:
        """Motor financiero (lazy-loaded)."""
        if self._financial_engine is None:
            financial_config_data = self.config.get("financial_config", {})
            financial_config = FinancialConfig(**financial_config_data)
            self._financial_engine = FinancialEngine(financial_config)
        return self._financial_engine

    # =========================================================================
    # CONTEXT MANAGERS Y UTILIDADES
    # =========================================================================
    
    @contextmanager
    def _phase_context(
        self, phase: EvaluationPhase
    ) -> Generator[None, None, None]:
        """
        Context manager para tracking y telemetr√≠a de fases.
        
        Registra autom√°ticamente:
        - Tiempo de ejecuci√≥n
        - Errores ocurridos
        - M√©tricas de telemetr√≠a
        """
        phase_name = phase.name.lower()
        start_time = time.perf_counter()
        
        logger.debug(f"{phase.emoji} Iniciando fase: {phase_name}")
        self.telemetry.start_span(f"business_agent.{phase_name}")
        
        error_occurred: Optional[str] = None
        
        try:
            yield
        except Exception as e:
            error_occurred = str(e)
            self.telemetry.record_error(f"business_agent.{phase_name}", error_occurred)
            raise
        finally:
            elapsed_ms = (time.perf_counter() - start_time) * 1000
            self.telemetry.end_span()
            self.telemetry.record_metric(
                f"phase_{phase_name}_duration_ms", elapsed_ms
            )
            
            # Registrar resultado de fase
            self._phase_results.append(PhaseResult(
                phase=phase,
                duration_ms=elapsed_ms,
                success=error_occurred is None,
                error=error_occurred,
            ))
            
            status = "‚úì" if error_occurred is None else "‚úó"
            logger.debug(
                f"{phase.emoji} Fase {phase_name} [{status}]: {elapsed_ms:.2f}ms"
            )

    def _generate_default_cash_flows(
        self, initial_investment: float
    ) -> List[float]:
        """
        Genera flujos de caja proyectados por defecto.
        
        Utiliza un modelo simplificado de retorno uniforme
        basado en la configuraci√≥n de evaluaci√≥n.
        """
        return [
            initial_investment * self.eval_config.cash_flow_ratio
            for _ in range(self.eval_config.cash_flow_periods)
        ]

    # =========================================================================
    # FASES DEL PIPELINE
    # =========================================================================
    
    def _extract_evaluation_context(
        self, raw_context: Dict[str, Any]
    ) -> EvaluationContext:
        """
        Extrae y valida el contexto de evaluaci√≥n.
        
        Args:
            raw_context: Diccionario con datos del pipeline.
            
        Returns:
            Contexto de evaluaci√≥n validado y normalizado.
            
        Raises:
            DataValidationError: Si los datos requeridos no est√°n disponibles.
        """
        df_presupuesto = raw_context.get("df_presupuesto")
        df_apus_detail = raw_context.get("df_merged")
        
        if df_presupuesto is None:
            raise DataValidationError(
                "DataFrame 'df_presupuesto' no encontrado en contexto",
                phase="Extraction"
            )
        
        if df_apus_detail is None:
            raise DataValidationError(
                "DataFrame 'df_merged' no encontrado en contexto",
                phase="Extraction"
            )
        
        # Obtener o generar par√°metros financieros
        initial_investment = raw_context.get(
            "initial_investment",
            self.eval_config.default_initial_investment
        )
        
        cash_flows = raw_context.get("cash_flows")
        if cash_flows is None:
            cash_flows = self._generate_default_cash_flows(initial_investment)
            logger.info(
                f"Flujos de caja generados autom√°ticamente: "
                f"{len(cash_flows)} per√≠odos"
            )
        
        context = EvaluationContext(
            df_presupuesto=df_presupuesto,
            df_apus_detail=df_apus_detail,
            initial_investment=initial_investment,
            cash_flows=cash_flows,
            metadata=raw_context.get("metadata", {}),
        )
        
        context.validate()
        return context

    def _build_budget_topology(
        self, context: EvaluationContext
    ) -> BudgetGraph:
        """
        Construye el grafo topol√≥gico del presupuesto.
        
        El grafo representa la estructura del presupuesto como un
        complejo simplicial donde:
        - Nodos: Partidas, cap√≠tulos, recursos
        - Aristas: Relaciones de composici√≥n y dependencia
        """
        with self._phase_context(EvaluationPhase.TOPOLOGY_CONSTRUCTION):
            logger.info("Construyendo topolog√≠a del presupuesto...")
            
            graph = self.graph_builder.build(
                context.df_presupuesto,
                context.df_apus_detail
            )
            
            # Validaci√≥n b√°sica del grafo
            if graph is None:
                raise TopologicalCoherenceError(
                    "El constructor de grafos retorn√≥ None",
                    phase="TopologyConstruction"
                )
            
            return graph

    def _analyze_topology(self, graph: BudgetGraph) -> TopologicalMetrics:
        """
        Analiza la topolog√≠a del grafo y extrae invariantes.
        
        Aplica t√©cnicas de topolog√≠a algebraica para caracterizar
        la estructura del presupuesto mediante:
        - N√∫meros de Betti (homolog√≠a)
        - Estabilidad piramidal (jerarqu√≠a)
        - Densidad de conexiones
        
        Args:
            graph: Grafo de presupuesto construido.
            
        Returns:
            M√©tricas topol√≥gicas validadas.
            
        Raises:
            TopologicalCoherenceError: Si los invariantes son inconsistentes.
        """
        with self._phase_context(EvaluationPhase.TOPOLOGICAL_ANALYSIS):
            logger.info("Analizando estructura topol√≥gica...")
            
            # Calcular n√∫meros de Betti
            betti_numbers = self.topological_analyzer.calculate_betti_numbers(graph)
            
            # Calcular estabilidad de la pir√°mide de costos
            pyramid_stability = self.topological_analyzer.calculate_pyramid_stability(
                graph
            )
            
            # Construir m√©tricas (valida en __post_init__)
            metrics = TopologicalMetrics(
                betti_0=betti_numbers.get("betti_0", 1),
                betti_1=betti_numbers.get("betti_1", 0),
                betti_2=betti_numbers.get("betti_2", 0),
                pyramid_stability=pyramid_stability,
                graph_density=betti_numbers.get("density", 0.0),
            )
            
            # Validaci√≥n de coherencia adicional
            self._validate_topological_coherence(metrics)
            
            logger.info(
                f"M√©tricas topol√≥gicas: Œ≤‚ÇÄ={metrics.betti_0}, Œ≤‚ÇÅ={metrics.betti_1}, "
                f"Œ≤‚ÇÇ={metrics.betti_2}, œá={metrics.euler_characteristic}"
            )
            
            return metrics

    def _validate_topological_coherence(
        self, metrics: TopologicalMetrics
    ) -> None:
        """
        Valida la coherencia topol√≥gica seg√∫n invariantes algebraicos.
        
        Verificaciones:
        1. Estabilidad piramidal en rango v√°lido [0, 1]
        2. Score de coherencia sobre umbral m√≠nimo
        3. Consistencia de la caracter√≠stica de Euler
        """
        if not self.eval_config.enable_topological_validation:
            logger.debug("Validaci√≥n topol√≥gica deshabilitada")
            return
        
        # Validar estabilidad piramidal
        if not 0 <= metrics.pyramid_stability <= 1:
            raise TopologicalCoherenceError(
                f"Estabilidad piramidal fuera de rango [0,1]: "
                f"{metrics.pyramid_stability}",
                phase="TopologicalValidation"
            )
        
        # Advertencia si coherencia es baja
        if metrics.coherence_score < self.eval_config.min_coherence_threshold:
            logger.warning(
                f"‚ö†Ô∏è Score de coherencia bajo: {metrics.coherence_score:.2%} "
                f"(umbral: {self.eval_config.min_coherence_threshold:.2%}). "
                f"La estructura del presupuesto puede tener problemas."
            )
            self.telemetry.record_metric("coherence_warning", 1)

    def _perform_financial_analysis(
        self, context: EvaluationContext
    ) -> Dict[str, Any]:
        """
        Ejecuta el an√°lisis financiero completo.
        
        Incluye:
        - VPN (Valor Presente Neto)
        - TIR (Tasa Interna de Retorno)
        - An√°lisis de opciones reales
        - M√©tricas de riesgo (VaR, CVaR)
        """
        with self._phase_context(EvaluationPhase.FINANCIAL_ANALYSIS):
            logger.info("Realizando an√°lisis financiero...")
            
            cost_std_dev = (
                context.initial_investment * 
                self.eval_config.cost_std_dev_ratio
            )
            
            try:
                return self.financial_engine.analyze_project(
                    initial_investment=context.initial_investment,
                    expected_cash_flows=context.cash_flows,
                    cost_std_dev=cost_std_dev,
                    project_volatility=self.eval_config.project_volatility,
                )
            except Exception as e:
                raise FinancialAnalysisError(
                    f"Error en motor financiero: {e}",
                    phase="FinancialAnalysis"
                ) from e

    def _generate_executive_report(
        self,
        graph: BudgetGraph,
        financial_metrics: Dict[str, Any],
    ) -> ConstructionRiskReport:
        """
        Genera el reporte ejecutivo base.
        
        Combina m√©tricas topol√≥gicas y financieras en un
        reporte estructurado para toma de decisiones.
        """
        with self._phase_context(EvaluationPhase.REPORT_SYNTHESIS):
            logger.info("Sintetizando reporte ejecutivo...")
            
            report = self.topological_analyzer.generate_executive_report(
                graph, financial_metrics
            )
            
            if report is None:
                raise BusinessAgentError(
                    "El analizador topol√≥gico retorn√≥ reporte nulo",
                    phase="ReportSynthesis"
                )
            
            return report

    def _enrich_with_strategic_narrative(
        self,
        report: ConstructionRiskReport,
        topo_metrics: TopologicalMetrics,
        financial_metrics: Dict[str, Any],
    ) -> ConstructionRiskReport:
        """
        Enriquece el reporte con narrativa estrat√©gica.
        
        Utiliza el traductor sem√°ntico para generar una
        interpretaci√≥n en lenguaje natural de las m√©tricas
        t√©cnicas, facilitando la comunicaci√≥n con stakeholders.
        """
        with self._phase_context(EvaluationPhase.NARRATIVE_COMPOSITION):
            logger.info("Componiendo narrativa estrat√©gica...")
            
            # Componer narrativa usando m√©tricas serializadas
            strategic_narrative = self.translator.compose_strategic_narrative(
                topo_metrics.to_dict(),
                financial_metrics,
                stability=topo_metrics.pyramid_stability,
            )
            
            # Enriquecer reporte
            report.strategic_narrative = strategic_narrative
            report.details["strategic_narrative"] = strategic_narrative
            report.details["topological_metrics"] = topo_metrics.to_dict()
            report.details["coherence_score"] = topo_metrics.coherence_score
            report.details["euler_characteristic"] = topo_metrics.euler_characteristic
            
            return report

    # =========================================================================
    # M√âTODO PRINCIPAL
    # =========================================================================
    
    def evaluate_project(
        self, context: Dict[str, Any]
    ) -> Optional[ConstructionRiskReport]:
        """
        Ejecuta una evaluaci√≥n completa del proyecto.

        Orquesta el pipeline de evaluaci√≥n en 6 fases:
        
        1. **Validaci√≥n**: Extracci√≥n y validaci√≥n del contexto
        2. **Construcci√≥n Topol√≥gica**: Grafo de presupuesto
        3. **An√°lisis Topol√≥gico**: N√∫meros de Betti, œá, coherencia
        4. **An√°lisis Financiero**: VPN, TIR, opciones reales
        5. **S√≠ntesis de Reporte**: Integraci√≥n de m√©tricas
        6. **Narrativa Estrat√©gica**: Traducci√≥n sem√°ntica

        Args:
            context: Contexto del pipeline. Debe contener:
                - df_presupuesto (pd.DataFrame): Presupuesto
                - df_merged (pd.DataFrame): Detalle de APUs
                
                Opcional:
                - initial_investment (float): Inversi√≥n inicial
                - cash_flows (List[float]): Flujos de caja

        Returns:
            ConstructionRiskReport si exitoso, None en caso de error manejado.

        Raises:
            DataValidationError: Datos de entrada inv√°lidos.
            TopologicalCoherenceError: Invariantes topol√≥gicos violados.
            FinancialAnalysisError: Error en an√°lisis financiero.
        """
        # Limpiar historial de fases anteriores
        self._phase_results.clear()
        total_start = time.perf_counter()
        
        logger.info("ü§ñ Iniciando evaluaci√≥n de negocio del proyecto...")
        
        try:
            # Fase 1: Validaci√≥n y extracci√≥n
            with self._phase_context(EvaluationPhase.VALIDATION):
                eval_context = self._extract_evaluation_context(context)
                logger.info(
                    f"Contexto validado: inversi√≥n={eval_context.initial_investment:,.2f}, "
                    f"per√≠odos={len(eval_context.cash_flows)}"
                )
            
            # Fase 2: Construcci√≥n topol√≥gica
            graph = self._build_budget_topology(eval_context)
            
            # Fase 3: An√°lisis topol√≥gico
            topo_metrics = self._analyze_topology(graph)
            
            # Registrar m√©tricas topol√≥gicas en telemetr√≠a
            self._record_topological_metrics(topo_metrics)
            
            # Fase 4: An√°lisis financiero
            financial_metrics = self._perform_financial_analysis(eval_context)
            
            # Fase 5: Generaci√≥n de reporte
            report = self._generate_executive_report(graph, financial_metrics)
            
            # Fase 6: Enriquecimiento narrativo
            report = self._enrich_with_strategic_narrative(
                report, topo_metrics, financial_metrics
            )
            
            # M√©tricas finales
            total_elapsed = time.perf_counter() - total_start
            self._record_final_metrics(total_elapsed, topo_metrics)
            
            logger.info(
                f"‚úÖ Evaluaci√≥n completada en {total_elapsed:.2f}s | "
                f"Coherencia: {topo_metrics.coherence_score:.1%} | "
                f"œá={topo_metrics.euler_characteristic}"
            )
            
            return report

        except DataValidationError as e:
            logger.warning(f"‚ö†Ô∏è Validaci√≥n fallida: {e}")
            return None

        except TopologicalCoherenceError as e:
            logger.error(f"‚ùå Error de coherencia topol√≥gica: {e}")
            return None

        except FinancialAnalysisError as e:
            logger.error(f"‚ùå Error en an√°lisis financiero: {e}")
            return None

        except Exception as e:
            logger.error(
                f"‚ùå Error inesperado en evaluaci√≥n: {e}",
                exc_info=True
            )
            self.telemetry.record_error("business_agent.unexpected", str(e))
            return None

    def _record_topological_metrics(
        self, metrics: TopologicalMetrics
    ) -> None:
        """Registra m√©tricas topol√≥gicas en telemetr√≠a."""
        self.telemetry.record_metric("betti_0", metrics.betti_0)
        self.telemetry.record_metric("betti_1", metrics.betti_1)
        self.telemetry.record_metric("betti_2", metrics.betti_2)
        self.telemetry.record_metric(
            "euler_characteristic", metrics.euler_characteristic
        )
        self.telemetry.record_metric("coherence_score", metrics.coherence_score)
        self.telemetry.record_metric(
            "pyramid_stability", metrics.pyramid_stability
        )

    def _record_final_metrics(
        self, 
        total_elapsed: float,
        topo_metrics: TopologicalMetrics,
    ) -> None:
        """Registra m√©tricas finales de evaluaci√≥n."""
        self.telemetry.record_metric(
            "total_evaluation_duration_ms", total_elapsed * 1000
        )
        self.telemetry.record_metric("evaluation_success", 1)
        self.telemetry.record_metric(
            "final_coherence_score", topo_metrics.coherence_score
        )

    # =========================================================================
    # DIAGN√ìSTICO Y UTILIDADES
    # =========================================================================
    
    def get_phase_results(self) -> List[PhaseResult]:
        """
        Obtiene los resultados de las fases de la √∫ltima evaluaci√≥n.
        
        Returns:
            Lista de resultados por fase con tiempos y estados.
        """
        return self._phase_results.copy()

    def get_diagnostic_info(self) -> Dict[str, Any]:
        """
        Obtiene informaci√≥n diagn√≥stica del agente.
        
        √ötil para debugging, monitoreo y verificaci√≥n de estado.
        
        Returns:
            Diccionario con informaci√≥n diagn√≥stica completa.
        """
        return {
            "agent_version": "2.0.0",
            "config": {
                "initial_investment": self.eval_config.default_initial_investment,
                "cash_flow_periods": self.eval_config.cash_flow_periods,
                "cash_flow_ratio": self.eval_config.cash_flow_ratio,
                "cost_std_dev_ratio": self.eval_config.cost_std_dev_ratio,
                "project_volatility": self.eval_config.project_volatility,
                "topological_validation": self.eval_config.enable_topological_validation,
                "min_coherence_threshold": self.eval_config.min_coherence_threshold,
            },
            "components_initialized": {
                "graph_builder": self._graph_builder is not None,
                "topological_analyzer": self._topological_analyzer is not None,
                "translator": self._translator is not None,
                "financial_engine": self._financial_engine is not None,
            },
            "last_evaluation": {
                "phases_completed": len(self._phase_results),
                "total_duration_ms": sum(
                    r.duration_ms for r in self._phase_results
                ),
                "all_successful": all(
                    r.success for r in self._phase_results
                ),
            },
        }

    def reset_components(self) -> None:
        """
        Reinicia los componentes lazy-loaded.
        
        √ötil para liberar memoria o forzar reinicializaci√≥n
        despu√©s de cambios de configuraci√≥n.
        """
        self._graph_builder = None
        self._topological_analyzer = None
        self._translator = None
        self._financial_engine = None
        self._phase_results.clear()
        
        logger.info("Componentes del BusinessAgent reiniciados")


### test_business_agent

# -*- coding: utf-8 -*-
"""
Tests para el BusinessAgent con cobertura exhaustiva.

Este m√≥dulo prueba:
- Validaci√≥n de configuraci√≥n e invariantes
- Coherencia topol√≥gica (n√∫meros de Betti, caracter√≠stica de Euler)
- Pipeline de evaluaci√≥n completo
- Manejo de errores espec√≠ficos
- Telemetr√≠a y diagn√≥stico
- Lazy-loading de componentes

Ejecutar con: pytest test_business_agent.py -v --cov=agent.business_agent
"""

import logging
import math
from dataclasses import FrozenInstanceError
from typing import Any, Dict, List, Optional
from unittest.mock import MagicMock, Mock, patch, PropertyMock

import pandas as pd
import pytest
from hypothesis import given, settings, strategies as st, assume

# M√≥dulo bajo prueba
from agent.business_agent import (
    BusinessAgent,
    BusinessAgentError,
    DataValidationError,
    DefaultParams,
    EvaluationConfig,
    EvaluationContext,
    EvaluationPhase,
    FinancialAnalysisError,
    PhaseResult,
    TopologicalCoherenceError,
    TopologicalMetrics,
)


# =============================================================================
# FIXTURES
# =============================================================================

@pytest.fixture
def mock_telemetry():
    """Mock del contexto de telemetr√≠a."""
    telemetry = MagicMock()
    telemetry.start_span = MagicMock()
    telemetry.end_span = MagicMock()
    telemetry.record_metric = MagicMock()
    telemetry.record_error = MagicMock()
    return telemetry


@pytest.fixture
def basic_config() -> Dict[str, Any]:
    """Configuraci√≥n b√°sica v√°lida."""
    return {
        "financial_config": {
            "discount_rate": 0.10,
            "risk_free_rate": 0.03,
        },
        "evaluation_config": {
            "default_initial_investment": 500_000.0,
            "cash_flow_periods": 3,
        },
    }


@pytest.fixture
def sample_df_presupuesto() -> pd.DataFrame:
    """DataFrame de presupuesto de ejemplo."""
    return pd.DataFrame({
        "id": [1, 2, 3, 4, 5],
        "capitulo": ["CAP1", "CAP1", "CAP2", "CAP2", "CAP3"],
        "partida": ["P1.1", "P1.2", "P2.1", "P2.2", "P3.1"],
        "descripcion": [
            "Excavaci√≥n",
            "Cimentaci√≥n",
            "Estructura met√°lica",
            "Soldadura",
            "Acabados",
        ],
        "cantidad": [100.0, 50.0, 200.0, 150.0, 75.0],
        "precio_unitario": [25.0, 100.0, 80.0, 45.0, 60.0],
        "total": [2500.0, 5000.0, 16000.0, 6750.0, 4500.0],
    })


@pytest.fixture
def sample_df_apus() -> pd.DataFrame:
    """DataFrame de APUs de ejemplo."""
    return pd.DataFrame({
        "partida_id": [1, 1, 2, 2, 3, 4, 5],
        "recurso": [
            "Mano de obra",
            "Equipo",
            "Material",
            "Mano de obra",
            "Material",
            "Equipo",
            "Material",
        ],
        "unidad": ["hr", "hr", "m3", "hr", "kg", "hr", "m2"],
        "cantidad": [10.0, 5.0, 25.0, 8.0, 100.0, 12.0, 50.0],
        "precio": [15.0, 30.0, 50.0, 15.0, 8.0, 25.0, 20.0],
    })


@pytest.fixture
def valid_evaluation_context(
    sample_df_presupuesto, sample_df_apus
) -> EvaluationContext:
    """Contexto de evaluaci√≥n v√°lido."""
    return EvaluationContext(
        df_presupuesto=sample_df_presupuesto,
        df_apus_detail=sample_df_apus,
        initial_investment=1_000_000.0,
        cash_flows=[300_000.0, 350_000.0, 400_000.0, 450_000.0, 500_000.0],
    )


@pytest.fixture
def valid_raw_context(sample_df_presupuesto, sample_df_apus) -> Dict[str, Any]:
    """Contexto raw v√°lido para evaluate_project."""
    return {
        "df_presupuesto": sample_df_presupuesto,
        "df_merged": sample_df_apus,
        "initial_investment": 1_500_000.0,
        "cash_flows": [400_000.0, 450_000.0, 500_000.0],
    }


@pytest.fixture
def mock_graph():
    """Mock del grafo de presupuesto."""
    graph = MagicMock()
    graph.number_of_nodes.return_value = 10
    graph.number_of_edges.return_value = 15
    return graph


@pytest.fixture
def mock_construction_risk_report():
    """Mock del reporte de riesgo."""
    report = MagicMock()
    report.risk_level = "MEDIUM"
    report.strategic_narrative = None
    report.details = {}
    return report


@pytest.fixture
def business_agent(basic_config, mock_telemetry) -> BusinessAgent:
    """BusinessAgent configurado para tests."""
    return BusinessAgent(
        config=basic_config,
        telemetry=mock_telemetry,
    )


# =============================================================================
# TESTS DE DefaultParams
# =============================================================================

class TestDefaultParams:
    """Tests para la clase de constantes DefaultParams."""

    def test_initial_investment_positive(self):
        """La inversi√≥n inicial por defecto debe ser positiva."""
        assert DefaultParams.INITIAL_INVESTMENT > 0

    def test_cash_flow_periods_at_least_one(self):
        """Debe haber al menos un per√≠odo de flujo de caja."""
        assert DefaultParams.CASH_FLOW_PERIODS >= 1

    def test_ratios_in_valid_range(self):
        """Los ratios deben estar en rangos v√°lidos."""
        assert 0 < DefaultParams.CASH_FLOW_RATIO <= 1
        assert 0 < DefaultParams.COST_STD_DEV_RATIO < 1
        assert 0 < DefaultParams.PROJECT_VOLATILITY < 1
        assert 0 <= DefaultParams.MIN_COHERENCE_THRESHOLD <= 1


# =============================================================================
# TESTS DE EvaluationConfig
# =============================================================================

class TestEvaluationConfig:
    """Tests para la configuraci√≥n de evaluaci√≥n."""

    def test_default_initialization(self):
        """Debe inicializarse correctamente con valores por defecto."""
        config = EvaluationConfig()
        
        assert config.default_initial_investment == DefaultParams.INITIAL_INVESTMENT
        assert config.cash_flow_periods == DefaultParams.CASH_FLOW_PERIODS
        assert config.cash_flow_ratio == DefaultParams.CASH_FLOW_RATIO
        assert config.enable_topological_validation is True

    def test_custom_initialization(self):
        """Debe aceptar valores personalizados v√°lidos."""
        config = EvaluationConfig(
            default_initial_investment=2_000_000.0,
            cash_flow_periods=10,
            cash_flow_ratio=0.25,
            project_volatility=0.30,
        )
        
        assert config.default_initial_investment == 2_000_000.0
        assert config.cash_flow_periods == 10
        assert config.cash_flow_ratio == 0.25
        assert config.project_volatility == 0.30

    def test_immutability(self):
        """La configuraci√≥n debe ser inmutable (frozen)."""
        config = EvaluationConfig()
        
        with pytest.raises(FrozenInstanceError):
            config.default_initial_investment = 999.0

    @pytest.mark.parametrize("invalid_investment", [0, -1, -1000])
    def test_invalid_initial_investment(self, invalid_investment):
        """Debe rechazar inversi√≥n inicial no positiva."""
        with pytest.raises(ValueError, match="inversi√≥n inicial debe ser positiva"):
            EvaluationConfig(default_initial_investment=invalid_investment)

    @pytest.mark.parametrize("invalid_periods", [0, -1, -5])
    def test_invalid_cash_flow_periods(self, invalid_periods):
        """Debe rechazar per√≠odos de flujo de caja inv√°lidos."""
        with pytest.raises(ValueError, match="al menos un per√≠odo"):
            EvaluationConfig(cash_flow_periods=invalid_periods)

    @pytest.mark.parametrize("invalid_ratio", [0, -0.1, 1.1, 2.0])
    def test_invalid_cash_flow_ratio(self, invalid_ratio):
        """Debe rechazar ratios de flujo de caja fuera de (0, 1]."""
        with pytest.raises(ValueError, match="ratio de flujo"):
            EvaluationConfig(cash_flow_ratio=invalid_ratio)

    @pytest.mark.parametrize("invalid_std", [0, -0.05, 1.0, 1.5])
    def test_invalid_cost_std_dev_ratio(self, invalid_std):
        """Debe rechazar ratios de desviaci√≥n fuera de (0, 1)."""
        with pytest.raises(ValueError, match="ratio de desviaci√≥n"):
            EvaluationConfig(cost_std_dev_ratio=invalid_std)

    @pytest.mark.parametrize("invalid_vol", [0, -0.1, 1.0, 2.0])
    def test_invalid_project_volatility(self, invalid_vol):
        """Debe rechazar volatilidad fuera de (0, 1)."""
        with pytest.raises(ValueError, match="volatilidad"):
            EvaluationConfig(project_volatility=invalid_vol)

    @pytest.mark.parametrize("invalid_threshold", [-0.1, 1.1, 2.0])
    def test_invalid_coherence_threshold(self, invalid_threshold):
        """Debe rechazar umbral de coherencia fuera de [0, 1]."""
        with pytest.raises(ValueError, match="umbral de coherencia"):
            EvaluationConfig(min_coherence_threshold=invalid_threshold)


# =============================================================================
# TESTS DE TopologicalMetrics
# =============================================================================

class TestTopologicalMetrics:
    """Tests para m√©tricas topol√≥gicas e invariantes algebraicos."""

    def test_valid_initialization(self):
        """Debe inicializarse con valores v√°lidos."""
        metrics = TopologicalMetrics(
            betti_0=3,
            betti_1=1,
            betti_2=0,
            pyramid_stability=0.85,
        )
        
        assert metrics.betti_0 == 3
        assert metrics.betti_1 == 1
        assert metrics.betti_2 == 0
        assert metrics.pyramid_stability == 0.85

    def test_euler_characteristic_calculation(self):
        """Debe calcular correctamente œá = Œ≤‚ÇÄ - Œ≤‚ÇÅ + Œ≤‚ÇÇ."""
        metrics = TopologicalMetrics(
            betti_0=5,
            betti_1=3,
            betti_2=1,
            pyramid_stability=0.75,
        )
        
        # œá = 5 - 3 + 1 = 3
        assert metrics.euler_characteristic == 3

    def test_euler_characteristic_cached(self):
        """La caracter√≠stica de Euler debe estar cacheada."""
        metrics = TopologicalMetrics(
            betti_0=2,
            betti_1=1,
            betti_2=0,
            pyramid_stability=0.80,
        )
        
        # Acceder m√∫ltiples veces debe retornar el mismo valor
        chi_1 = metrics.euler_characteristic
        chi_2 = metrics.euler_characteristic
        
        assert chi_1 == chi_2 == 1

    @pytest.mark.parametrize("b0,b1,b2,expected_chi", [
        (1, 0, 0, 1),   # Espacio conexo sin agujeros
        (2, 1, 0, 1),   # Dos componentes con un ciclo
        (1, 2, 1, 0),   # Toro (topolog√≠a de donut)
        (1, 0, 1, 2),   # Esfera S¬≤
        (10, 5, 2, 7),  # Caso complejo
    ])
    def test_euler_characteristic_various_cases(self, b0, b1, b2, expected_chi):
        """Verifica œá para varios casos topol√≥gicos conocidos."""
        metrics = TopologicalMetrics(
            betti_0=b0,
            betti_1=b1,
            betti_2=b2,
            pyramid_stability=0.75,
        )
        
        assert metrics.euler_characteristic == expected_chi

    def test_betti_0_must_be_positive(self):
        """Œ≤‚ÇÄ debe ser al menos 1 (m√≠nimo un componente conexo)."""
        with pytest.raises(TopologicalCoherenceError, match="Œ≤‚ÇÄ debe ser ‚â• 1"):
            TopologicalMetrics(
                betti_0=0,
                betti_1=0,
                betti_2=0,
                pyramid_stability=0.80,
            )

    def test_negative_betti_numbers_rejected(self):
        """Los n√∫meros de Betti deben ser no negativos."""
        with pytest.raises(TopologicalCoherenceError, match="no negativos"):
            TopologicalMetrics(
                betti_0=2,
                betti_1=-1,
                betti_2=0,
                pyramid_stability=0.80,
            )
        
        with pytest.raises(TopologicalCoherenceError, match="no negativos"):
            TopologicalMetrics(
                betti_0=2,
                betti_1=0,
                betti_2=-3,
                pyramid_stability=0.80,
            )

    def test_coherence_score_calculation(self):
        """Debe calcular el score de coherencia correctamente."""
        # Caso ideal: alta estabilidad, sin ciclos
        metrics_ideal = TopologicalMetrics(
            betti_0=5,
            betti_1=0,
            betti_2=0,
            pyramid_stability=1.0,
        )
        
        # Con Œ≤‚ÇÅ=0, cycle_penalty_factor = 1.0
        # connectivity_factor = min(1.0, 5/10) = 0.5
        # score = 1.0*0.5 + 1.0*0.3 + 0.5*0.2 = 0.5 + 0.3 + 0.1 = 0.9
        assert abs(metrics_ideal.coherence_score - 0.9) < 0.01

    def test_coherence_score_penalizes_cycles(self):
        """El score debe penalizar ciclos (Œ≤‚ÇÅ alto)."""
        metrics_no_cycles = TopologicalMetrics(
            betti_0=5,
            betti_1=0,
            betti_2=0,
            pyramid_stability=0.80,
        )
        
        metrics_with_cycles = TopologicalMetrics(
            betti_0=5,
            betti_1=5,
            betti_2=0,
            pyramid_stability=0.80,
        )
        
        assert metrics_no_cycles.coherence_score > metrics_with_cycles.coherence_score

    def test_coherence_score_in_valid_range(self):
        """El score de coherencia debe estar en [0, 1]."""
        metrics = TopologicalMetrics(
            betti_0=1,
            betti_1=10,
            betti_2=5,
            pyramid_stability=0.1,
        )
        
        assert 0 <= metrics.coherence_score <= 1

    def test_to_dict_serialization(self):
        """Debe serializar correctamente a diccionario."""
        metrics = TopologicalMetrics(
            betti_0=3,
            betti_1=2,
            betti_2=1,
            pyramid_stability=0.75,
            graph_density=0.45,
        )
        
        result = metrics.to_dict()
        
        assert result["betti_0"] == 3
        assert result["betti_1"] == 2
        assert result["betti_2"] == 1
        assert result["euler_characteristic"] == 2  # 3 - 2 + 1
        assert result["pyramid_stability"] == 0.75
        assert result["graph_density"] == 0.45
        assert "coherence_score" in result

    def test_immutability(self):
        """Las m√©tricas deben ser inmutables."""
        metrics = TopologicalMetrics(
            betti_0=2,
            betti_1=1,
            betti_2=0,
            pyramid_stability=0.80,
        )
        
        with pytest.raises(FrozenInstanceError):
            metrics.betti_0 = 5

    @given(
        b0=st.integers(min_value=1, max_value=100),
        b1=st.integers(min_value=0, max_value=100),
        b2=st.integers(min_value=0, max_value=100),
        stability=st.floats(min_value=0.0, max_value=1.0, allow_nan=False),
    )
    @settings(max_examples=50)
    def test_euler_characteristic_invariant_property(self, b0, b1, b2, stability):
        """Property-based test: œá siempre debe ser consistente."""
        metrics = TopologicalMetrics(
            betti_0=b0,
            betti_1=b1,
            betti_2=b2,
            pyramid_stability=stability,
        )
        
        # Invariante fundamental
        assert metrics.euler_characteristic == b0 - b1 + b2
        
        # Coherencia debe estar en rango v√°lido
        assert 0 <= metrics.coherence_score <= 1


# =============================================================================
# TESTS DE EvaluationContext
# =============================================================================

class TestEvaluationContext:
    """Tests para el contexto de evaluaci√≥n."""

    def test_valid_context_creation(
        self, sample_df_presupuesto, sample_df_apus
    ):
        """Debe crear contexto v√°lido sin errores."""
        context = EvaluationContext(
            df_presupuesto=sample_df_presupuesto,
            df_apus_detail=sample_df_apus,
            initial_investment=500_000.0,
            cash_flows=[100_000.0, 150_000.0, 200_000.0],
        )
        
        context.validate()  # No debe lanzar excepci√≥n

    def test_empty_presupuesto_rejected(self, sample_df_apus):
        """Debe rechazar DataFrame de presupuesto vac√≠o."""
        context = EvaluationContext(
            df_presupuesto=pd.DataFrame(),
            df_apus_detail=sample_df_apus,
            initial_investment=500_000.0,
            cash_flows=[100_000.0],
        )
        
        with pytest.raises(DataValidationError, match="presupuesto vac√≠o"):
            context.validate()

    def test_none_presupuesto_rejected(self, sample_df_apus):
        """Debe rechazar presupuesto None."""
        context = EvaluationContext(
            df_presupuesto=None,
            df_apus_detail=sample_df_apus,
            initial_investment=500_000.0,
            cash_flows=[100_000.0],
        )
        
        with pytest.raises(DataValidationError, match="presupuesto vac√≠o"):
            context.validate()

    def test_empty_apus_rejected(self, sample_df_presupuesto):
        """Debe rechazar DataFrame de APUs vac√≠o."""
        context = EvaluationContext(
            df_presupuesto=sample_df_presupuesto,
            df_apus_detail=pd.DataFrame(),
            initial_investment=500_000.0,
            cash_flows=[100_000.0],
        )
        
        with pytest.raises(DataValidationError, match="APUs vac√≠o"):
            context.validate()

    def test_zero_investment_rejected(
        self, sample_df_presupuesto, sample_df_apus
    ):
        """Debe rechazar inversi√≥n inicial cero o negativa."""
        context = EvaluationContext(
            df_presupuesto=sample_df_presupuesto,
            df_apus_detail=sample_df_apus,
            initial_investment=0.0,
            cash_flows=[100_000.0],
        )
        
        with pytest.raises(DataValidationError, match="positiva"):
            context.validate()

    def test_empty_cash_flows_rejected(
        self, sample_df_presupuesto, sample_df_apus
    ):
        """Debe rechazar lista de flujos de caja vac√≠a."""
        context = EvaluationContext(
            df_presupuesto=sample_df_presupuesto,
            df_apus_detail=sample_df_apus,
            initial_investment=500_000.0,
            cash_flows=[],
        )
        
        with pytest.raises(DataValidationError, match="flujos de caja vac√≠a"):
            context.validate()

    def test_negative_cash_flows_rejected(
        self, sample_df_presupuesto, sample_df_apus
    ):
        """Debe rechazar flujos de caja negativos."""
        context = EvaluationContext(
            df_presupuesto=sample_df_presupuesto,
            df_apus_detail=sample_df_apus,
            initial_investment=500_000.0,
            cash_flows=[100_000.0, -50_000.0, 200_000.0],
        )
        
        with pytest.raises(DataValidationError, match="no pueden ser negativos"):
            context.validate()


# =============================================================================
# TESTS DE EXCEPCIONES
# =============================================================================

class TestExceptions:
    """Tests para el sistema de excepciones."""

    def test_business_agent_error_with_phase(self):
        """BusinessAgentError debe incluir fase en el mensaje."""
        error = BusinessAgentError("Test error", phase="TestPhase")
        
        assert "TestPhase" in str(error)
        assert "Test error" in str(error)
        assert error.phase == "TestPhase"

    def test_business_agent_error_without_phase(self):
        """BusinessAgentError debe funcionar sin fase."""
        error = BusinessAgentError("Test error")
        
        assert str(error) == "Test error"
        assert error.phase is None

    def test_data_validation_error_inheritance(self):
        """DataValidationError debe heredar de BusinessAgentError."""
        error = DataValidationError("Invalid data", phase="Validation")
        
        assert isinstance(error, BusinessAgentError)
        assert isinstance(error, Exception)

    def test_topological_coherence_error_inheritance(self):
        """TopologicalCoherenceError debe heredar de BusinessAgentError."""
        error = TopologicalCoherenceError("Invalid topology", phase="Analysis")
        
        assert isinstance(error, BusinessAgentError)

    def test_financial_analysis_error_inheritance(self):
        """FinancialAnalysisError debe heredar de BusinessAgentError."""
        error = FinancialAnalysisError("Financial error", phase="Financial")
        
        assert isinstance(error, BusinessAgentError)


# =============================================================================
# TESTS DE EvaluationPhase
# =============================================================================

class TestEvaluationPhase:
    """Tests para las fases de evaluaci√≥n."""

    def test_all_phases_have_emoji(self):
        """Todas las fases deben tener un emoji definido."""
        for phase in EvaluationPhase:
            emoji = phase.emoji
            assert emoji is not None
            assert len(emoji) > 0

    def test_phase_order(self):
        """Las fases deben tener orden definido."""
        phases = list(EvaluationPhase)
        
        assert phases[0] == EvaluationPhase.VALIDATION
        assert phases[-1] == EvaluationPhase.NARRATIVE_COMPOSITION

    def test_phase_count(self):
        """Debe haber exactamente 6 fases."""
        assert len(EvaluationPhase) == 6


# =============================================================================
# TESTS DE PhaseResult
# =============================================================================

class TestPhaseResult:
    """Tests para resultados de fase."""

    def test_successful_phase_result(self):
        """Debe crear resultado exitoso correctamente."""
        result = PhaseResult(
            phase=EvaluationPhase.VALIDATION,
            duration_ms=150.5,
            success=True,
            data={"validated": True},
        )
        
        assert result.success is True
        assert result.error is None
        assert result.duration_ms == 150.5

    def test_failed_phase_result(self):
        """Debe crear resultado fallido correctamente."""
        result = PhaseResult(
            phase=EvaluationPhase.FINANCIAL_ANALYSIS,
            duration_ms=250.0,
            success=False,
            error="Division by zero",
        )
        
        assert result.success is False
        assert result.error == "Division by zero"

    def test_phase_result_immutable(self):
        """Los resultados de fase deben ser inmutables."""
        result = PhaseResult(
            phase=EvaluationPhase.VALIDATION,
            duration_ms=100.0,
            success=True,
        )
        
        with pytest.raises(FrozenInstanceError):
            result.success = False


# =============================================================================
# TESTS DE BusinessAgent - Inicializaci√≥n
# =============================================================================

class TestBusinessAgentInitialization:
    """Tests para la inicializaci√≥n del BusinessAgent."""

    def test_basic_initialization(self, basic_config, mock_telemetry):
        """Debe inicializarse correctamente con configuraci√≥n b√°sica."""
        agent = BusinessAgent(config=basic_config, telemetry=mock_telemetry)
        
        assert agent.config == basic_config
        assert agent.telemetry == mock_telemetry
        assert agent.eval_config is not None

    def test_initialization_without_telemetry(self, basic_config):
        """Debe crear telemetr√≠a por defecto si no se proporciona."""
        with patch('agent.business_agent.TelemetryContext') as MockTelemetry:
            mock_instance = MagicMock()
            MockTelemetry.return_value = mock_instance
            
            agent = BusinessAgent(config=basic_config)
            
            MockTelemetry.assert_called_once()
            assert agent.telemetry == mock_instance

    def test_initialization_with_custom_eval_config(
        self, basic_config, mock_telemetry
    ):
        """Debe aceptar configuraci√≥n de evaluaci√≥n personalizada."""
        custom_config = EvaluationConfig(
            default_initial_investment=3_000_000.0,
            cash_flow_periods=7,
        )
        
        agent = BusinessAgent(
            config=basic_config,
            telemetry=mock_telemetry,
            eval_config=custom_config,
        )
        
        assert agent.eval_config == custom_config
        assert agent.eval_config.default_initial_investment == 3_000_000.0
        assert agent.eval_config.cash_flow_periods == 7

    def test_initialization_with_invalid_config_type(self, mock_telemetry):
        """Debe rechazar config que no sea dict."""
        with pytest.raises(TypeError, match="config debe ser dict"):
            BusinessAgent(config="invalid", telemetry=mock_telemetry)

    def test_initialization_with_invalid_telemetry_type(self, basic_config):
        """Debe rechazar telemetry de tipo incorrecto."""
        with pytest.raises(TypeError, match="telemetry debe ser TelemetryContext"):
            BusinessAgent(config=basic_config, telemetry="invalid")

    def test_initialization_with_invalid_eval_config_type(
        self, basic_config, mock_telemetry
    ):
        """Debe rechazar eval_config de tipo incorrecto."""
        with pytest.raises(TypeError, match="eval_config debe ser EvaluationConfig"):
            BusinessAgent(
                config=basic_config,
                telemetry=mock_telemetry,
                eval_config={"invalid": "dict"},
            )

    def test_components_not_initialized_on_construction(
        self, basic_config, mock_telemetry
    ):
        """Los componentes lazy deben estar en None tras construcci√≥n."""
        agent = BusinessAgent(config=basic_config, telemetry=mock_telemetry)
        
        # Acceder a atributos privados para verificar lazy-loading
        assert agent._graph_builder is None
        assert agent._topological_analyzer is None
        assert agent._translator is None
        assert agent._financial_engine is None


# =============================================================================
# TESTS DE BusinessAgent - Lazy Loading
# =============================================================================

class TestBusinessAgentLazyLoading:
    """Tests para la inicializaci√≥n diferida de componentes."""

    def test_graph_builder_lazy_loading(self, business_agent):
        """El graph_builder debe inicializarse en primer acceso."""
        with patch(
            'agent.business_agent.BudgetGraphBuilder'
        ) as MockBuilder:
            mock_instance = MagicMock()
            MockBuilder.return_value = mock_instance
            
            # Primer acceso - debe crear
            builder = business_agent.graph_builder
            MockBuilder.assert_called_once()
            
            # Segundo acceso - debe reutilizar
            builder_2 = business_agent.graph_builder
            assert MockBuilder.call_count == 1
            assert builder is builder_2

    def test_topological_analyzer_lazy_loading(self, business_agent):
        """El topological_analyzer debe inicializarse en primer acceso."""
        with patch(
            'agent.business_agent.BusinessTopologicalAnalyzer'
        ) as MockAnalyzer:
            mock_instance = MagicMock()
            MockAnalyzer.return_value = mock_instance
            
            analyzer = business_agent.topological_analyzer
            MockAnalyzer.assert_called_once_with(business_agent.telemetry)

    def test_translator_lazy_loading(self, business_agent):
        """El translator debe inicializarse en primer acceso."""
        with patch(
            'agent.business_agent.SemanticTranslator'
        ) as MockTranslator:
            mock_instance = MagicMock()
            MockTranslator.return_value = mock_instance
            
            translator = business_agent.translator
            MockTranslator.assert_called_once()

    def test_financial_engine_lazy_loading(self, business_agent):
        """El financial_engine debe inicializarse en primer acceso."""
        with patch(
            'agent.business_agent.FinancialEngine'
        ) as MockEngine:
            with patch(
                'agent.business_agent.FinancialConfig'
            ) as MockConfig:
                mock_engine = MagicMock()
                MockEngine.return_value = mock_engine
                
                engine = business_agent.financial_engine
                MockConfig.assert_called_once()
                MockEngine.assert_called_once()


# =============================================================================
# TESTS DE BusinessAgent - Extracci√≥n de Contexto
# =============================================================================

class TestBusinessAgentContextExtraction:
    """Tests para la extracci√≥n y validaci√≥n de contexto."""

    def test_extract_valid_context(
        self, business_agent, valid_raw_context
    ):
        """Debe extraer contexto v√°lido correctamente."""
        context = business_agent._extract_evaluation_context(valid_raw_context)
        
        assert context.initial_investment == 1_500_000.0
        assert len(context.cash_flows) == 3
        assert not context.df_presupuesto.empty
        assert not context.df_apus_detail.empty

    def test_extract_context_missing_presupuesto(self, business_agent):
        """Debe fallar si falta df_presupuesto."""
        raw_context = {"df_merged": pd.DataFrame({"a": [1]})}
        
        with pytest.raises(DataValidationError, match="df_presupuesto"):
            business_agent._extract_evaluation_context(raw_context)

    def test_extract_context_missing_apus(self, business_agent, sample_df_presupuesto):
        """Debe fallar si falta df_merged."""
        raw_context = {"df_presupuesto": sample_df_presupuesto}
        
        with pytest.raises(DataValidationError, match="df_merged"):
            business_agent._extract_evaluation_context(raw_context)

    def test_extract_context_uses_default_investment(
        self, business_agent, sample_df_presupuesto, sample_df_apus
    ):
        """Debe usar inversi√≥n por defecto si no se proporciona."""
        raw_context = {
            "df_presupuesto": sample_df_presupuesto,
            "df_merged": sample_df_apus,
        }
        
        context = business_agent._extract_evaluation_context(raw_context)
        
        assert context.initial_investment == \
            business_agent.eval_config.default_initial_investment

    def test_extract_context_generates_default_cash_flows(
        self, business_agent, sample_df_presupuesto, sample_df_apus
    ):
        """Debe generar flujos de caja por defecto si no se proporcionan."""
        raw_context = {
            "df_presupuesto": sample_df_presupuesto,
            "df_merged": sample_df_apus,
            "initial_investment": 1_000_000.0,
        }
        
        context = business_agent._extract_evaluation_context(raw_context)
        
        expected_periods = business_agent.eval_config.cash_flow_periods
        assert len(context.cash_flows) == expected_periods


# =============================================================================
# TESTS DE BusinessAgent - Pipeline Fases
# =============================================================================

class TestBusinessAgentPipelinePhases:
    """Tests para las fases individuales del pipeline."""

    def test_build_budget_topology(
        self, business_agent, valid_evaluation_context, mock_graph
    ):
        """Debe construir la topolog√≠a correctamente."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder:
            mock_builder.build.return_value = mock_graph
            
            graph = business_agent._build_budget_topology(valid_evaluation_context)
            
            mock_builder.build.assert_called_once()
            assert graph == mock_graph

    def test_build_budget_topology_null_graph_error(
        self, business_agent, valid_evaluation_context
    ):
        """Debe lanzar error si el builder retorna None."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder:
            mock_builder.build.return_value = None
            
            with pytest.raises(TopologicalCoherenceError, match="retorn√≥ None"):
                business_agent._build_budget_topology(valid_evaluation_context)

    def test_analyze_topology(self, business_agent, mock_graph):
        """Debe analizar la topolog√≠a y retornar m√©tricas v√°lidas."""
        with patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer:
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 3,
                "betti_1": 1,
                "betti_2": 0,
                "density": 0.5,
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.85
            
            metrics = business_agent._analyze_topology(mock_graph)
            
            assert isinstance(metrics, TopologicalMetrics)
            assert metrics.betti_0 == 3
            assert metrics.betti_1 == 1
            assert metrics.pyramid_stability == 0.85

    def test_perform_financial_analysis(
        self, business_agent, valid_evaluation_context
    ):
        """Debe ejecutar an√°lisis financiero correctamente."""
        expected_metrics = {
            "npv": 250_000.0,
            "irr": 0.15,
            "payback_period": 3.5,
        }
        
        with patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine:
            mock_engine.analyze_project.return_value = expected_metrics
            
            result = business_agent._perform_financial_analysis(
                valid_evaluation_context
            )
            
            assert result == expected_metrics
            mock_engine.analyze_project.assert_called_once()

    def test_perform_financial_analysis_error_handling(
        self, business_agent, valid_evaluation_context
    ):
        """Debe envolver errores del motor financiero."""
        with patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine:
            mock_engine.analyze_project.side_effect = ValueError("Engine error")
            
            with pytest.raises(FinancialAnalysisError, match="Engine error"):
                business_agent._perform_financial_analysis(valid_evaluation_context)


# =============================================================================
# TESTS DE BusinessAgent - Validaci√≥n Topol√≥gica
# =============================================================================

class TestBusinessAgentTopologicalValidation:
    """Tests para la validaci√≥n de coherencia topol√≥gica."""

    def test_validate_valid_metrics(self, business_agent):
        """No debe lanzar error con m√©tricas v√°lidas."""
        metrics = TopologicalMetrics(
            betti_0=5,
            betti_1=1,
            betti_2=0,
            pyramid_stability=0.80,
        )
        
        # No debe lanzar excepci√≥n
        business_agent._validate_topological_coherence(metrics)

    def test_validate_invalid_pyramid_stability(self, business_agent):
        """Debe fallar con estabilidad fuera de rango."""
        # Creamos m√©tricas con estabilidad inv√°lida (fuera de [0,1])
        # Como TopologicalMetrics no valida esto, lo forzamos con un mock
        metrics = MagicMock()
        metrics.pyramid_stability = 1.5
        metrics.coherence_score = 0.80
        
        with pytest.raises(
            TopologicalCoherenceError, 
            match="Estabilidad piramidal fuera de rango"
        ):
            business_agent._validate_topological_coherence(metrics)

    def test_validation_skipped_when_disabled(self, basic_config, mock_telemetry):
        """No debe validar si est√° deshabilitado."""
        eval_config = EvaluationConfig(enable_topological_validation=False)
        
        agent = BusinessAgent(
            config=basic_config,
            telemetry=mock_telemetry,
            eval_config=eval_config,
        )
        
        # M√©tricas con estabilidad inv√°lida
        metrics = MagicMock()
        metrics.pyramid_stability = -0.5  # Inv√°lido
        
        # No debe lanzar error
        agent._validate_topological_coherence(metrics)

    def test_low_coherence_logs_warning(
        self, business_agent, mock_telemetry, caplog
    ):
        """Debe registrar warning cuando coherencia es baja."""
        metrics = TopologicalMetrics(
            betti_0=1,
            betti_1=10,  # Muchos ciclos = baja coherencia
            betti_2=0,
            pyramid_stability=0.30,  # Baja estabilidad
        )
        
        with caplog.at_level(logging.WARNING):
            business_agent._validate_topological_coherence(metrics)
        
        assert "Score de coherencia bajo" in caplog.text
        mock_telemetry.record_metric.assert_any_call("coherence_warning", 1)


# =============================================================================
# TESTS DE BusinessAgent - evaluate_project (Integraci√≥n)
# =============================================================================

class TestBusinessAgentEvaluateProject:
    """Tests de integraci√≥n para evaluate_project."""

    def test_successful_evaluation(
        self,
        business_agent,
        valid_raw_context,
        mock_graph,
        mock_construction_risk_report,
    ):
        """Debe completar evaluaci√≥n exitosamente con datos v√°lidos."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            # Configurar mocks
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 3, "betti_1": 1, "betti_2": 0
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.85
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {"npv": 100_000}
            mock_translator.compose_strategic_narrative.return_value = \
                "Strategic narrative"
            
            result = business_agent.evaluate_project(valid_raw_context)
            
            assert result is not None
            assert result.strategic_narrative == "Strategic narrative"
            assert "coherence_score" in result.details

    def test_evaluation_with_missing_data_returns_none(
        self, business_agent, caplog
    ):
        """Debe retornar None si faltan datos requeridos."""
        invalid_context = {"some_key": "some_value"}
        
        with caplog.at_level(logging.WARNING):
            result = business_agent.evaluate_project(invalid_context)
        
        assert result is None
        assert "Validaci√≥n fallida" in caplog.text

    def test_evaluation_records_phase_results(
        self, business_agent, valid_raw_context, mock_graph, mock_construction_risk_report
    ):
        """Debe registrar resultados de cada fase."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 2, "betti_1": 0, "betti_2": 0
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.90
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            business_agent.evaluate_project(valid_raw_context)
            
            phase_results = business_agent.get_phase_results()
            
            assert len(phase_results) == 6  # Todas las fases
            assert all(r.success for r in phase_results)
            assert all(r.duration_ms >= 0 for r in phase_results)

    def test_evaluation_handles_topology_error(
        self, business_agent, valid_raw_context, caplog
    ):
        """Debe manejar errores de topolog√≠a correctamente."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder:
            mock_builder.build.return_value = None
            
            with caplog.at_level(logging.ERROR):
                result = business_agent.evaluate_project(valid_raw_context)
            
            assert result is None
            assert "coherencia topol√≥gica" in caplog.text

    def test_evaluation_handles_financial_error(
        self, business_agent, valid_raw_context, mock_graph, caplog
    ):
        """Debe manejar errores financieros correctamente."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 2, "betti_1": 0, "betti_2": 0
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.85
            mock_engine.analyze_project.side_effect = RuntimeError("Financial crash")
            
            with caplog.at_level(logging.ERROR):
                result = business_agent.evaluate_project(valid_raw_context)
            
            assert result is None
            assert "an√°lisis financiero" in caplog.text

    def test_evaluation_clears_previous_results(
        self, business_agent, valid_raw_context, mock_graph, mock_construction_risk_report
    ):
        """Debe limpiar resultados de evaluaciones anteriores."""
        # Simular resultado previo
        business_agent._phase_results.append(
            PhaseResult(
                phase=EvaluationPhase.VALIDATION,
                duration_ms=50.0,
                success=True,
            )
        )
        
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 1, "betti_1": 0, "betti_2": 0
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.80
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            business_agent.evaluate_project(valid_raw_context)
            
            # Solo debe haber resultados de la √∫ltima evaluaci√≥n
            assert len(business_agent.get_phase_results()) == 6


# =============================================================================
# TESTS DE BusinessAgent - Diagn√≥stico
# =============================================================================

class TestBusinessAgentDiagnostics:
    """Tests para funciones de diagn√≥stico."""

    def test_get_diagnostic_info(self, business_agent):
        """Debe retornar informaci√≥n diagn√≥stica completa."""
        info = business_agent.get_diagnostic_info()
        
        assert "agent_version" in info
        assert "config" in info
        assert "components_initialized" in info
        assert "last_evaluation" in info
        
        # Verificar estructura de config
        config = info["config"]
        assert "initial_investment" in config
        assert "cash_flow_periods" in config
        assert "topological_validation" in config

    def test_get_diagnostic_info_reflects_component_state(
        self, business_agent
    ):
        """Debe reflejar estado real de componentes."""
        info_before = business_agent.get_diagnostic_info()
        
        # Ning√∫n componente inicializado
        assert not info_before["components_initialized"]["graph_builder"]
        
        # Forzar inicializaci√≥n
        with patch('agent.business_agent.BudgetGraphBuilder'):
            _ = business_agent.graph_builder
        
        info_after = business_agent.get_diagnostic_info()
        assert info_after["components_initialized"]["graph_builder"]

    def test_get_phase_results_returns_copy(self, business_agent):
        """Debe retornar copia de resultados, no referencia."""
        business_agent._phase_results.append(
            PhaseResult(
                phase=EvaluationPhase.VALIDATION,
                duration_ms=100.0,
                success=True,
            )
        )
        
        results = business_agent.get_phase_results()
        results.clear()  # Modificar copia
        
        # Original no afectado
        assert len(business_agent._phase_results) == 1

    def test_reset_components(self, business_agent):
        """Debe resetear todos los componentes lazy."""
        # Forzar inicializaci√≥n
        with patch('agent.business_agent.BudgetGraphBuilder'):
            _ = business_agent.graph_builder
        with patch('agent.business_agent.SemanticTranslator'):
            _ = business_agent.translator
        
        business_agent._phase_results.append(
            PhaseResult(
                phase=EvaluationPhase.VALIDATION,
                duration_ms=50.0,
                success=True,
            )
        )
        
        business_agent.reset_components()
        
        assert business_agent._graph_builder is None
        assert business_agent._topological_analyzer is None
        assert business_agent._translator is None
        assert business_agent._financial_engine is None
        assert len(business_agent._phase_results) == 0


# =============================================================================
# TESTS DE BusinessAgent - Telemetr√≠a
# =============================================================================

class TestBusinessAgentTelemetry:
    """Tests para integraci√≥n con telemetr√≠a."""

    def test_phase_context_records_metrics(
        self, business_agent, mock_telemetry
    ):
        """El context manager debe registrar m√©tricas."""
        with business_agent._phase_context(EvaluationPhase.VALIDATION):
            pass  # Fase vac√≠a
        
        mock_telemetry.start_span.assert_called()
        mock_telemetry.end_span.assert_called()
        mock_telemetry.record_metric.assert_called()

    def test_phase_context_records_error_on_exception(
        self, business_agent, mock_telemetry
    ):
        """Debe registrar error si la fase falla."""
        with pytest.raises(ValueError):
            with business_agent._phase_context(EvaluationPhase.VALIDATION):
                raise ValueError("Test error")
        
        mock_telemetry.record_error.assert_called_once()
        error_call = mock_telemetry.record_error.call_args
        assert "Test error" in str(error_call)

    def test_topological_metrics_recorded(
        self, business_agent, mock_telemetry, valid_raw_context, 
        mock_graph, mock_construction_risk_report
    ):
        """Debe registrar m√©tricas topol√≥gicas en telemetr√≠a."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 3, "betti_1": 2, "betti_2": 1
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.75
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            business_agent.evaluate_project(valid_raw_context)
            
            # Verificar que se registraron m√©tricas topol√≥gicas
            metric_calls = [
                call[0][0] for call in mock_telemetry.record_metric.call_args_list
            ]
            assert "betti_0" in metric_calls
            assert "betti_1" in metric_calls
            assert "euler_characteristic" in metric_calls
            assert "coherence_score" in metric_calls


# =============================================================================
# TESTS DE INTEGRACI√ìN AVANZADOS
# =============================================================================

class TestBusinessAgentIntegration:
    """Tests de integraci√≥n end-to-end."""

    def test_full_pipeline_with_real_dataframes(
        self, sample_df_presupuesto, sample_df_apus
    ):
        """Test de integraci√≥n con DataFrames reales."""
        config = {
            "financial_config": {"discount_rate": 0.08},
            "evaluation_config": {
                "cash_flow_periods": 4,
                "enable_topological_validation": True,
            },
        }
        
        with patch('agent.business_agent.TelemetryContext'), \
             patch('agent.business_agent.BudgetGraphBuilder') as MockBuilder, \
             patch('agent.business_agent.BusinessTopologicalAnalyzer') as MockAnalyzer, \
             patch('agent.business_agent.FinancialEngine') as MockEngine, \
             patch('agent.business_agent.SemanticTranslator') as MockTranslator:
            
            # Configurar mocks
            mock_graph = MagicMock()
            MockBuilder.return_value.build.return_value = mock_graph
            
            MockAnalyzer.return_value.calculate_betti_numbers.return_value = {
                "betti_0": 4, "betti_1": 1, "betti_2": 0, "density": 0.6
            }
            MockAnalyzer.return_value.calculate_pyramid_stability.return_value = 0.88
            
            mock_report = MagicMock()
            mock_report.details = {}
            MockAnalyzer.return_value.generate_executive_report.return_value = mock_report
            
            MockEngine.return_value.analyze_project.return_value = {
                "npv": 150_000.0,
                "irr": 0.12,
            }
            
            MockTranslator.return_value.compose_strategic_narrative.return_value = \
                "El proyecto presenta una estructura s√≥lida."
            
            agent = BusinessAgent(config=config)
            
            context = {
                "df_presupuesto": sample_df_presupuesto,
                "df_merged": sample_df_apus,
                "initial_investment": 750_000.0,
            }
            
            result = agent.evaluate_project(context)
            
            assert result is not None
            assert result.details["coherence_score"] > 0
            assert result.details["euler_characteristic"] == 3  # 4 - 1 + 0

    @pytest.mark.parametrize("b0,b1,b2,expected_chi", [
        (1, 0, 0, 1),
        (3, 2, 1, 2),
        (5, 5, 0, 0),
        (10, 3, 2, 9),
    ])
    def test_euler_characteristic_consistency_in_pipeline(
        self, business_agent, valid_raw_context, mock_graph,
        mock_construction_risk_report, b0, b1, b2, expected_chi
    ):
        """Verifica que œá se calcule consistentemente en todo el pipeline."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": b0, "betti_1": b1, "betti_2": b2
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.75
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            result = business_agent.evaluate_project(valid_raw_context)
            
            assert result.details["euler_characteristic"] == expected_chi


# =============================================================================
# TESTS DE EDGE CASES
# =============================================================================

class TestBusinessAgentEdgeCases:
    """Tests para casos l√≠mite y edge cases."""

    def test_minimal_valid_context(
        self, business_agent, mock_graph, mock_construction_risk_report
    ):
        """Debe funcionar con el contexto m√≠nimo v√°lido."""
        minimal_context = {
            "df_presupuesto": pd.DataFrame({"id": [1], "total": [100.0]}),
            "df_merged": pd.DataFrame({"partida_id": [1]}),
        }
        
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 1, "betti_1": 0, "betti_2": 0
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 1.0
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            result = business_agent.evaluate_project(minimal_context)
            
            assert result is not None

    def test_large_betti_numbers(self, business_agent, mock_graph, mock_construction_risk_report, valid_raw_context):
        """Debe manejar n√∫meros de Betti grandes."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 1000,
                "betti_1": 500,
                "betti_2": 100,
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.50
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            result = business_agent.evaluate_project(valid_raw_context)
            
            assert result is not None
            # œá = 1000 - 500 + 100 = 600
            assert result.details["euler_characteristic"] == 600

    def test_zero_coherence_score_possible(self):
        """El score de coherencia puede ser muy bajo (pero no negativo)."""
        metrics = TopologicalMetrics(
            betti_0=1,  # M√≠nimo
            betti_1=100,  # Muchos ciclos
            betti_2=0,
            pyramid_stability=0.0,  # Sin estabilidad
        )
        
        assert metrics.coherence_score >= 0
        assert metrics.coherence_score < 0.1  # Muy bajo

    def test_concurrent_evaluations_isolation(self, basic_config):
        """Evaluaciones concurrentes no deben interferir."""
        agent1 = BusinessAgent(config=basic_config)
        agent2 = BusinessAgent(config=basic_config)
        
        # Simular resultados diferentes
        agent1._phase_results.append(
            PhaseResult(
                phase=EvaluationPhase.VALIDATION,
                duration_ms=100.0,
                success=True,
            )
        )
        
        # agent2 no debe verse afectado
        assert len(agent2._phase_results) == 0


# =============================================================================
# TESTS DE RENDIMIENTO
# =============================================================================

class TestBusinessAgentPerformance:
    """Tests relacionados con rendimiento y eficiencia."""

    def test_lazy_loading_prevents_unnecessary_initialization(
        self, basic_config, mock_telemetry
    ):
        """Los componentes no usados no deben inicializarse."""
        with patch('agent.business_agent.BudgetGraphBuilder') as MockBuilder, \
             patch('agent.business_agent.BusinessTopologicalAnalyzer') as MockAnalyzer, \
             patch('agent.business_agent.SemanticTranslator') as MockTranslator, \
             patch('agent.business_agent.FinancialEngine') as MockEngine:
            
            agent = BusinessAgent(config=basic_config, telemetry=mock_telemetry)
            
            # Solo crear agente - no acceder a propiedades
            MockBuilder.assert_not_called()
            MockAnalyzer.assert_not_called()
            MockTranslator.assert_not_called()
            MockEngine.assert_not_called()

    def test_phase_durations_recorded(
        self, business_agent, valid_raw_context, mock_graph, mock_construction_risk_report
    ):
        """Las duraciones de fase deben ser positivas y razonables."""
        with patch.object(
            business_agent, 'graph_builder'
        ) as mock_builder, patch.object(
            business_agent, 'topological_analyzer'
        ) as mock_analyzer, patch.object(
            business_agent, 'financial_engine'
        ) as mock_engine, patch.object(
            business_agent, 'translator'
        ) as mock_translator:
            mock_builder.build.return_value = mock_graph
            mock_analyzer.calculate_betti_numbers.return_value = {
                "betti_0": 2, "betti_1": 1, "betti_2": 0
            }
            mock_analyzer.calculate_pyramid_stability.return_value = 0.80
            mock_analyzer.generate_executive_report.return_value = \
                mock_construction_risk_report
            mock_engine.analyze_project.return_value = {}
            mock_translator.compose_strategic_narrative.return_value = ""
            
            business_agent.evaluate_project(valid_raw_context)
            
            results = business_agent.get_phase_results()
            
            for result in results:
                assert result.duration_ms >= 0
                assert result.duration_ms < 10000  # < 10 segundos razonable


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])