1Ô∏è‚É£ ReportParserCrudo - Validaci√≥n Preventiva Robusta

# En app/report_parser_crudo.py

import re
from typing import List, Optional, Dict, Any
from dataclasses import dataclass

@dataclass
class LineValidationResult:
    """Resultado de la validaci√≥n de una l√≠nea."""
    is_valid: bool
    reason: str = ""
    fields_count: int = 0
    has_numeric_fields: bool = False

class ReportParserCrudo:
    
    def __init__(self, config, profile=None):
        self.config = config
        self.profile = profile or {}
        
        # Patrones de validaci√≥n seg√∫n perfil
        self.numeric_pattern = self._build_numeric_pattern()
        
        # Estad√≠sticas detalladas
        self.validation_stats = {
            "total_lines_evaluated": 0,
            "valid_insumos": 0,
            "rejected_insufficient_fields": 0,
            "rejected_no_numeric_data": 0,
            "rejected_empty_key_field": 0,
            "rejected_junk_pattern": 0,
            "rejected_subtotal_line": 0,
        }
    
    def _build_numeric_pattern(self) -> re.Pattern:
        """
        Construye el patr√≥n regex para validar n√∫meros seg√∫n el perfil.
        
        Returns:
            Pattern compilado para validar n√∫meros con el separador decimal correcto.
        """
        decimal_sep = self.profile.get("decimal_separator", "comma")
        
        if decimal_sep == "comma":
            # Acepta: 1.234,56 o 1234,56 o 1,56
            pattern = r'^\d{1,3}(?:\.\d{3})*(?:,\d{1,})?$|^\d+,\d+$|^\d+$'
        else:  # dot
            # Acepta: 1,234.56 o 1234.56 o 1.56
            pattern = r'^\d{1,3}(?:,\d{3})*(?:\.\d{1,})?$|^\d+\.\d+$|^\d+$'
        
        return re.compile(pattern)
    
    def _validate_insumo_line(self, line: str, fields: List[str]) -> LineValidationResult:
        """
        Validaci√≥n estricta de una l√≠nea candidata a insumo.
        
        Esta funci√≥n aplica m√∫ltiples criterios de validaci√≥n para determinar
        si una l√≠nea tiene el formato correcto ANTES de enviarla al parser Lark.
        
        Criterios de validaci√≥n:
        1. N√∫mero m√≠nimo de campos (5)
        2. Campo clave (descripci√≥n) no vac√≠o
        3. Al menos 2 campos con formato num√©rico v√°lido
        4. No es una l√≠nea de subtotal/total
        5. No contiene patrones de "ruido"
        
        Args:
            line: La l√≠nea original completa.
            fields: Los campos ya separados por ";".
        
        Returns:
            LineValidationResult con el resultado de la validaci√≥n.
        """
        # Validaci√≥n 1: N√∫mero m√≠nimo de campos
        if len(fields) < 5:
            return LineValidationResult(
                is_valid=False,
                reason=f"Insuficientes campos: {len(fields)} < 5",
                fields_count=len(fields)
            )
        
        # Validaci√≥n 2: Campo de descripci√≥n (primero) no vac√≠o
        if not fields[0] or not fields[0].strip():
            return LineValidationResult(
                is_valid=False,
                reason="Campo de descripci√≥n vac√≠o",
                fields_count=len(fields)
            )
        
        # Validaci√≥n 3: Detectar l√≠neas de subtotal/total
        line_upper = line.upper()
        subtotal_keywords = [
            "SUBTOTAL", "TOTAL", "SUMA", "SUMATORIA",
            "COSTO DIRECTO", "COSTO TOTAL", "PRECIO TOTAL"
        ]
        
        if any(keyword in line_upper for keyword in subtotal_keywords):
            return LineValidationResult(
                is_valid=False,
                reason="L√≠nea de subtotal/total detectada",
                fields_count=len(fields)
            )
        
        # Validaci√≥n 4: L√≠neas decorativas o separadores
        if self._is_junk_line(line_upper):
            return LineValidationResult(
                is_valid=False,
                reason="L√≠nea decorativa/separador detectada",
                fields_count=len(fields)
            )
        
        # Validaci√≥n 5: CR√çTICA - Al menos 2 campos num√©ricos v√°lidos
        # T√≠picamente: cantidad, precio_unitario, precio_total
        numeric_fields_found = 0
        numeric_positions = []
        
        for idx, field in enumerate(fields[1:], start=1):  # Saltar descripci√≥n
            field_clean = field.strip().replace(" ", "")
            
            if field_clean and self.numeric_pattern.match(field_clean):
                numeric_fields_found += 1
                numeric_positions.append(idx)
        
        if numeric_fields_found < 2:
            return LineValidationResult(
                is_valid=False,
                reason=f"Campos num√©ricos insuficientes: {numeric_fields_found} < 2 (posiciones: {numeric_positions})",
                fields_count=len(fields),
                has_numeric_fields=numeric_fields_found > 0
            )
        
        # ‚úÖ L√≠nea v√°lida
        return LineValidationResult(
            is_valid=True,
            reason="Validaci√≥n exitosa",
            fields_count=len(fields),
            has_numeric_fields=True
        )
    
    def _parse_by_lines(self, lines: List[str]) -> bool:
        """
        M√°quina de estados ROBUSTECIDA que procesa el archivo l√≠nea por l√≠nea.
        
        Mejoras implementadas:
        - Validaci√≥n estricta de l√≠neas de insumo antes de aceptarlas
        - Logging detallado de rechazos para debugging
        - Estad√≠sticas granulares de validaci√≥n
        - Pre-validaci√≥n compatible con la gram√°tica Lark
        
        Args:
            lines: La lista de todas las l√≠neas del archivo.
        
        Returns:
            True si se extrajo al menos un insumo v√°lido, False en caso contrario.
        """
        current_apu_context: Optional[APUContext] = None
        current_category = "INDEFINIDO"
        i = 0

        while i < len(lines):
            line = lines[i].strip()

            if not line:
                i += 1
                continue

            # Estado 1: Buscar un encabezado de APU
            is_header_line = "UNIDAD:" in line.upper()
            is_item_line_next = (i + 1) < len(lines) and "ITEM:" in lines[i + 1].upper()

            if is_header_line and is_item_line_next:
                header_line = line
                item_line = lines[i + 1].strip()

                try:
                    apu_desc = header_line.split(";")[0].strip()
                    unit_match = re.search(r"UNIDAD:\s*(\S+)", header_line, re.IGNORECASE)
                    apu_unit = (
                        unit_match.group(1) if unit_match else self.config.default_unit
                    )

                    item_match = re.search(r"ITEM:\s*([\S,]+)", item_line, re.IGNORECASE)
                    apu_code_raw = (
                        item_match.group(1) if item_match else f"UNKNOWN_APU_{i + 1}"
                    )
                    apu_code = clean_apu_code(apu_code_raw)

                    current_apu_context = APUContext(
                        apu_code=apu_code,
                        apu_desc=apu_desc,
                        apu_unit=apu_unit,
                        source_line=i + 1,
                    )
                    current_category = "INDEFINIDO"
                    self.stats["apus_detected"] += 1
                    logger.info(
                        f"‚úì APU detectado [l√≠nea {i + 1}]: {apu_code} - {apu_desc}"
                    )
                    i += 2
                    continue
                    
                except Exception as e:
                    logger.warning(
                        f"‚úó Fallo al parsear encabezado de APU en l√≠nea {i + 1}: {e}"
                    )
                    current_apu_context = None
                    i += 1
                    continue

            # Estado 2: Procesar l√≠neas dentro de un contexto de APU
            if current_apu_context:
                line_upper = line.upper()

                # Comprobar si es una nueva categor√≠a
                new_category = self._detect_category(line_upper)
                if new_category:
                    current_category = new_category
                    self.stats[f"category_{current_category}"] += 1
                    logger.debug(f"  ‚Üí Categor√≠a detectada: {current_category}")
                    i += 1
                    continue

                # Comprobar si es una l√≠nea de "ruido"
                if self._is_junk_line(line_upper):
                    self.stats["junk_lines_skipped"] += 1
                    i += 1
                    continue

                # üî• VALIDACI√ìN ROBUSTA DE L√çNEA DE INSUMO
                fields = [f.strip() for f in line.split(";")]
                self.validation_stats["total_lines_evaluated"] += 1
                
                validation_result = self._validate_insumo_line(line, fields)
                
                if validation_result.is_valid:
                    # ‚úÖ L√≠nea V√ÅLIDA - Agregar a registros
                    record = {
                        "apu_code": current_apu_context.apu_code,
                        "apu_desc": current_apu_context.apu_desc,
                        "apu_unit": current_apu_context.apu_unit,
                        "category": current_category,
                        "insumo_line": line,
                        "source_line": i + 1,
                        "fields_count": validation_result.fields_count,
                    }
                    self.raw_records.append(record)
                    self.stats["insumos_extracted"] += 1
                    self.validation_stats["valid_insumos"] += 1
                    
                    logger.debug(
                        f"  ‚úì Insumo v√°lido [l√≠nea {i + 1}]: "
                        f"{fields[0][:50]}... ({validation_result.fields_count} campos)"
                    )
                else:
                    # ‚ùå L√≠nea RECHAZADA - Clasificar raz√≥n y registrar
                    if "Insuficientes campos" in validation_result.reason:
                        self.validation_stats["rejected_insufficient_fields"] += 1
                    elif "num√©ricos insuficientes" in validation_result.reason:
                        self.validation_stats["rejected_no_numeric_data"] += 1
                    elif "descripci√≥n vac√≠o" in validation_result.reason:
                        self.validation_stats["rejected_empty_key_field"] += 1
                    elif "subtotal" in validation_result.reason:
                        self.validation_stats["rejected_subtotal_line"] += 1
                    elif "decorativa" in validation_result.reason:
                        self.validation_stats["rejected_junk_pattern"] += 1
                    
                    logger.debug(
                        f"  ‚úó L√≠nea rechazada [l√≠nea {i + 1}]: {validation_result.reason}\n"
                        f"    Contenido: {line[:80]}..."
                    )
                    self.stats["lines_ignored_in_context"] += 1

            i += 1

        # Logging final de estad√≠sticas de validaci√≥n
        self._log_validation_summary()
        
        return self.stats["insumos_extracted"] > 0
    
    def _log_validation_summary(self):
        """Registra un resumen detallado de la validaci√≥n."""
        total_eval = self.validation_stats["total_lines_evaluated"]
        valid = self.validation_stats["valid_insumos"]
        
        if total_eval == 0:
            logger.warning("‚ö†Ô∏è  No se evaluaron l√≠neas para validaci√≥n")
            return
        
        logger.info("=" * 70)
        logger.info("üìä RESUMEN DE VALIDACI√ìN DE L√çNEAS")
        logger.info("=" * 70)
        logger.info(f"Total l√≠neas evaluadas:        {total_eval}")
        logger.info(f"‚úì Insumos v√°lidos:             {valid} ({valid/total_eval*100:.1f}%)")
        logger.info(f"‚úó Rechazados - Campos insuf.:  {self.validation_stats['rejected_insufficient_fields']}")
        logger.info(f"‚úó Rechazados - Sin num√©ricos:  {self.validation_stats['rejected_no_numeric_data']}")
        logger.info(f"‚úó Rechazados - Desc. vac√≠a:    {self.validation_stats['rejected_empty_key_field']}")
        logger.info(f"‚úó Rechazados - Subtotales:     {self.validation_stats['rejected_subtotal_line']}")
        logger.info(f"‚úó Rechazados - Decorativas:    {self.validation_stats['rejected_junk_pattern']}")
        logger.info("=" * 70)
        
        if valid == 0:
            logger.error(
                "üö® CR√çTICO: 0 insumos v√°lidos encontrados. "
                "Revise el formato del archivo o el perfil de configuraci√≥n."
            )


### 2Ô∏è‚É£ APUProcessor - Manejo Inteligente de Errores

# En app/apu_processor.py

from lark.exceptions import LarkError, UnexpectedInput, UnexpectedCharacters
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field

@dataclass
class ParsingStats:
    """Estad√≠sticas detalladas del proceso de parsing."""
    total_lines: int = 0
    successful_parses: int = 0
    lark_parse_errors: int = 0
    lark_unexpected_input: int = 0
    lark_unexpected_chars: int = 0
    transformer_errors: int = 0
    empty_results: int = 0
    fallback_attempts: int = 0
    fallback_successes: int = 0
    failed_lines: List[Dict[str, Any]] = field(default_factory=list)

class APUProcessor:
    
    def __init__(self, config, profile=None):
        self.config = config
        self.profile = profile or {}
        self.parser = self._initialize_parser()
        self.keyword_cache = {}
        
        # Estad√≠sticas de parsing
        self.parsing_stats = ParsingStats()
        
        # Modo debug
        self.debug_mode = self.config.get("debug_mode", False)
    
    def _process_apu_lines(
        self, lines: List[str], apu_context: Dict[str, Any]
    ) -> List[InsumoProcesado]:
        """
        Procesa las l√≠neas de detalle de un √∫nico APU con manejo ROBUSTO de errores.
        
        Mejoras implementadas:
        - Manejo granular de excepciones de Lark
        - Logging detallado con contexto de errores
        - Estad√≠sticas completas de parsing
        - Sistema de fallback documentado
        - Modo debug para investigaci√≥n profunda
        
        Args:
            lines: Lista de cadenas de texto, cada una es una l√≠nea del APU.
            apu_context: El contexto del APU al que pertenecen las l√≠neas.
        
        Returns:
            Una lista de objetos `InsumoProcesado`.
        """
        results = []
        self.parsing_stats = ParsingStats()  # Reset stats por APU
        
        logger.info(
            f"Procesando {len(lines)} l√≠neas para APU: {apu_context.get('apu_code', 'UNKNOWN')}"
        )

        for line_num, line in enumerate(lines, start=1):
            if not line or not line.strip():
                continue
            
            self.parsing_stats.total_lines += 1
            line_clean = line.strip()
            insumo = None

            try:
                if self.parser:
                    # Intentar parsing con Lark
                    try:
                        tree = self.parser.parse(line_clean)
                        
                        # Intentar transformaci√≥n
                        try:
                            transformer = APUTransformer(
                                apu_context, self.config, self.profile, self.keyword_cache
                            )
                            insumo = transformer.transform(tree)
                            
                            # Manejar resultado de tipo lista
                            if isinstance(insumo, list):
                                if insumo:
                                    insumo = insumo[0]
                                    self.parsing_stats.successful_parses += 1
                                else:
                                    self.parsing_stats.empty_results += 1
                                    logger.warning(
                                        f"  ‚ö†Ô∏è  L√≠nea {line_num}: Transformer devolvi√≥ lista vac√≠a"
                                    )
                                    insumo = None
                            else:
                                self.parsing_stats.successful_parses += 1
                        
                        except Exception as transform_error:
                            self.parsing_stats.transformer_errors += 1
                            logger.error(
                                f"  ‚úó L√≠nea {line_num}: Error en transformer\n"
                                f"    Error: {type(transform_error).__name__}: {transform_error}\n"
                                f"    L√≠nea: {line_clean[:100]}"
                            )
                            
                            if self.debug_mode:
                                logger.debug(f"    √Årbol Lark: {tree.pretty()}")
                            
                            # Intentar fallback
                            insumo = self._attempt_fallback(line_clean, apu_context, line_num)
                    
                    except UnexpectedInput as ui_error:
                        self.parsing_stats.lark_unexpected_input += 1
                        self._log_lark_error(
                            "UnexpectedInput", ui_error, line_clean, line_num
                        )
                        insumo = self._attempt_fallback(line_clean, apu_context, line_num)
                    
                    except UnexpectedCharacters as uc_error:
                        self.parsing_stats.lark_unexpected_chars += 1
                        self._log_lark_error(
                            "UnexpectedCharacters", uc_error, line_clean, line_num
                        )
                        insumo = self._attempt_fallback(line_clean, apu_context, line_num)
                    
                    except LarkError as lark_error:
                        self.parsing_stats.lark_parse_errors += 1
                        self._log_lark_error(
                            "LarkError", lark_error, line_clean, line_num
                        )
                        insumo = self._attempt_fallback(line_clean, apu_context, line_num)
                
                else:
                    # No hay parser Lark, usar fallback directo
                    logger.warning("Parser Lark no disponible, usando fallback")
                    insumo = self._process_with_specialists(line_clean, apu_context)

                # Agregar resultado si es v√°lido
                if insumo:
                    insumo.line_number = line_num
                    results.append(insumo)
                else:
                    # Registrar l√≠nea fallida para an√°lisis
                    self.parsing_stats.failed_lines.append({
                        "line_number": line_num,
                        "content": line_clean,
                        "apu_code": apu_context.get("apu_code", "UNKNOWN")
                    })

            except Exception as unexpected_error:
                # Error completamente inesperado
                logger.error(
                    f"  üö® L√≠nea {line_num}: Error inesperado NO capturado\n"
                    f"    Tipo: {type(unexpected_error).__name__}\n"
                    f"    Error: {unexpected_error}\n"
                    f"    L√≠nea: {line_clean}"
                )
                
                self.parsing_stats.failed_lines.append({
                    "line_number": line_num,
                    "content": line_clean,
                    "error": str(unexpected_error),
                    "apu_code": apu_context.get("apu_code", "UNKNOWN")
                })
                
                if self.debug_mode:
                    import traceback
                    logger.debug(f"Traceback completo:\n{traceback.format_exc()}")
                
                continue

        # Log de estad√≠sticas del APU procesado
        self._log_parsing_stats(apu_context.get("apu_code", "UNKNOWN"))
        
        return results
    
    def _log_lark_error(
        self, 
        error_type: str, 
        error: LarkError, 
        line: str, 
        line_num: int
    ):
        """
        Logging detallado y estructurado de errores de Lark.
        
        Args:
            error_type: Tipo de error Lark.
            error: La excepci√≥n de Lark.
            line: La l√≠nea que caus√≥ el error.
            line_num: N√∫mero de l√≠nea.
        """
        logger.warning(
            f"  ‚úó L√≠nea {line_num}: {error_type}\n"
            f"    Error: {error}\n"
            f"    L√≠nea: {line[:100]}{'...' if len(line) > 100 else ''}"
        )
        
        if self.debug_mode and hasattr(error, 'line') and hasattr(error, 'column'):
            logger.debug(
                f"    Posici√≥n del error: l√≠nea {error.line}, columna {error.column}"
            )
            if hasattr(error, 'expected'):
                logger.debug(f"    Esperaba: {error.expected}")
    
    def _attempt_fallback(
        self, 
        line: str, 
        apu_context: Dict[str, Any], 
        line_num: int
    ) -> Optional[InsumoProcesado]:
        """
        Intenta procesar la l√≠nea con el sistema de fallback.
        
        Args:
            line: La l√≠nea a procesar.
            apu_context: Contexto del APU.
            line_num: N√∫mero de l√≠nea.
        
        Returns:
            InsumoProcesado si el fallback tiene √©xito, None en caso contrario.
        """
        self.parsing_stats.fallback_attempts += 1
        
        try:
            insumo = self._process_with_specialists(line, apu_context)
            
            if insumo:
                self.parsing_stats.fallback_successes += 1
                logger.info(f"  ‚úì L√≠nea {line_num}: Fallback exitoso")
                return insumo
            else:
                logger.debug(f"  ‚úó L√≠nea {line_num}: Fallback sin resultado")
                return None
                
        except Exception as fallback_error:
            logger.error(
                f"  ‚úó L√≠nea {line_num}: Fallback fall√≥\n"
                f"    Error: {fallback_error}"
            )
            return None
    
    def _log_parsing_stats(self, apu_code: str):
        """
        Registra estad√≠sticas detalladas del parsing del APU.
        
        Args:
            apu_code: C√≥digo del APU procesado.
        """
        stats = self.parsing_stats
        
        if stats.total_lines == 0:
            return
        
        success_rate = (stats.successful_parses / stats.total_lines * 100) if stats.total_lines > 0 else 0
        
        logger.info("-" * 70)
        logger.info(f"üìà ESTAD√çSTICAS DE PARSING - APU: {apu_code}")
        logger.info("-" * 70)
        logger.info(f"Total l√≠neas procesadas:           {stats.total_lines}")
        logger.info(f"‚úì Parsing exitoso:                 {stats.successful_parses} ({success_rate:.1f}%)")
        logger.info(f"‚úó Errores Lark - Parse:            {stats.lark_parse_errors}")
        logger.info(f"‚úó Errores Lark - Input inesperado: {stats.lark_unexpected_input}")
        logger.info(f"‚úó Errores Lark - Char inesperado:  {stats.lark_unexpected_chars}")
        logger.info(f"‚úó Errores Transformer:             {stats.transformer_errors}")
        logger.info(f"‚ö†Ô∏è  Resultados vac√≠os:              {stats.empty_results}")
        logger.info(f"üîÑ Intentos de fallback:           {stats.fallback_attempts}")
        logger.info(f"‚úì Fallback exitoso:                {stats.fallback_successes}")
        logger.info("-" * 70)
        
        # Alertas cr√≠ticas
        if stats.successful_parses == 0 and stats.total_lines > 0:
            logger.error(
                f"üö® CR√çTICO: APU {apu_code} - 0% de √©xito en parsing. "
                "Posible incompatibilidad entre gram√°tica Lark y formato de datos."
            )
        
        if self.debug_mode and stats.failed_lines:
            logger.debug(f"\nüìã Primeras 5 l√≠neas fallidas:")
            for failed in stats.failed_lines[:5]:
                logger.debug(
                    f"  L√≠nea {failed['line_number']}: {failed['content'][:80]}..."
                )
    
    def _process_with_specialists(
        self, line: str, apu_context: Dict[str, Any]
    ) -> Optional[InsumoProcesado]:
        """
        Sistema de fallback usando especialistas de parsing.
        
        NOTA: Este m√©todo debe ser implementado seg√∫n tu l√≥gica espec√≠fica.
        
        Args:
            line: L√≠nea a procesar.
            apu_context: Contexto del APU.
        
        Returns:
            InsumoProcesado o None.
        """
        # Placeholder - implementar seg√∫n tu l√≥gica existente
        logger.debug("Ejecutando _process_with_specialists (fallback)")
        return None

### 3Ô∏è‚É£ HERRAMIENTA DE DIAGN√ìSTICO ADICIONAL

# En app/utils/diagnostic_tools.py

def compare_parser_outputs(
    raw_records: List[Dict],
    processed_insumos: List[InsumoProcesado],
    output_file: str = "diagnostic_parser_comparison.txt"
):
    """
    Compara los registros crudos con los procesados para identificar discrepancias.
    
    Args:
        raw_records: Registros extra√≠dos por ReportParserCrudo.
        processed_insumos: Insumos procesados por APUProcessor.
        output_file: Archivo de salida para el diagn√≥stico.
    """
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("=" * 100 + "\n")
        f.write("DIAGN√ìSTICO: COMPARACI√ìN PARSER CRUDO VS APU PROCESSOR\n")
        f.write("=" * 100 + "\n\n")
        
        f.write(f"Total registros crudos extra√≠dos: {len(raw_records)}\n")
        f.write(f"Total insumos procesados:         {len(processed_insumos)}\n")
        f.write(f"Tasa de conversi√≥n:               {len(processed_insumos)/len(raw_records)*100:.2f}%\n\n")
        
        if len(raw_records) > len(processed_insumos):
            f.write("‚ö†Ô∏è  DISCREPANCIA DETECTADA\n\n")
            
            processed_lines = {ins.line_number for ins in processed_insumos}
            
            f.write("L√çNEAS RECHAZADAS POR APUPROCESSOR:\n")
            f.write("-" * 100 + "\n")
            
            for idx, record in enumerate(raw_records):
                if idx not in processed_lines:
                    f.write(f"\nL√≠nea fuente: {record['source_line']}\n")
                    f.write(f"APU: {record['apu_code']}\n")
                    f.write(f"Categor√≠a: {record['category']}\n")
                    f.write(f"Contenido: {record['insumo_line']}\n")
                    f.write(f"Campos: {record['insumo_line'].split(';')}\n")
                    f.write("-" * 100 + "\n")
    
    logger.info(f"‚úì Diagn√≥stico guardado en: {output_file}")


### ‚úÖ BENEFICIOS DE ESTA SOLUCI√ìN

    Visibilidad total: Sabr√°s EXACTAMENTE qu√© l√≠neas fallan y por qu√©
    Validaci√≥n preventiva: El ReportParserCrudo solo enviar√° l√≠neas con alta probabilidad de √©xito
    Diagn√≥stico actionable: Las estad√≠sticas te dir√°n d√≥nde est√° el problema
    Mantenible: C√≥digo documentado y con responsabilidades claras
    Debugging eficiente: Modo debug con trazabilidad completa
