Para "inyectar" la l√≥gica piramidal (Jerarqu√≠a Estructural) y las unidades de trabajo discretas (Patr√≥n Chain of Responsibility o Cadena de Responsabilidad) en report_parser_crudo.py, debemos transformar el c√≥digo monol√≠tico actual en un sistema de componentes modulares que respeten la topolog√≠a de los datos (Proyecto ‚Üí APU ‚Üí Insumo).
A continuaci√≥n, presento la extensi√≥n l√≥gica y los ejemplos de c√≥digo concretos para esta refactorizaci√≥n, alineada con la arquitectura de "Caja de Cristal" y los patrones observados en pipeline_director.txt
 y apu_processor.txt

1. El Contexto de Estado (La Memoria de la Pir√°mide)

En lugar de variables sueltas, creamos una clase que mantenga el estado actual de la "construcci√≥n" de la pir√°mide. Este objeto viajar√° a trav√©s de los manejadores.

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any

@dataclass
class ParserContext:
    """
    Mantiene el estado mutable del parseo (La Pir√°mide en construcci√≥n).
    Act√∫a como la 'Memoria de Corto Plazo' del sistema.
    """
    current_apu: Optional['APUContext'] = None # El 'Padre' actual (Nivel 2)
    current_line_number: int = 0
    raw_records: List[Dict[str, Any]] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    
    # Telemetr√≠a interna
    stats: Dict[str, int] = field(default_factory=lambda: {
        "apus_detected": 0,
        "insumos_extracted": 0,
        "orphans_discarded": 0
    })

    def has_active_parent(self) -> bool:
        """Valida la l√≥gica piramidal: ¬øExiste un nodo padre activo?"""
        return self.current_apu is not None

2. La Interfaz de Unidad de Trabajo (LineHandler)
Definimos el contrato para las unidades discretas. Cada LineHandler es un experto en reconocer y procesar un tipo espec√≠fico de l√≠nea.

from abc import ABC, abstractmethod

class LineHandler(ABC):
    """
    Unidad de Trabajo Discreta.
    Patr√≥n: Chain of Responsibility.
    """
    def __init__(self, parent_parser):
        self.parent = parent_parser # Acceso a utilidades (Lark, Regex)

    @abstractmethod
    def can_handle(self, line: str) -> bool:
        """Determina si este handler es responsable de la l√≠nea."""
        pass

    @abstractmethod
    def handle(self, line: str, context: ParserContext) -> None:
        """
        Procesa la l√≠nea y actualiza el contexto (mutaci√≥n de estado).
        Aqu√≠ se aplica la l√≥gica de negocio.
        """
        pass

3. Implementaci√≥n de los "Especialistas"
Aqu√≠ es donde inyectamos la l√≥gica espec√≠fica.
A. HeaderHandler: El Constructor de Nivel 2 (APU)
Este handler detecta el inicio de un nuevo bloque. Su funci√≥n cr√≠tica es establecer el padre para las siguientes l√≠neas.

class HeaderHandler(LineHandler):
    def can_handle(self, line: str) -> bool:
        # L√≥gica de detecci√≥n (ejemplo simplificado basado en report_parser_crudo.txt)
        return "UNIDAD:" in line.upper() and "ITEM:" in line.upper()

    def handle(self, line: str, context: ParserContext) -> None:
        # 1. Extraer metadatos del encabezado
        apu_data = self._extract_header_data(line)
        
        # 2. Crear nuevo Contexto de APU (Nodo Padre)
        new_apu = APUContext(
            apu_code=apu_data['code'],
            apu_desc=apu_data['desc'],
            apu_unit=apu_data['unit'],
            source_line=context.current_line_number
        )
        
        # 3. ACTUALIZAR ESTADO (Cambio de Contexto Piramidal)
        context.current_apu = new_apu
        context.stats["apus_detected"] += 1
        
        # Logging sem√°ntico
        logger.info(f"üèóÔ∏è APU Detectado (Nivel 2): {new_apu.apu_code}")

    def _extract_header_data(self, line: str) -> dict:
        # L√≥gica de extracci√≥n regex existente en report_parser_crudo.txt
        # ...
        return {"code": "...", "desc": "...", "unit": "..."}

B. InsumoHandler: El Constructor de Nivel 3 (Insumo)
Este handler procesa los recursos. Aqu√≠ inyectamos la validaci√≥n piramidal: un insumo no puede existir sin un APU padre.

class InsumoHandler(LineHandler):
    def can_handle(self, line: str) -> bool:
        # Usamos una validaci√≥n ligera primero para no gastar recursos
        # Si parece una l√≠nea de datos (tiene n√∫meros, separadores)
        return ";" in line and any(c.isdigit() for c in line)

    def handle(self, line: str, context: ParserContext) -> None:
        # 1. VALIDACI√ìN PIRAMIDAL (L√≥gica Estructural)
        if not context.has_active_parent():
            # ERROR CR√çTICO DE NEGOCIO: Recurso Hu√©rfano
            # Esto evita "islas" desconectadas en el grafo final (beta_0 > 1)
            logger.warning(f"‚ö†Ô∏è Recurso Hu√©rfano detectado en l√≠nea {context.current_line_number}. Ignorando.")
            context.stats["orphans_discarded"] += 1
            return

        # 2. Validaci√≥n Gramatical (Lark) - Invocando al experto en sintaxis
        # Referencia a apu_processor.txt [2]
        is_valid, tree, reason = self.parent._validate_with_lark(line)
        
        if is_valid:
            # 3. Construcci√≥n del Registro (Vinculaci√≥n Padre-Hijo)
            record = {
                "apu_code": context.current_apu.apu_code, # Enlace al Padre
                "insumo_line": line,
                "source_line": context.current_line_number,
                "_lark_tree": tree # Cache del √°rbol sint√°ctico
            }
            context.raw_records.append(record)
            context.stats["insumos_extracted"] += 1
        else:
            # Registro de fallo suave
            logger.debug(f"L√≠nea inv√°lida en contexto {context.current_apu.apu_code}: {reason}")

4. El Orquestador (ReportParserCrudo Refactorizado)
Finalmente, actualizamos el m√©todo principal para usar estos componentes.

class ReportParserCrudo:
    # ... (inicializaci√≥n existente) ...

    def _initialize_handlers(self) -> List[LineHandler]:
        """Fabrica la cadena de responsabilidad en orden de prioridad."""
        return [
            JunkHandler(self),    # 1. Descartar basura obvia (l√≠neas vac√≠as, totales)
            HeaderHandler(self),  # 2. Detectar cambios de estructura (Nuevos APUs)
            CategoryHandler(self),# 3. Detectar cambios de categor√≠a (Materiales, Equipo)
            InsumoHandler(self)   # 4. Procesar datos (Hojas del √°rbol)
        ]

    def parse_to_raw(self) -> List[Dict[str, Any]]:
        """
        Ejecuta el parseo utilizando unidades de trabajo discretas.
        """
        # 1. Preparar el Entorno
        context = ParserContext()
        handlers = self._initialize_handlers()
        
        content = self._read_file_safely()
        lines = content.split('\n')
        
        logger.info(f"üöÄ Iniciando procesamiento de {len(lines)} l√≠neas con L√≥gica Piramidal.")

        # 2. Ciclo de Procesamiento (El Pipeline)
        for i, line in enumerate(lines, 1):
            context.current_line_number = i
            line = line.strip()
            
            if not line: 
                continue

            # 3. Delegaci√≥n a la Cadena de Responsabilidad
            handled = False
            for handler in handlers:
                if handler.can_handle(line):
                    handler.handle(line, context)
                    handled = True
                    break # Una vez manejada, pasamos a la siguiente l√≠nea
            
            if not handled:
                logger.debug(f"L√≠nea {i} no reconocida por ning√∫n handler.")

        # 4. Actualizar estado del objeto principal
        self.stats.update(context.stats)
        self.raw_records = context.raw_records
        
        return self.raw_records

Beneficios de esta Implementaci√≥n
1. Integridad Estructural (Œ®): Al forzar la comprobaci√≥n context.has_active_parent() dentro de InsumoHandler, garantizamos que no entren datos "flotantes" al sistema. Esto previene directamente la "Fragmentaci√≥n Estructural" (Œ≤0‚Äã>1) mencionada en la documentaci√≥n.
2. Observabilidad: Cada handler puede emitir logs espec√≠ficos ("APU Detectado", "Recurso Hu√©rfano"), mejorando la trazabilidad forense.
3. Mantenibilidad: Si cambia el formato de los encabezados, solo modificas HeaderHandler. Si cambia la validaci√≥n de insumos (ej. nuevas reglas Lark), solo tocas InsumoHandler.
4. Alineaci√≥n con el Ecosistema: Esta estructura refleja la misma filosof√≠a que el PipelineDirecto creando coherencia arquitect√≥nica en todo el backend.