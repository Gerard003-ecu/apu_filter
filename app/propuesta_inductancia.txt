import logging
import math
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, NamedTuple, Optional

import pandas as pd

from .apu_processor import APUProcessor
from .report_parser_crudo import ReportParserCrudo

logger = logging.getLogger(__name__)

# ... (ParsedData, Excepciones se mantienen igual) ...
class ParsedData(NamedTuple):
    raw_records: List[Dict[str, Any]]
    parse_cache: Dict[str, Any]

class DataFluxCondenserError(Exception): pass
class InvalidInputError(DataFluxCondenserError): pass
class ProcessingError(DataFluxCondenserError): pass

@dataclass(frozen=True)
class CondenserConfig:
    min_records_threshold: int = 1
    enable_strict_validation: bool = True
    log_level: str = "INFO"
    # --- Configuraci√≥n F√≠sica RLC ---
    system_capacitance: float = 5000.0  # Faradios (Capacidad de carga)
    base_resistance: float = 10.0       # Ohmios (Fricci√≥n est√°tica)
    system_inductance: float = 2.0      # Henrios (Inercia/Resistencia al cambio)

# --- MOTOR DE F√çSICA AVANZADO (RLC) ---
class FluxPhysicsEngine:
    """
    Simula el comportamiento f√≠sico RLC (Resistencia-Inductancia-Capacitancia).
    
    A√±ade la dimensi√≥n de INDUCTANCIA (L) basada en el documento 'bobinas_fisica.pdf'.
    Calcula la 'Tensi√≥n de Flyback' (CEMF) generada por cambios abruptos en la 
    calidad de los datos.
    """
    def __init__(self, capacitance: float, resistance: float, inductance: float):
        self.C = capacitance  # Capacidad de absorci√≥n
        self.R = resistance   # Resistencia base
        self.L = inductance   # Inercia del sistema (Inductancia)
        
    def calculate_metrics(self, total_records: int, cache_hits: int) -> Dict[str, float]:
        """
        Calcula m√©tricas f√≠sicas del flujo de datos.
        """
        if total_records == 0:
            return {"saturation": 0.0, "complexity": 0.0, "flyback_voltage": 0.0}

        # 1. Resistencia Din√°mica (Complejidad)
        # R aumenta si el cache no se usa (fricci√≥n de procesamiento)
        complexity = 1.0 - (cache_hits / total_records)
        
        # 2. Saturaci√≥n (Carga del Condensador)
        # Vc(t) = 1 - e^(-t/RC)
        dynamic_R = self.R * (1 + complexity * 5) # La complejidad aumenta R dr√°sticamente
        tau_c = dynamic_R * self.C
        saturation = 1.0 - math.exp(-float(total_records) / tau_c)

        # 3. Tensi√≥n de Flyback (Inductancia - Ley de Faraday/Lenz)
        # V_L = -L * (di/dt)
        # Asumimos que 'corriente' (i) es la tasa de √©xito (cache_hits / total).
        # Un cambio brusco en la calidad genera un pico de voltaje l√≥gico.
        # En un escenario batch, comparamos contra un "flujo ideal" (i=1.0).
        
        current_i = cache_hits / total_records # 0.0 a 1.0
        delta_i = 1.0 - current_i # La ca√≠da de corriente (p√©rdida de calidad)
        
        # El 'dt' es inversamente proporcional al tama√±o (en archivos peque√±os, 
        # un error es un cambio m√°s brusco que en grandes).
        dt = math.log1p(total_records) 
        
        # Voltaje inducido (magnitud del pico de error)
        flyback_voltage = self.L * (delta_i / dt) if dt > 0 else 0.0

        return {
            "saturation": saturation,
            "complexity": complexity,
            "flyback_voltage": flyback_voltage
        }

    def get_system_diagnosis(self, metrics: Dict[str, float]) -> str:
        v_flyback = metrics["flyback_voltage"]
        saturation = metrics["saturation"]

        # Diagn√≥stico basado en Flyback (Picos de tensi√≥n)
        if v_flyback > 0.5:
            return f"‚ö° PELIGRO: PICO INDUCTIVO ALTO (vL={v_flyback:.2f}). Datos muy inestables."
        elif v_flyback > 0.1:
            return f"‚ö†Ô∏è ADVERTENCIA: Rizado Inductivo (vL={v_flyback:.2f}). Calidad variable."
        
        # Diagn√≥stico basado en Saturaci√≥n (Carga)
        if saturation < 0.3: return "üåä FLUJO LAMINAR (Estable)"
        if saturation < 0.7: return "üåä FLUJO TRANSITORIO (Carga Media)"
        return "üåä FLUJO TURBULENTO (Saturado)"

# --- CLASE PRINCIPAL ACTUALIZADA ---

class DataFluxCondenser:
    # ... (Init se mantiene similar, a√±adiendo inductance a la config) ...
    
    def __init__(self, config: Dict[str, Any], profile: Dict[str, Any], condenser_config: Optional[CondenserConfig] = None):
        # ... validaciones previas ...
        self.config = config
        self.profile = profile
        self.condenser_config = condenser_config or CondenserConfig()
        
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(self.condenser_config.log_level)
        
        # Inicializar Motor de F√≠sica RLC
        self.physics = FluxPhysicsEngine(
            capacitance=self.condenser_config.system_capacitance,
            resistance=self.condenser_config.base_resistance,
            inductance=self.condenser_config.system_inductance # Nuevo par√°metro
        )
        self.logger.info("DataFluxCondenser (Motor RLC Activado) inicializado")

    # ... (M√©todos de validaci√≥n igual) ...

    def stabilize(self, file_path: str) -> pd.DataFrame:
        start_time = time.time()
        path_obj = Path(file_path)
        self.logger.info(f"‚ö° [F√çSICA] Energizando circuito para: {path_obj.name}")

        try:
            validated_path = self._validate_input_file(file_path)
            
            # FASE 1: ABSORCI√ìN (Carga del Condensador)
            parsed_data = self._absorb_and_filter(validated_path)
            
            if not self._validate_parsed_data(parsed_data):
                return pd.DataFrame()

            # --- C√ÅLCULO DE TELEMETR√çA RLC ---
            total_records = len(parsed_data.raw_records)
            cache_hits = len(parsed_data.parse_cache)
            
            metrics = self.physics.calculate_metrics(total_records, cache_hits)
            diagnosis = self.physics.get_system_diagnosis(metrics)
            
            # DIODO DE RUEDA LIBRE (Flyback Diode Logic)
            # Si el voltaje inductivo es demasiado alto, activamos el diodo de protecci√≥n
            # (en software: log de advertencia cr√≠tico o modo de fallo seguro)
            if metrics["flyback_voltage"] > 0.8:
                self.logger.warning(
                    f"üõ°Ô∏è [DIODO FLYBACK ACTIVADO] Se detect√≥ un colapso masivo de calidad. "
                    f"Disipando energ√≠a para evitar crash."
                )
            
            self.logger.info(
                f"üß≤ [TELEMETR√çA RLC] "
                f"Sat(C): {metrics['saturation']:.3f} | "
                f"Comp(R): {metrics['complexity']:.3f} | "
                f"Pico(L): {metrics['flyback_voltage']:.3f}v"
            )
            self.logger.info(f"   Diagn√≥stico: {diagnosis}")
            # ----------------------

            # FASE 2: DESCARGA (Rectificaci√≥n)
            df_stabilized = self._rectify_signal(parsed_data)
            
            self._validate_output(df_stabilized)
            
            elapsed = time.time() - start_time
            self.logger.info(
                f"‚úÖ [√âXITO] Descarga estabilizada en {elapsed:.2f}s. "
                f"{len(df_stabilized)} registros entregados."
            )
            return df_stabilized

        except Exception as e:
            self.logger.exception(f"üí• [CORTO CIRCUITO] Fallo cr√≠tico: {e}")
            raise ProcessingError(f"Fallo en estabilizaci√≥n: {e}") from e
            
    # ... (Resto de m√©todos igual) ...