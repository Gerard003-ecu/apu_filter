M√©todos y Clases Cr√≠ticas para la Implementaci√≥n de Jules
1. La Gram√°tica (APU_GRAMMAR): Simple y Orientada a Separadores

Este es el fundamento. La gram√°tica debe ser lo m√°s simple posible para evitar los LexError
APU_GRAMMAR = r"""
    ?start: line
    line: (field (SEP field)*)?   // Una l√≠nea es una lista opcional de campos
    field: /[^;]*/               // Un campo es cualquier cosa que no sea un separador
    SEP: ";"                      // El separador es un terminal expl√≠cito
    %import common.WS
    %ignore WS
"""
Funci√≥n Cr√≠tica: Su √∫nica responsabilidad es dividir la l√≠nea por el separador ;. No intenta entender el contenido de los campos. Esto resuelve el problema de los "zero-width terminals" de una vez por todas.

2. La Clase APUProcessor (El Orquestador üèóÔ∏è)

Esta clase es el punto de entrada y el controlador del flujo de trabajo.

    Funci√≥n Cr√≠tica: Inicializar correctamente el parser de lark.

    Implementaci√≥n Robusta:
    self.parser = Lark(APU_GRAMMAR, start='line', parser='earley', ambiguity='resolve')

        parser='earley': Se elige este algoritmo por su capacidad para manejar gram√°ticas complejas y ambiguas, lo que lo hace perfecto para datos del mundo real. Es la soluci√≥n al bloqueo de Jules.

        ambiguity='resolve': Emula la filosof√≠a de Arpeggio/PEG. Si Earley encuentra m√∫ltiples formas de interpretar una l√≠nea, simplemente elige la primera, garantizando un resultado determinista.

    Funci√≥n Cr√≠tica: Orquestar el proceso para una sola l√≠nea de insumo.

    Implementaci√≥n Robusta:

        Contexto: Prepara el apu_context (c√≥digo, descripci√≥n, etc.) que se pasar√° al transformer.

        Llamada a "Tree-less Parsing": Invoca al parser usando la optimizaci√≥n clave que aprendimos del informe de Lark. Esto es m√°s r√°pido y consume menos memoria.
    
    transformer = APUTransformer(apu_context, self.config)
    insumo_obj = self.parser.parse(insumo_line, transformer=transformer)

Cadena de Validaci√≥n: Aplica las funciones de validaci√≥n (_is_excluded_insumo, _should_add_insumo) sobre el objeto dataclass ya construido. Esto asegura que solo los objetos v√°lidos y completos lleguen al resultado final.

Manejo de Errores: Envuelve todo en un bloque try...except para que, si una l√≠nea es completamente irreparable, el proceso no se detenga, sino que se registre el error y se contin√∫e.

    Funci√≥n Cr√≠tica: Clasificar un insumo bas√°ndose en su descripci√≥n.

    Implementaci√≥n Robusta (L√≥gica de "Embudo"):

        Excepciones Primero: Comprueba si la descripci√≥n coincide con una lista de excepciones conocidas (ej. "HERRAMIENTA MENOR (% MANO DE OBRA)") para forzar una clasificaci√≥n correcta en casos ambiguos.

        Precedencia Despu√©s: Si no es una excepci√≥n, comprueba las palabras clave generales en un orden de precedencia estricto: Equipo -> Mano de Obra -> Transporte -> Suministro. Este orden es la soluci√≥n al bug de clasificaci√≥n que Jules no pod√≠a resolver.

        @staticmethod: Se define como un m√©todo est√°tico para que pueda ser llamado desde el APUTransformer sin necesidad de una instancia de APUProcessor, promoviendo un bajo acoplamiento.

3. La Clase APUTransformer (El Cerebro de la Transformaci√≥n üß†)

Esta es la clase m√°s importante y donde reside la l√≥gica de negocio del parsing.

    Funci√≥n Cr√≠tica: Actuar como un despachador inteligente. Es el coraz√≥n de la nueva arquitectura.

    Implementaci√≥n Robusta:

        Recibe una lista de tokens limpios.

        Decide bas√°ndose en el n√∫mero de campos:

            Si hay 6 o m√°s campos, determina si es ManoDeObra o un Insumo general y llama al m√©todo _build_* correspondiente.

            Si hay 5 campos, asume que es un Insumo b√°sico y llama a _build_insumo_basico.

        Si el n√∫mero de campos es inesperado, descarta la l√≠nea y la registra. Esto reemplaza la necesidad de m√∫ltiples reglas de gram√°tica fr√°giles.

    Funci√≥n Cr√≠tica: Actuar como "f√°bricas" especializadas para cada tipo de l√≠nea.

    Implementaci√≥n Robusta:

        Desempaquetado Expl√≠cito: Asigna los tokens a variables con nombres claros (ej. descripcion, _, _, jornal_total, ...). Esto hace que el c√≥digo sea auto-documentado.

        Conversi√≥n Segura: Utiliza parse_number() para convertir los tokens de texto a n√∫meros, manejando errores de forma segura.

        L√≥gica de Negocio Centralizada: Contiene los c√°lculos clave en un solo lugar. Por ejemplo, _build_mo_completa es el √∫nico lugar donde se calcula cantidad = 1.0 / rend.

        Instanciaci√≥n Directa de dataclasses: Su return es un objeto ManoDeObra(...) o Suministro(...) ya completo y validado por su tipo. Esto garantiza que solo objetos bien formados salgan del transformer.