# Configurar logging para las pruebas
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


class TestAPUTransformerRefined(unittest.TestCase):
    """Suite de pruebas completa para APUTransformer refinado."""
    
    def setUp(self):
        """Configuración inicial para cada prueba."""
        self.apu_context = {
            "codigo_apu": "APU001",
            "descripcion_apu": "Construcción de muro",
            "unidad_apu": "M2",
            "valor_unitario_apu": 100000.0
        }
        
        self.config = {
            "validation_thresholds": {
                "MANO_DE_OBRA": {
                    "min_jornal": 50000,
                    "max_jornal": 10000000,
                    "min_rendimiento": 0.001,
                    "max_rendimiento": 1000
                }
            }
        }
        
        # Mock del keyword cache
        self.keyword_cache = Mock(spec=KeywordCache)
        self.keyword_cache.equipo_keywords = ["EQUIPO", "HERRAMIENTA", "MAQUINA"]
        self.keyword_cache.mo_keywords = ["OFICIAL", "AYUDANTE", "PEON", "MO ", "MANO OBRA"]
        self.keyword_cache.transporte_keywords = ["TRANSPORTE", "VOLQUETA", "CAMION"]
        self.keyword_cache.suministro_keywords = ["CEMENTO", "ARENA", "CONCRETO"]
        
        self.transformer = APUTransformer(
            self.apu_context,
            self.config,
            self.keyword_cache
        )


class TestDetectFormat(TestAPUTransformerRefined):
    """Pruebas para el método _detect_format refinado."""
    
    def test_detect_mo_completa_formato_valido(self):
        """Prueba detección de formato MO_COMPLETA con datos válidos."""
        # Caso típico: Oficial de primera con todos los campos
        fields = [
            "OFICIAL DE PRIMERA",  # descripción
            "JOR",                  # unidad
            "0.125",                # rendimiento
            "",                     # desperdicio (vacío)
            "180000",               # jornal total
            "22500"                 # valor (opcional)
        ]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.MO_COMPLETA)
    
    def test_detect_mo_completa_sin_campos_opcionales(self):
        """Prueba detección MO_COMPLETA con campos mínimos."""
        fields = [
            "AYUDANTE DE OBRA",
            "JOR",
            "0.25",    # rendimiento
            "",        # campo vacío
            "120000",  # jornal
        ]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.MO_COMPLETA)
    
    def test_detect_insumo_basico_formato_valido(self):
        """Prueba detección de formato INSUMO_BASICO."""
        fields = [
            "CEMENTO GRIS",
            "KG",
            "50",
            "1200",
            "60000"
        ]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.INSUMO_BASICO)
    
    def test_detect_formato_desconocido_campos_insuficientes(self):
        """Prueba detección DESCONOCIDO con campos insuficientes."""
        fields = ["DESCRIPCION", "UND"]  # Solo 2 campos
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.DESCONOCIDO)
    
    def test_detect_linea_especial_subtotal(self):
        """Prueba detección de líneas especiales (subtotal)."""
        fields = ["SUBTOTAL MATERIALES", "100000", "", ""]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.DESCONOCIDO)
    
    def test_detect_linea_especial_encabezado(self):
        """Prueba detección de encabezados."""
        fields = ["DESCRIPCION", "UNIDAD", "CANTIDAD", "PRECIO", "VALOR"]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.DESCONOCIDO)
    
    def test_detect_linea_especial_categoria(self):
        """Prueba detección de líneas de categoría."""
        fields = ["MATERIALES", "", "", "", ""]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.DESCONOCIDO)
    
    def test_detect_formato_con_campos_vacios_al_final(self):
        """Prueba detección con campos vacíos al final."""
        fields = [
            "ARENA LAVADA",
            "M3",
            "2.5",
            "80000",
            "200000",
            "",  # campos vacíos al final
            "",
            ""
        ]
        
        resultado = self.transformer._detect_format(fields)
        self.assertEqual(resultado, FormatoLinea.INSUMO_BASICO)
    
    def test_detect_formato_con_valores_numericos_mixtos(self):
        """Prueba con campos que mezclan números y texto."""
        fields = [
            "HERRAMIENTA MENOR",
            "% MO",
            "5%",      # porcentaje
            "Ver nota",  # texto
            "15000"
        ]
        
        resultado = self.transformer._detect_format(fields)
        # Debe detectar que no hay suficientes campos numéricos válidos
        self.assertIn(resultado, [FormatoLinea.INSUMO_BASICO, FormatoLinea.DESCONOCIDO])


class TestValidateMoFormat(TestAPUTransformerRefined):
    """Pruebas para el método _validate_mo_format refinado."""
    
    def test_validate_mo_format_valido(self):
        """Prueba validación exitosa de formato MO."""
        fields = [
            "OFICIAL PRIMERA",
            "JOR",
            "0.125",   # rendimiento válido
            "",
            "180000",  # jornal válido
            "22500"
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertTrue(resultado)
    
    def test_validate_mo_format_campos_insuficientes(self):
        """Prueba validación con campos insuficientes."""
        fields = ["OFICIAL", "JOR", "0.125", "180000"]  # Solo 4 campos
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertFalse(resultado)
    
    def test_validate_mo_format_rendimiento_fuera_rango(self):
        """Prueba validación con rendimiento fuera de rango."""
        fields = [
            "OFICIAL",
            "JOR",
            "2000",    # rendimiento muy alto (> 1000)
            "",
            "180000",
            ""
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertFalse(resultado)
    
    def test_validate_mo_format_jornal_fuera_rango(self):
        """Prueba validación con jornal fuera de rango."""
        fields = [
            "PEON",
            "JOR",
            "0.5",
            "",
            "20000",   # jornal muy bajo (< 50000)
            ""
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertFalse(resultado)
    
    def test_validate_mo_format_campos_vacios(self):
        """Prueba validación con campos requeridos vacíos."""
        fields = [
            "AYUDANTE",
            "JOR",
            "",        # rendimiento vacío
            "",
            "150000",
            ""
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertFalse(resultado)
    
    def test_validate_mo_format_valores_no_numericos(self):
        """Prueba validación con valores no numéricos."""
        fields = [
            "OFICIAL",
            "JOR",
            "ABC",     # no numérico
            "",
            "XYZ",     # no numérico
            ""
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertFalse(resultado)
    
    def test_validate_mo_format_coherencia_invalida(self):
        """Prueba validación de coherencia con rendimiento irreal."""
        fields = [
            "OFICIAL",
            "JOR",
            "150",     # 150 jornadas por unidad es muy alto
            "",
            "180000",
            ""
        ]
        
        # Modificar temporalmente el umbral para esta prueba
        with patch.object(self.transformer, '_validate_mo_coherence', return_value=False):
            resultado = self.transformer._validate_mo_format(fields)
            self.assertFalse(resultado)
    
    def test_validate_mo_format_con_separador_decimal_coma(self):
        """Prueba validación con separador decimal coma."""
        fields = [
            "OFICIAL ESPECIALIZADO",
            "JOR",
            "0,125",    # coma como decimal
            "",
            "180.000",  # punto como separador de miles
            ""
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertTrue(resultado)


class TestBuildMoCompleta(TestAPUTransformerRefined):
    """Pruebas para el método _build_mo_completa refinado."""
    
    def test_build_mo_completa_exitoso(self):
        """Prueba construcción exitosa de ManoDeObra."""
        tokens = [
            "OFICIAL DE PRIMERA",
            "JOR",
            "0.125",   # rendimiento = 0.125 jornadas por M2
            "",
            "180000",  # jornal total
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        
        self.assertIsNotNone(resultado)
        self.assertEqual(resultado.descripcion_insumo, "OFICIAL DE PRIMERA")
        self.assertEqual(resultado.unidad_insumo, "JOR")
        self.assertAlmostEqual(resultado.rendimiento, 0.125, places=3)
        self.assertAlmostEqual(resultado.cantidad, 8.0, places=2)  # 1/0.125
        self.assertEqual(resultado.precio_unitario, 180000)
        self.assertAlmostEqual(resultado.valor_total, 1440000, places=0)  # 8 * 180000
        self.assertEqual(resultado.tipo_insumo, "MANO_DE_OBRA")
        self.assertEqual(resultado.formato_origen, "MO_COMPLETA")
    
    def test_build_mo_completa_tokens_insuficientes(self):
        """Prueba con tokens insuficientes."""
        tokens = ["OFICIAL", "JOR", "0.125"]  # Solo 3 tokens
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNone(resultado)
    
    def test_build_mo_completa_descripcion_vacia(self):
        """Prueba con descripción vacía."""
        tokens = ["", "JOR", "0.125", "", "180000"]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNone(resultado)
    
    def test_build_mo_completa_valores_invalidos(self):
        """Prueba con valores numéricos inválidos."""
        tokens = [
            "AYUDANTE",
            "JOR",
            "0",       # rendimiento cero (inválido)
            "",
            "150000",
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNone(resultado)
    
    def test_build_mo_completa_jornal_negativo(self):
        """Prueba con jornal negativo."""
        tokens = [
            "PEON",
            "JOR",
            "0.5",
            "",
            "-100000",  # jornal negativo
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNone(resultado)
    
    def test_build_mo_completa_cantidad_calculada_fuera_rango(self):
        """Prueba con cantidad calculada fuera de rango."""
        tokens = [
            "OFICIAL",
            "JOR",
            "0.0001",   # rendimiento muy pequeño -> cantidad muy grande
            "",
            "180000",
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        # Debe fallar porque cantidad = 1/0.0001 = 10000 > 1000
        self.assertIsNone(resultado)
    
    def test_build_mo_completa_con_unidad_diferente(self):
        """Prueba con unidad diferente a JOR."""
        tokens = [
            "OPERARIO ESPECIALIZADO",
            "HR",       # Horas en lugar de jornadas
            "0.25",
            "",
            "22500",    # precio por hora
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        
        self.assertIsNotNone(resultado)
        self.assertEqual(resultado.unidad_insumo, "HR")  # Debe respetar HR para MO
    
    def test_build_mo_completa_manejo_excepciones(self):
        """Prueba manejo de excepciones durante construcción."""
        tokens = [
            "OFICIAL",
            "JOR",
            "texto_invalido",  # Causará excepción en parse_number
            "",
            "180000",
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNone(resultado)  # Debe retornar None sin crash


class TestMetodosAuxiliares(TestAPUTransformerRefined):
    """Pruebas para métodos auxiliares refinados."""
    
    def test_detect_decimal_separator_coma(self):
        """Prueba detección de separador decimal coma."""
        resultado = self.transformer._detect_decimal_separator("123,45", "678,90")
        self.assertEqual(resultado, "comma")
    
    def test_detect_decimal_separator_punto(self):
        """Prueba detección de separador decimal punto."""
        resultado = self.transformer._detect_decimal_separator("123.45", "678.90")
        self.assertEqual(resultado, "dot")
    
    def test_detect_decimal_separator_mixto(self):
        """Prueba con separadores mixtos (miles y decimales)."""
        # Formato: 1.234,56 (punto para miles, coma para decimales)
        resultado = self.transformer._detect_decimal_separator("1.234,56")
        self.assertEqual(resultado, "comma")
        
        # Formato: 1,234.56 (coma para miles, punto para decimales)
        resultado = self.transformer._detect_decimal_separator("1,234.56")
        self.assertEqual(resultado, "dot")
    
    def test_detect_decimal_separator_miles_sin_decimales(self):
        """Prueba con solo separador de miles."""
        # 180,000 - coma como separador de miles (3 dígitos después)
        resultado = self.transformer._detect_decimal_separator("180,000")
        self.assertEqual(resultado, "dot")  # Asume punto como decimal
    
    def test_get_mo_thresholds_valores_default(self):
        """Prueba obtención de umbrales con valores por defecto."""
        thresholds = self.transformer._get_mo_thresholds()
        
        self.assertEqual(thresholds['min_jornal'], 50000)
        self.assertEqual(thresholds['max_jornal'], 10000000)
        self.assertEqual(thresholds['min_rendimiento'], 0.001)
        self.assertEqual(thresholds['max_rendimiento'], 1000)
    
    def test_get_mo_thresholds_configuracion_personalizada(self):
        """Prueba con configuración personalizada."""
        self.transformer.config['validation_thresholds']['MANO_DE_OBRA']['min_jornal'] = 100000
        
        thresholds = self.transformer._get_mo_thresholds()
        self.assertEqual(thresholds['min_jornal'], 100000)
    
    def test_validate_mo_coherence_valido(self):
        """Prueba validación de coherencia válida."""
        fields = ["OFICIAL", "JOR", "0.125", "", "180000"]
        resultado = self.transformer._validate_mo_coherence(0.125, 180000, fields)
        self.assertTrue(resultado)
    
    def test_validate_mo_coherence_rendimiento_alto(self):
        """Prueba con rendimiento muy alto."""
        fields = ["OFICIAL", "JOR", "150", "", "180000"]
        resultado = self.transformer._validate_mo_coherence(150, 180000, fields)
        self.assertFalse(resultado)  # > 100 jornadas es poco probable
    
    def test_validate_mo_coherence_jornal_muy_bajo(self):
        """Prueba con jornal por hora muy bajo."""
        fields = ["PEON", "JOR", "0.5", "", "30000"]
        resultado = self.transformer._validate_mo_coherence(0.5, 30000, fields)
        self.assertFalse(resultado)  # 30000/8 = 3750 por hora es muy bajo
    
    def test_is_special_line_subtotal(self):
        """Prueba detección de línea de subtotal."""
        self.assertTrue(self.transformer._is_special_line("SUBTOTAL MATERIALES"))
        self.assertTrue(self.transformer._is_special_line("TOTAL GENERAL"))
        self.assertTrue(self.transformer._is_special_line("VALOR TOTAL APU"))
    
    def test_is_special_line_encabezado(self):
        """Prueba detección de línea de encabezado."""
        self.assertTrue(self.transformer._is_special_line("DESCRIPCIÓN"))
        self.assertTrue(self.transformer._is_special_line("UNIDAD"))
        self.assertTrue(self.transformer._is_special_line("CANTIDAD"))
        self.assertTrue(self.transformer._is_special_line("PRECIO UNITARIO"))
    
    def test_is_special_line_categoria(self):
        """Prueba detección de línea de categoría."""
        self.assertTrue(self.transformer._is_special_line("MATERIALES"))
        self.assertTrue(self.transformer._is_special_line("MANO DE OBRA"))
        self.assertTrue(self.transformer._is_special_line("EQUIPO"))
        self.assertTrue(self.transformer._is_special_line("TRANSPORTE"))
    
    def test_is_special_line_normal(self):
        """Prueba con líneas normales (no especiales)."""
        self.assertFalse(self.transformer._is_special_line("CEMENTO GRIS TIPO 1"))
        self.assertFalse(self.transformer._is_special_line("OFICIAL DE PRIMERA"))
        self.assertFalse(self.transformer._is_special_line("ARENA LAVADA"))
    
    def test_analyze_numeric_fields(self):
        """Prueba análisis de campos numéricos."""
        fields = ["UND", "10", "5%", "1500.50", "15005.00"]
        
        analysis = self.transformer._analyze_numeric_fields(fields)
        
        self.assertEqual(analysis['count'], 3)  # 10, 1500.50, 15005.00
        self.assertTrue(analysis['has_percentage'])  # 5%
        self.assertTrue(analysis['has_decimal'])  # .50 y .00
        self.assertEqual(analysis['positions'], [1, 3, 4])
        self.assertEqual(len(analysis['values']), 3)
    
    def test_analyze_numeric_fields_sin_numeros(self):
        """Prueba análisis sin campos numéricos."""
        fields = ["UND", "ABC", "XYZ", "N/A"]
        
        analysis = self.transformer._analyze_numeric_fields(fields)
        
        self.assertEqual(analysis['count'], 0)
        self.assertFalse(analysis['has_percentage'])
        self.assertFalse(analysis['has_decimal'])
        self.assertEqual(analysis['positions'], [])
    
    def test_validate_total_coherence_valido(self):
        """Prueba validación de coherencia total válida."""
        cantidad = 10
        precio = 1000
        total = 10000
        
        resultado = self.transformer._validate_total_coherence(cantidad, precio, total)
        self.assertTrue(resultado)
    
    def test_validate_total_coherence_con_tolerancia(self):
        """Prueba validación con diferencia dentro de tolerancia."""
        cantidad = 10
        precio = 1000
        total = 10040  # 0.4% de diferencia
        
        resultado = self.transformer._validate_total_coherence(cantidad, precio, total, tolerance=0.05)
        self.assertTrue(resultado)
    
    def test_validate_total_coherence_fuera_tolerancia(self):
        """Prueba validación con diferencia fuera de tolerancia."""
        cantidad = 10
        precio = 1000
        total = 11000  # 10% de diferencia
        
        resultado = self.transformer._validate_total_coherence(cantidad, precio, total, tolerance=0.05)
        self.assertFalse(resultado)
    
    def test_is_valid_annotation(self):
        """Prueba validación de anotaciones."""
        self.assertTrue(self.transformer._is_valid_annotation("INCLUYE IVA"))
        self.assertTrue(self.transformer._is_valid_annotation("SIN DESPERDICIO"))
        self.assertTrue(self.transformer._is_valid_annotation("VER PLANOS"))
        self.assertFalse(self.transformer._is_valid_annotation("RANDOM TEXT"))


class TestIntegracionCompleta(TestAPUTransformerRefined):
    """Pruebas de integración del flujo completo."""
    
    @patch('logging.Logger.debug')
    def test_flujo_completo_mo_completa(self, mock_logger):
        """Prueba flujo completo para línea MO_COMPLETA."""
        # Simular entrada de Lark tokens
        mock_token = Mock()
        mock_token.value = ""
        
        tokens = []
        for value in ["OFICIAL ALBAÑIL", "JOR", "0.125", "", "185000", "23125"]:
            token = Mock()
            token.value = value
            tokens.append(token)
        
        # Ejecutar transformación completa
        resultado = self.transformer.line(*tokens)
        
        # Verificaciones
        self.assertIsNotNone(resultado)
        self.assertIsInstance(resultado, ManoDeObra)
        self.assertEqual(resultado.descripcion_insumo, "OFICIAL ALBAÑIL")
        self.assertAlmostEqual(resultado.cantidad, 8.0, places=2)
        self.assertEqual(resultado.precio_unitario, 185000)
        self.assertEqual(resultado.tipo_insumo, "MANO_DE_OBRA")
    
    @patch('logging.Logger.debug')
    def test_flujo_completo_insumo_basico(self, mock_logger):
        """Prueba flujo completo para línea INSUMO_BASICO."""
        tokens = []
        for value in ["CEMENTO PORTLAND", "KG", "50", "1200", "60000"]:
            token = Mock()
            token.value = value
            tokens.append(token)
        
        resultado = self.transformer.line(*tokens)
        
        self.assertIsNotNone(resultado)
        self.assertEqual(resultado.descripcion_insumo, "CEMENTO PORTLAND")
        self.assertEqual(resultado.cantidad, 50)
        self.assertEqual(resultado.precio_unitario, 1200)
        self.assertEqual(resultado.valor_total, 60000)
    
    @patch('logging.Logger.debug')
    def test_flujo_completo_fallback_mo_a_basico(self, mock_logger):
        """Prueba fallback de MO_COMPLETA a INSUMO_BASICO."""
        # Datos que parecen MO pero no pasan validación estricta
        tokens = []
        for value in ["AYUDANTE TEMPORAL", "JOR", "9999", "", "45000", ""]:
            token = Mock()
            token.value = value
            tokens.append(token)
        
        # El rendimiento 9999 está fuera de rango, debería hacer fallback
        resultado = self.transformer.line(*tokens)
        
        # Debería construirse como INSUMO_BASICO después del fallback
        self.assertIsNotNone(resultado)
        self.assertEqual(resultado.formato_origen, "INSUMO_BASICO")


class TestCasosEdge(TestAPUTransformerRefined):
    """Pruebas para casos edge y situaciones límite."""
    
    def test_campos_con_caracteres_especiales(self):
        """Prueba con caracteres especiales en los campos."""
        fields = [
            "OFICIAL 1° CATEGORÍA",
            "JOR",
            "0.125",
            "",
            "180,000.00",  # formato con miles y decimales
            ""
        ]
        
        resultado = self.transformer._validate_mo_format(fields)
        self.assertTrue(resultado)
    
    def test_descripcion_muy_larga(self):
        """Prueba con descripción extremadamente larga."""
        descripcion = "OFICIAL " + "ESPECIALIZADO " * 50  # Descripción muy larga
        tokens = [descripcion, "JOR", "0.125", "", "180000", ""]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNotNone(resultado)
        self.assertEqual(resultado.descripcion_insumo, descripcion)
    
    def test_valores_limite_minimos(self):
        """Prueba con valores en límites mínimos."""
        tokens = [
            "AYUDANTE",
            "JOR",
            "0.001",    # rendimiento mínimo
            "",
            "50000",    # jornal mínimo
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNotNone(resultado)
        self.assertAlmostEqual(resultado.cantidad, 1000, places=2)
    
    def test_valores_limite_maximos(self):
        """Prueba con valores en límites máximos."""
        # Ajustar temporalmente el límite de cantidad para esta prueba
        tokens = [
            "ESPECIALISTA",
            "JOR",
            "1",        # rendimiento que da cantidad = 1
            "",
            "10000000", # jornal máximo
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNotNone(resultado)
        self.assertEqual(resultado.precio_unitario, 10000000)
    
    def test_campos_unicode_y_acentos(self):
        """Prueba con caracteres Unicode y acentos."""
        tokens = [
            "PEÓN CATEGORÍA ÚNICA",
            "JOR",
            "0,250",    # con coma decimal
            "",
            "120.000",  # con punto de miles
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNotNone(resultado)
    
    def test_division_por_cero_protegida(self):
        """Prueba protección contra división por cero."""
        # Simular un caso donde el rendimiento podría ser interpretado como 0
        tokens = [
            "OFICIAL",
            "JOR",
            "0.0",      # rendimiento cero
            "",
            "180000",
            ""
        ]
        
        resultado = self.transformer._build_mo_completa(tokens)
        self.assertIsNone(resultado)  # Debe retornar None, no crash
    
    def test_campos_nulos_none(self):
        """Prueba con campos None en lugar de strings vacíos."""
        fields = [
            "OFICIAL",
            None,       # None en lugar de ""
            "0.125",
            None,
            "180000",
            None
        ]
        
        # Convertir None a string vacío internamente
        fields_clean = [f if f is not None else "" for f in fields]
        resultado = self.transformer._validate_mo_format(fields_clean)
        self.assertTrue(resultado)


# ============================================================================
# EJECUCIÓN DE PRUEBAS
# ============================================================================

def run_tests():
    """Ejecuta todas las pruebas."""
    # Crear suite de pruebas
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Agregar todas las clases de prueba
    suite.addTests(loader.loadTestsFromTestCase(TestDetectFormat))
    suite.addTests(loader.loadTestsFromTestCase(TestValidateMoFormat))
    suite.addTests(loader.loadTestsFromTestCase(TestBuildMoCompleta))
    suite.addTests(loader.loadTestsFromTestCase(TestMetodosAuxiliares))
    suite.addTests(loader.loadTestsFromTestCase(TestIntegracionCompleta))
    suite.addTests(loader.loadTestsFromTestCase(TestCasosEdge))
    
    # Ejecutar con verbosidad
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Resumen de resultados
    print("\n" + "="*70)
    print(f"Pruebas ejecutadas: {result.testsRun}")
    print(f"Éxitos: {result.testsRun - len(result.failures) - len(result.errors)}")
    print(f"Fallos: {len(result.failures)}")
    print(f"Errores: {len(result.errors)}")
    
    if result.failures:
        print("\nFallos detectados:")
        for test, traceback in result.failures:
            print(f"  - {test}: {traceback.split(chr(10))[0]}")
    
    if result.errors:
        print("\nErrores detectados:")
        for test, traceback in result.errors:
            print(f"  - {test}: {traceback.split(chr(10))[0]}")
    
    print("="*70)
    
    return result.wasSuccessful()


if __name__ == "__main__":
    success = run_tests()
    exit(0 if success else 1)