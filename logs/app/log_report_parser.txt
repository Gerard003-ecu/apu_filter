# En app/report_parser.py

import logging
import re
from typing import Dict, Optional

import pandas as pd

from .utils import clean_apu_code

logger = logging.getLogger(__name__)

class ReportParser:
    """
    Parsea un archivo de reporte de APUs en formato de texto (tipo SAGUT)
    utilizando una m√°quina de estados pura para manejar el formato de reporte.
    VERSI√ìN MEJORADA CON SOPORTE MULTI-FORMATO.
    """
    PATTERNS = {
        "item_code": re.compile(r"ITEM:\s*([^;]+)", re.IGNORECASE),
        
        # Patr√≥n para insumos generales
        "insumo_full": re.compile(
            r"^(?P<descripcion>[^;]+);"
            r"(?P<unidad>[^;]*);"
            r"(?P<cantidad>[^;]*);"
            r"(?P<desperdicio>[^;]*);"
            r"(?P<precio_unit>[^;]*);"
            r"(?P<valor_total>[^;]*)",
            re.IGNORECASE
        ),
        
        # Patr√≥n para mano de obra COMPLEJA (formato SAGUT extendido)
        "mano_de_obra_compleja": re.compile(
            r"^(?P<descripcion>(M\.O\.|MANO DE OBRA|SISO|INGENIERO|OFICIAL|AYUDANTE|MAESTRO).+?);"
            r"(?P<jornal_base>[\d.,\s]+);"
            r"(?P<prestaciones>[\d%.,\s]+);"
            r"(?P<jornal_total>[\d.,\s]+);"
            r"(?P<rendimiento>[\d.,\s]+);"
            r"(?P<valor_total>[\d.,\s]+)",
            re.IGNORECASE
        ),
        
        # Patr√≥n para mano de obra SIMPLE (formato CSV est√°ndar)
        "mano_de_obra_simple": re.compile(
            r"^(?P<descripcion>(M\.O\.|MANO DE OBRA|SISO|INGENIERO|OFICIAL|AYUDANTE|MAESTRO).+?);"
            r"[^;]*;"  # Ignora segundo campo (puede ser c√≥digo o vac√≠o)
            r"(?P<cantidad>[^;]*);"
            r"[^;]*;"  # Ignora cuarto campo (desperdicio)
            r"(?P<precio_unit>[^;]*);"
            r"(?P<valor_total>[^;]*)",
            re.IGNORECASE
        ),
    }

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.apus_data = []
        self.context = {
            "apu_code": None,
            "apu_desc": "",
            "apu_unit": "",
            "category": "INDEFINIDO",
        }
        self.potential_apu_desc = ""
        # M√©tricas mejoradas
        self.stats = {
            "total_lines": 0,
            "processed_lines": 0,
            "items_found": 0,
            "insumos_parsed": 0,
            "mo_compleja_parsed": 0,
            "mo_simple_parsed": 0,
            "garbage_lines": 0,
            "unparsed_data_lines": 0
        }

    def parse(self) -> pd.DataFrame:
        logger.info(f"üîç Iniciando el parsing del archivo: {self.file_path}")
        try:
            with open(self.file_path, "r", encoding="latin1") as f:
                for line in f:
                    self.stats["total_lines"] += 1
                    self._process_line(line)
        except Exception as e:
            logger.error(f"‚ùå Error al parsear {self.file_path}: {e}", exc_info=True)
            return pd.DataFrame()

        logger.info(f"üìä M√©tricas de parsing para {self.file_path}:")
        for key, value in self.stats.items():
            logger.info(f"   {key}: {value}")
        
        if not self.apus_data:
            logger.warning("‚ö†Ô∏è No se extrajeron datos de APU, devolviendo DataFrame vac√≠o.")
            return pd.DataFrame()

        df = pd.DataFrame(self.apus_data)
        df.rename(columns={
            "DESCRIPCION": "DESCRIPCION_INSUMO",
            "CANTIDAD": "CANTIDAD_APU",
            "VR_UNITARIO": "PRECIO_UNIT_APU",
            "VR_TOTAL": "VALOR_TOTAL_APU",
            "UNIDAD": "UNIDAD_INSUMO"
        }, inplace=True)
        df["NORMALIZED_DESC"] = self._normalize_text(df["DESCRIPCION_INSUMO"])
        
        logger.info(f"‚úÖ DataFrame generado con {len(df)} registros")
        return df

    def _process_line(self, line: str):
        """
        Proceso principal mejorado con mejor manejo de contexto.
        """
        line = line.strip()
        if not line:
            return

        self.stats["processed_lines"] += 1

        # Filtrar basura primero
        if self._is_garbage_line(line):
            self.stats["garbage_lines"] += 1
            return

        upper_line = line.upper()

        # Detectar nuevo ITEM (inicio de APU)
        match_item = self.PATTERNS["item_code"].search(upper_line)
        if match_item:
            raw_code = match_item.group(1).strip()
            unit_match = re.search(r"UNIDAD:\s*([A-Z0-9/%]+)", upper_line)
            unit = unit_match.group(1) if unit_match else "INDEFINIDO"

            logger.debug(f"üÜï ITEM detectado: c√≥digo='{raw_code}', unidad='{unit}'")
            self._start_new_apu(raw_code, unit)
            return

        # Detectar cambio de categor√≠a
        category_keywords = {"MATERIALES", "MANO DE OBRA", "EQUIPO", "OTROS", "TRANSPORTE"}
        first_part = line.split(';', 1)[0].strip().upper()

        for category in category_keywords:
            if category in first_part:
                self.context["category"] = category
                logger.debug(f"üìÇ Categor√≠a establecida: {category}")
                return

        # Si no hay APU activo, buscar descripci√≥n potencial
        if not self.context["apu_code"]:
            if self._is_potential_description(line):
                self.potential_apu_desc = line.split(';', 1)[0].strip()
            return

        # Intentar parsear como l√≠nea de datos
        processed = self._try_parse_data_line(line)
        if not processed and self._is_potential_description(line):
            self.potential_apu_desc = line.split(';', 1)[0].strip()

    def _try_parse_data_line(self, line: str) -> bool:
        """
        Versi√≥n mejorada con l√≥gica de fallback para m√∫ltiples formatos.
        Retorna True si la l√≠nea fue parseada exitosamente.
        """
        # PRIORIDAD 1: Intentar como Mano de Obra COMPLEJA (formato extendido)
        if "MANO DE OBRA" in self.context["category"].upper() or self._looks_like_mo(line):
            match_mo_compleja = self.PATTERNS["mano_de_obra_compleja"].match(line)
            if match_mo_compleja:
                data = match_mo_compleja.groupdict()
                if self._is_valid_mo_compleja_data(data):
                    self._parse_mano_de_obra_compleja(data)
                    return True
            
            # FALLBACK: Intentar como Mano de Obra SIMPLE (formato CSV est√°ndar)
            match_mo_simple = self.PATTERNS["mano_de_obra_simple"].match(line)
            if match_mo_simple:
                data = match_mo_simple.groupdict()
                if self._is_valid_mo_simple_data(data):
                    self._parse_mano_de_obra_simple(data)
                    return True

        # PRIORIDAD 2: Intentar como Insumo general
        match_insumo = self.PATTERNS["insumo_full"].match(line)
        if match_insumo:
            data = match_insumo.groupdict()
            if self._is_valid_insumo_data(data):
                self._parse_insumo(data)
                return True

        # Si tiene estructura de datos pero no se parse√≥, registrar
        if self._has_data_structure(line):
            logger.warning(f"‚ö†Ô∏è L√≠nea con estructura no parseada: {line[:120]}...")
            self.stats["unparsed_data_lines"] += 1

        return False

    def _looks_like_mo(self, line: str) -> bool:
        """Detecta si una l√≠nea parece ser de mano de obra por su descripci√≥n."""
        mo_keywords = ["M.O.", "MANO DE OBRA", "SISO", "INGENIERO", "OFICIAL", 
                       "AYUDANTE", "MAESTRO", "TOPOGRAFO", "CAPATAZ", "CUADRILLA"]
        upper_line = line.upper()
        return any(keyword in upper_line for keyword in mo_keywords)

    def _calculate_mo_quantity(self, valor_total: float, jornal_total: float, rendimiento: float) -> float:
        """
        Calcula cantidad para mano de obra compleja considerando casos edge.
        """
        if jornal_total <= 0:
            logger.debug("‚ö†Ô∏è Jornal total es 0 o negativo, retornando cantidad 0")
            return 0.0

        if valor_total > 0:
            cantidad_base = valor_total / jornal_total
        else:
            cantidad_base = 0.0

        # Ajustes por rendimiento an√≥malo
        if rendimiento > 0:
            if 0 < rendimiento < 0.2:
                logger.debug(f"üîß Rendimiento muy bajo ({rendimiento}), interpretando como horas -> *8")
                cantidad_base *= 8
            elif rendimiento > 10:
                logger.debug(f"‚ö†Ô∏è Rendimiento inusualmente alto: {rendimiento}")

        return round(cantidad_base, 6)

    def _calculate_rendimiento_from_values(self, valor_total: float, precio_unit: float) -> float:
        """
        Calcula rendimiento cuando solo se conoce valor total y precio unitario.
        F√≥rmula: rendimiento = precio_unitario / valor_total
        (Representa cu√°nto del jornal se usa por unidad de APU)
        """
        if valor_total <= 0:
            logger.debug("‚ö†Ô∏è Valor total es 0 o negativo, rendimiento = 0")
            return 0.0
        
        rendimiento = precio_unit / valor_total
        
        # Validar que el rendimiento calculado sea razonable
        if rendimiento > 100:
            logger.warning(f"‚ö†Ô∏è Rendimiento calculado muy alto ({rendimiento:.2f}), posible error en datos")
        elif rendimiento < 0.0001:
            logger.warning(f"‚ö†Ô∏è Rendimiento calculado muy bajo ({rendimiento:.6f}), posible error en datos")
        
        return round(rendimiento, 6)

    def _should_add_insumo(self, descripcion: str, cantidad: float, valor_total: float) -> bool:
        """
        Validaci√≥n mejorada para determinar si un insumo debe agregarse.
        """
        # Validar descripci√≥n
        if not descripcion or len(descripcion.strip()) < 2:
            logger.debug(f"‚ùå Descripci√≥n inv√°lida o muy corta: '{descripcion}'")
            return False

        invalid_descriptions = {"", "-", "N/A", "NO APLICA", "S/D", "SIN DATOS", "SUBTOTAL", "TOTAL"}
        if descripcion.upper().strip() in invalid_descriptions:
            logger.debug(f"‚ùå Descripci√≥n en lista negra: '{descripcion}'")
            return False

        # Al menos uno de los valores debe ser positivo
        if cantidad <= 0 and valor_total <= 0:
            logger.debug(f"‚ùå Cantidad y valor total son 0 o negativos: qty={cantidad}, total={valor_total}")
            return False

        # Filtrar valores excesivamente peque√±os (posible ruido)
        if 0 < cantidad < 1e-10 or 0 < valor_total < 0.001:
            logger.debug(f"‚ö†Ô∏è Valores muy peque√±os descartados: cantidad={cantidad}, total={valor_total}")
            return False

        return True

    def _is_garbage_line(self, line: str) -> bool:
        """Filtra l√≠neas que no aportan informaci√≥n √∫til."""
        upper_line = line.upper()
        garbage_keywords = [
            "FORMATO DE AN√ÅLISIS", "COSTOS DIRECTOS", "COSTO TOTAL",
            "PRESUPUESTO OFICIAL", "CONSTRUCTOR:", "REPRESENTANTE LEGAL:",
            "NIT:", "CIUDAD:", "FECHA:", "PROPONENTE:", "SUBTOTAL",
            "P√ÅGINA", "HOJA", "===", "---", "***"
        ]
        return any(keyword in upper_line for keyword in garbage_keywords)

    def _is_potential_description(self, line: str) -> bool:
        """Determina si una l√≠nea podr√≠a ser una descripci√≥n de APU."""
        return line.count(';') < 2 and not line.replace('.', '', 1).isdigit()

    def _is_valid_mo_compleja_data(self, data: Dict[str, str]) -> bool:
        """Valida datos de mano de obra en formato complejo."""
        required_fields = ["descripcion", "valor_total", "jornal_total", "rendimiento"]
        is_valid = all(data.get(k) and str(data.get(k)).strip() for k in required_fields)
        
        if not is_valid:
            logger.debug(f"‚ùå Datos MO compleja incompletos: {data}")
        
        return is_valid

    def _is_valid_mo_simple_data(self, data: Dict[str, str]) -> bool:
        """Valida datos de mano de obra en formato simple."""
        required_fields = ["descripcion", "cantidad", "precio_unit", "valor_total"]
        is_valid = all(data.get(k) and str(data.get(k)).strip() for k in required_fields)
        
        if not is_valid:
            logger.debug(f"‚ùå Datos MO simple incompletos: {data}")
        
        return is_valid

    def _is_valid_insumo_data(self, data: Dict[str, str]) -> bool:
        """Valida que los datos de insumo extra√≠dos sean coherentes."""
        has_desc = data.get("descripcion") and data["descripcion"].strip()
        has_total = data.get("valor_total") and data["valor_total"].strip()
        
        return bool(has_desc and has_total)

    def _has_data_structure(self, line: str) -> bool:
        """Comprueba si la l√≠nea parece tener datos por la cantidad de separadores."""
        return line.count(';') >= 5

    def _start_new_apu(self, raw_code: str, unit: Optional[str]):
        """Inicia contexto para un nuevo APU."""
        cleaned_code = clean_apu_code(raw_code)
        if not cleaned_code:
            logger.warning(f"‚ö†Ô∏è C√≥digo APU no v√°lido despu√©s de limpieza: '{raw_code}'")
            self.context["apu_code"] = None
            return

        self.context["apu_code"] = cleaned_code
        self.context["apu_desc"] = self.potential_apu_desc
        self.context["apu_unit"] = unit.strip() if unit else "INDEFINIDO"
        self.context["category"] = "INDEFINIDO"
        self.potential_apu_desc = ""
        self.stats["items_found"] += 1
        
        logger.debug(f"‚úÖ Nuevo APU iniciado: {cleaned_code} - {self.context['apu_desc']}")

    def _parse_insumo(self, data: Dict[str, str]):
        """Parsea y almacena un insumo general."""
        descripcion = data["descripcion"].strip()
        cantidad = self._to_numeric_safe(data["cantidad"])
        valor_total = self._to_numeric_safe(data["valor_total"])
        precio_unit = self._to_numeric_safe(data["precio_unit"])

        # Si cantidad es 0 pero tenemos total y precio, calcular cantidad
        if cantidad == 0 and valor_total > 0 and precio_unit > 0:
            cantidad = valor_total / precio_unit
            logger.debug(f"üîß Cantidad calculada: {cantidad:.4f} = {valor_total}/{precio_unit}")

        if not self._should_add_insumo(descripcion, cantidad, valor_total):
            return

        self.apus_data.append({
            "CODIGO_APU": self.context["apu_code"],
            "DESCRIPCION_APU": self.context["apu_desc"],
            "UNIDAD_APU": self.context["apu_unit"],
            "DESCRIPCION": descripcion,
            "UNIDAD": data["unidad"].strip(),
            "CANTIDAD": round(cantidad, 6),
            "VR_UNITARIO": round(precio_unit, 2),
            "VR_TOTAL": round(valor_total, 2),
            "CATEGORIA": self.context["category"],
            "RENDIMIENTO": 0.0,
            "FORMATO_ORIGEN": "INSUMO_GENERAL"
        })
        self.stats["insumos_parsed"] += 1
        logger.debug(f"‚úÖ Insumo agregado: {descripcion[:50]}...")

    def _parse_mano_de_obra_compleja(self, data: Dict[str, str]):
        """
        Parsea mano de obra en formato COMPLEJO (SAGUT extendido).
        Incluye: jornal_base, prestaciones, jornal_total, rendimiento, valor_total.
        """
        valor_total = self._to_numeric_safe(data["valor_total"])
        jornal_total = self._to_numeric_safe(data["jornal_total"])
        rendimiento = self._to_numeric_safe(data["rendimiento"])
        descripcion = data["descripcion"].strip()

        cantidad = self._calculate_mo_quantity(valor_total, jornal_total, rendimiento)

        if not self._should_add_insumo(descripcion, cantidad, valor_total):
            return

        self.apus_data.append({
            "CODIGO_APU": self.context["apu_code"],
            "DESCRIPCION_APU": self.context["apu_desc"],
            "UNIDAD_APU": self.context["apu_unit"],
            "DESCRIPCION": descripcion,
            "UNIDAD": "JOR",
            "CANTIDAD": round(cantidad, 6),
            "VR_UNITARIO": round(jornal_total, 2),
            "VR_TOTAL": round(valor_total, 2),
            "CATEGORIA": "MANO DE OBRA",
            "RENDIMIENTO": round(rendimiento, 6),
            "FORMATO_ORIGEN": "MO_COMPLEJA"
        })
        self.stats["mo_compleja_parsed"] += 1
        logger.debug(f"‚úÖ MO Compleja agregada: {descripcion[:50]}... (rend={rendimiento:.4f})")

    def _parse_mano_de_obra_simple(self, data: Dict[str, str]):
        """
        Parsea mano de obra en formato SIMPLE (CSV est√°ndar).
        Incluye: descripcion, cantidad, precio_unit, valor_total.
        Calcula el rendimiento a partir de: rendimiento = precio_unitario / valor_total
        """
        descripcion = data["descripcion"].strip()
        cantidad = self._to_numeric_safe(data["cantidad"])
        precio_unit = self._to_numeric_safe(data["precio_unit"])
        valor_total = self._to_numeric_safe(data["valor_total"])

        # Calcular rendimiento con la f√≥rmula propuesta
        rendimiento = self._calculate_rendimiento_from_values(valor_total, precio_unit)

        # Si cantidad es 0 pero tenemos total y precio, calcular cantidad
        if cantidad == 0 and valor_total > 0 and precio_unit > 0:
            cantidad = valor_total / precio_unit
            logger.debug(f"üîß Cantidad MO calculada: {cantidad:.4f} = {valor_total}/{precio_unit}")

        if not self._should_add_insumo(descripcion, cantidad, valor_total):
            return

        self.apus_data.append({
            "CODIGO_APU": self.context["apu_code"],
            "DESCRIPCION_APU": self.context["apu_desc"],
            "UNIDAD_APU": self.context["apu_unit"],
            "DESCRIPCION": descripcion,
            "UNIDAD": "JOR",
            "CANTIDAD": round(cantidad, 6),
            "VR_UNITARIO": round(precio_unit, 2),
            "VR_TOTAL": round(valor_total, 2),
            "CATEGORIA": "MANO DE OBRA",
            "RENDIMIENTO": rendimiento,
            "FORMATO_ORIGEN": "MO_SIMPLE"
        })
        self.stats["mo_simple_parsed"] += 1
        logger.debug(f"‚úÖ MO Simple agregada: {descripcion[:50]}... (rend_calc={rendimiento:.6f})")

    def _to_numeric_safe(self, s: Optional[str]) -> float:
        """Convierte string a n√∫mero de forma segura."""
        if not s:
            return 0.0
        
        # Limpiar: eliminar espacios, normalizar separadores decimales
        s_cleaned = s.replace(" ", "").replace(".", "").replace(",", ".").strip()
        
        if not s_cleaned or s_cleaned == "-":
            return 0.0
        
        try:
            return float(s_cleaned)
        except (ValueError, TypeError) as e:
            logger.debug(f"‚ö†Ô∏è No se pudo convertir '{s}' a num√©rico: {e}")
            return 0.0

    def _normalize_text(self, series: pd.Series) -> pd.Series:
        """Normaliza texto para comparaciones (sin acentos, min√∫sculas, etc.)."""
        from unidecode import unidecode
        
        normalized = series.astype(str).str.lower().str.strip()
        normalized = normalized.apply(unidecode)
        normalized = normalized.str.replace(r"[^a-z0-9\s#\-]", "", regex=True)
        normalized = normalized.str.replace(r"\s+", " ", regex=True)
        
        return normalized

Mejoras Implementadas:
1. Patr√≥n Dual para Mano de Obra

    mano_de_obra_compleja: Formato extendido con todos los campos
    mano_de_obra_simple: Formato CSV est√°ndar con fallback

2. L√≥gica de Fallback Robusta

    Intenta primero formato complejo
    Si falla, intenta formato simple
    Logging detallado para debugging

3. C√°lculo Inteligente de Rendimiento

    M√©todo _calculate_rendimiento_from_values() con validaciones
    Detecci√≥n de valores an√≥malos
    Documentaci√≥n clara de la f√≥rmula

4. M√©tricas Mejoradas

    Diferencia entre mo_compleja_parsed y mo_simple_parsed
    Nueva m√©trica unparsed_data_lines

5. Campo FORMATO_ORIGEN

    Permite rastrear de qu√© patr√≥n provino cada registro
    √ötil para auditor√≠as y debugging

6. Validaciones Adicionales

    _looks_like_mo(): Detecta mano de obra por keywords
    _is_valid_mo_simple_data(): Validaci√≥n espec√≠fica para formato simple
    Mejor manejo de divisiones por cero

7. Logging Mejorado

    Emojis para mejor visualizaci√≥n
    Logs m√°s descriptivos
    Nivel de detalle apropiado



# Variante 2 de report_parser

# En app/report_parser.py

import logging
import re
from typing import Dict, Optional

import pandas as pd

from .utils import clean_apu_code

logger = logging.getLogger(__name__)

class ReportParser:
    """
    Parsea un archivo de reporte de APUs en formato de texto (tipo SAGUT)
    utilizando una m√°quina de estados pura para manejar el formato de reporte.
    VERSI√ìN FINAL Y ROBUSTA.
    """
    PATTERNS = {
        "item_code": re.compile(r"ITEM:\s*([^;]+)", re.IGNORECASE),
        "insumo_full": re.compile(
            r"^(?P<descripcion>[^;]+);"
            r"(?P<unidad>[^;]*);"
            r"(?P<cantidad>[^;]*);"
            r"(?P<desperdicio>[^;]*);"
            r"(?P<precio_unit>[^;]*);"
            r"(?P<valor_total>[^;]*)",
            re.IGNORECASE
        ),
        # Nuevo nombre para claridad: versi√≥n compleja con jornal, prestaciones, etc.
        "mano_de_obra_compleja": re.compile(
            r"^(?P<descripcion>(M\.O\.|SISO|INGENIERO).+?);"
            r"(?P<jornal_base>[\d.,\s]+);"
            r"(?P<prestaciones>[\d%.,\s]+);"
            r"(?P<jornal_total>[\d.,\s]+);"
            r"(?P<rendimiento>[\d.,\s]+);"
            r"(?P<valor_total>[\d.,\s]+)"
        ),
        # Nueva expresi√≥n: estructura simple tipo CSV (com√∫n en exportaciones planas)
        "mano_de_obra_simple_csv": re.compile(
            r"^(?P<desc>[^;]+);[^;]*;(?P<qty>[^;]*);[^;]*;(?P<price>[^;]*);(?P<total>[^;]*)"
        ),
    }

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.apus_data = []
        self.context = {
            "apu_code": None,
            "apu_desc": "",
            "apu_unit": "",
            "category": "INDEFINIDO",
        }
        self.potential_apu_desc = ""
        # M√©tricas mejoradas
        self.stats = {
            "total_lines": 0,
            "processed_lines": 0,
            "items_found": 0,
            "insumos_parsed": 0,
            "mo_compleja_parsed": 0,
            "mo_simple_parsed": 0,
            "garbage_lines": 0
        }

    def parse(self) -> pd.DataFrame:
        logger.info(f"Iniciando el parsing del archivo: {self.file_path}")
        try:
            with open(self.file_path, "r", encoding="latin1") as f:
                for line in f:
                    self.stats["total_lines"] += 1
                    self._process_line(line)
        except Exception as e:
            logger.error(f"Error al parsear {self.file_path}: {e}", exc_info=True)
            return pd.DataFrame()

        logger.info(f"M√©tricas de parsing para {self.file_path}: {self.stats}")
        if not self.apus_data:
            logger.warning("No se extrajeron datos de APU, devolviendo DataFrame vac√≠o.")
            return pd.DataFrame()

        df = pd.DataFrame(self.apus_data)
        df.rename(columns={
            "DESCRIPCION": "DESCRIPCION_INSUMO",
            "CANTIDAD": "CANTIDAD_APU",
            "VR_UNITARIO": "PRECIO_UNIT_APU",
            "VR_TOTAL": "VALOR_TOTAL_APU",
            "UNIDAD": "UNIDAD_INSUMO"
        }, inplace=True)
        df["NORMALIZED_DESC"] = self._normalize_text(df["DESCRIPCION_INSUMO"])
        return df

    def _process_line(self, line: str):
        line = line.strip()
        if not line:
            return

        self.stats["processed_lines"] += 1

        if self._is_garbage_line(line):
            self.stats["garbage_lines"] += 1
            return

        upper_line = line.upper()

        match_item = self.PATTERNS["item_code"].search(upper_line)
        if match_item:
            raw_code = match_item.group(1).strip()
            unit_match = re.search(r"UNIDAD:\s*([A-Z0-9/%]+)", upper_line)
            unit = unit_match.group(1) if unit_match else "INDEFINIDO"

            logger.debug(f"ITEM detectado: c√≥digo='{raw_code}', unidad='{unit}'")
            self._start_new_apu(raw_code, unit)
            return

        category_keywords = {"MATERIALES", "MANO DE OBRA", "EQUIPO", "OTROS"}
        first_part = line.split(';', 1)[0].strip().upper()

        for category in category_keywords:
            if category in first_part:
                self.context["category"] = category
                logger.debug(f"Categor√≠a establecida: {category}")
                return

        if not self.context["apu_code"]:
            if self._is_potential_description(line):
                self.potential_apu_desc = line.split(';', 1)[0].strip()
            return

        # Procesar seg√∫n categor√≠a
        if self.context["category"] == "MANO DE OBRA":
            processed = self._try_parse_mo_line(line)
            if not processed and self._is_potential_description(line):
                self.potential_apu_desc = line.split(';', 1)[0].strip()
            return

        # Otros tipos (materiales, equipo, etc.)
        processed = self._try_parse_data_line(line)
        if not processed and self._is_potential_description(line):
            self.potential_apu_desc = line.split(';', 1)[0].strip()

    def _try_parse_mo_line(self, line: str) -> bool:
        """
        Intenta parsear l√≠nea de MO con dos niveles: primero compleja, luego simple.
        Retorna True si alguno fue exitoso.
        """
        # Primero: intentar con estructura completa
        match_compleja = self.PATTERNS["mano_de_obra_compleja"].match(line)
        if match_compleja:
            data = match_compleja.groupdict()
            if self._is_valid_mo_compleja_data(data):
                self._parse_mano_de_obra_compleja(data)
                return True

        # Segundo: fallback a estructura simple
        match_simple = self.PATTERNS["mano_de_obra_simple_csv"].match(line)
        if match_simple:
            data = match_simple.groupdict()
            if self._is_valid_mo_simple_data(data):
                self._parse_mano_de_obra_simple(data)
                return True

        # Si tiene estructura pero no pudo parsearse
        if self._has_data_structure(line):
            logger.warning(f"L√≠nea de MO con estructura no reconocida: {line[:100]}")

        return False

    def _try_parse_data_line(self, line: str) -> bool:
        """Parsea l√≠neas de insumos u otras categor√≠as."""
        match_insumo = self.PATTERNS["insumo_full"].match(line)
        if match_insumo:
            data = match_insumo.groupdict()
            if self._is_valid_insumo_data(data):
                self._parse_insumo(data)
                return True

        if self._has_data_structure(line):
            logger.warning(f"L√≠nea con estructura no parseada: {line[:100]}")

        return False

    def _parse_mano_de_obra_compleja(self, data: Dict[str, str]):
        valor_total = self._to_numeric_safe(data["valor_total"])
        jornal_total = self._to_numeric_safe(data["jornal_total"])
        rendimiento = self._to_numeric_safe(data["rendimiento"])
        descripcion = data["descripcion"].strip()

        cantidad = self._calculate_mo_quantity(valor_total, jornal_total, rendimiento)

        if not self._should_add_insumo(descripcion, cantidad, valor_total):
            return

        self.apus_data.append({
            "CODIGO_APU": self.context["apu_code"],
            "DESCRIPCION_APU": self.context["apu_desc"],
            "UNIDAD_APU": self.context["apu_unit"],
            "DESCRIPCION": descripcion,
            "UNIDAD": "JOR",
            "CANTIDAD": cantidad,
            "VR_UNITARIO": jornal_total,
            "VR_TOTAL": valor_total,
            "CATEGORIA": "MANO DE OBRA",
            "RENDIMIENTO": rendimiento,
        })
        self.stats["mo_compleja_parsed"] += 1

    def _parse_mano_de_obra_simple(self, data: Dict[str, str]):
        desc = data["desc"].strip()
        qty_str = data.get("qty", "")
        price_str = data.get("price", "")
        total_str = data.get("total", "")

        cantidad = self._to_numeric_safe(qty_str)
        precio_unitario = self._to_numeric_safe(price_str)
        valor_total = self._to_numeric_safe(total_str)

        # Validaci√≥n m√≠nima
        if not desc or valor_total <= 0 or precio_unitario <= 0:
            logger.debug(f"MO simple descartada por datos inv√°lidos: {desc} | {precio_unitario} | {valor_total}")
            return

        # Calcular rendimiento: horas por unidad producida (ej: 8.0 / (total / unitario))
        # Interpretamos: Rendimiento = horas hombre por unidad de producto
        try:
            rendimiento = precio_unitario / valor_total if valor_total != 0 else 0.0
        except ZeroDivisionError:
            rendimiento = 0.0

        if rendimiento < 0:
            rendimiento = 0.0

        if not self._should_add_insumo(desc, cantidad, valor_total):
            return

        # Si no viene cantidad, inferimos: cantidad = total / precio_unitario
        if cantidad <= 0 and precio_unitario > 0:
            cantidad = valor_total / precio_unitario

        self.apus_data.append({
            "CODIGO_APU": self.context["apu_code"],
            "DESCRIPCION_APU": self.context["apu_desc"],
            "UNIDAD_APU": self.context["apu_unit"],
            "DESCRIPCION": desc,
            "UNIDAD": "JOR",
            "CANTIDAD": cantidad,
            "VR_UNITARIO": precio_unitario,
            "VR_TOTAL": valor_total,
            "CATEGORIA": "MANO DE OBRA",
            "RENDIMIENTO": rendimiento,
        })
        self.stats["mo_simple_parsed"] += 1
        logger.debug(f"MO simple parseada: {desc}, rend={rendimiento:.4f}")

    def _calculate_mo_quantity(self, valor_total: float, jornal_total: float, rendimiento: float) -> float:
        if jornal_total <= 0:
            return 0.0

        if valor_total > 0:
            cantidad_base = valor_total / jornal_total
        else:
            cantidad_base = 0

        if rendimiento > 0:
            if 0 < rendimiento < 0.2:
                logger.debug(f"Rendimiento muy bajo ({rendimiento}), interpretando como horas")
                cantidad_base *= 8
            elif rendimiento > 10:
                logger.debug(f"Rendimiento inusualmente alto: {rendimiento}")

        return cantidad_base

    def _should_add_insumo(self, descripcion: str, cantidad: float, valor_total: float) -> bool:
        if not descripcion or len(descripcion.strip()) < 2:
            return False

        invalid_descriptions = {"", "-", "N/A", "NO APLICA", "S/D"}
        if descripcion.upper() in invalid_descriptions:
            return False

        if cantidad <= 0 and valor_total <= 0:
            return False

        if 0 < cantidad < 1e-10 or 0 < valor_total < 0.001:
            logger.debug(f"Valores muy peque√±os descartados: cantidad={cantidad}, total={valor_total}")
            return False

        return True

    def _is_garbage_line(self, line: str) -> bool:
        upper_line = line.upper()
        garbage_keywords = [
            "FORMATO DE AN√ÅLISIS", "COSTOS DIRECTOS", "COSTO TOTAL",
            "PRESUPUESTO OFICIAL", "CONSTRUCTOR:", "REPRESENTANTE LEGAL:",
            "NIT:", "CIUDAD:", "FECHA:", "PROPONENTE:", "SUBTOTAL"
        ]
        return any(keyword in upper_line for keyword in garbage_keywords)

    def _is_potential_description(self, line: str) -> bool:
        return line.count(';') < 2 and not line.replace('.', '', 1).isdigit()

    def _is_valid_mo_compleja_data(self, data: Dict[str, str]) -> bool:
        required = ["valor_total", "jornal_total", "rendimiento"]
        return all(data.get(k) for k in required)

    def _is_valid_mo_simple_data(self, data: Dict[str, str]) -> bool:
        required = ["desc", "price", "total"]
        return all(data.get(k) for k in required)

    def _is_valid_insumo_data(self, data: Dict[str, str]) -> bool:
        return all(data.get(k) for k in ["descripcion", "valor_total"])

    def _has_data_structure(self, line: str) -> bool:
        return line.count(';') >= 5

    def _start_new_apu(self, raw_code: str, unit: Optional[str]):
        cleaned_code = clean_apu_code(raw_code)
        if not cleaned_code:
            self.context["apu_code"] = None
            return

        self.context["apu_code"] = cleaned_code
        self.context["apu_desc"] = self.potential_apu_desc
        self.context["apu_unit"] = unit.strip() if unit else "INDEFINIDO"
        self.context["category"] = "INDEFINIDO"
        self.potential_apu_desc = ""
        self.stats["items_found"] += 1

    def _parse_insumo(self, data: Dict[str, str]):
        descripcion = data["descripcion"].strip()
        cantidad = self._to_numeric_safe(data["cantidad"])
        valor_total = self._to_numeric_safe(data["valor_total"])
        precio_unit = self._to_numeric_safe(data["precio_unit"])

        if not self._should_add_insumo(descripcion, cantidad, valor_total):
            return

        if cantidad == 0 and valor_total > 0 and precio_unit > 0:
            cantidad = valor_total / precio_unit

        self.apus_data.append({
            "CODIGO_APU": self.context["apu_code"],
            "DESCRIPCION_APU": self.context["apu_desc"],
            "UNIDAD_APU": self.context["apu_unit"],
            "DESCRIPCION": descripcion,
            "UNIDAD": data["unidad"].strip(),
            "CANTIDAD": cantidad,
            "VR_UNITARIO": precio_unit,
            "VR_TOTAL": valor_total,
            "CATEGORIA": self.context["category"],
            "RENDIMIENTO": 0.0,
        })
        self.stats["insumos_parsed"] += 1

    def _to_numeric_safe(self, s: Optional[str]) -> float:
        if not s:
            return 0.0
        s_cleaned = s.replace(" ", "").replace(".", "").replace(",", ".").strip()
        if not s_cleaned or s_cleaned == "-":
            return 0.0
        try:
            return float(s_cleaned)
        except (ValueError, TypeError):
            return 0.0

    def _normalize_text(self, series: pd.Series) -> pd.Series:
        from unidecode import unidecode
        normalized = series.astype(str).str.lower().str.strip()
        normalized = normalized.apply(unidecode)
        normalized = normalized.str.replace(r"[^a-z0-9\s#\-]", "", regex=True)
        normalized = normalized.str.replace(r"\s+", " ", regex=True)
        return normalized

######## 
‚úÖ Beneficios del refinamiento:
Caracter√≠stica	Beneficio
‚úÖ Dos tipos de MO	Soporta tanto formatos detallados como exportaciones planas
‚úÖ Fallback claro	No falla si uno de los formatos no aplica
‚úÖ M√©tricas separadas	Ayuda a monitorear qu√© tipo de datos se est√°n recibiendo
‚úÖ Rendimiento calculado	Infiere informaci√≥n √∫til incluso cuando falta
‚úÖ Logs descriptivos	Facilita debugging en producci√≥n
üìå Recomendaci√≥n adicional (opcional):

Si esperas m√°s variantes, podr√≠as considerar un sistema de perfiles o formatos detectados din√°micamente, pero por ahora este dise√±o es simple, robusto y escalable.