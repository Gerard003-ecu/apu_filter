>       if pd.isna(value):
E       ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()

models/probability_models.py:20: ValueError
___________________________ TestProbabilityModels.test_simulation_with_min_cost_threshold ____________________________

self = <tests.test_models.TestProbabilityModels testMethod=test_simulation_with_min_cost_threshold>

    def test_simulation_with_min_cost_threshold(self):
        """
        Verifica que el umbral m√≠nimo funcione correctamente (aunque no es expuesto en API p√∫blica,
        el c√≥digo interno lo usa ‚Äî no es necesario exponerlo, pero debe funcionar).
        """
        # Un costo de 50, con umbral 100 ‚Üí debe ignorarse
        apu_details = [{"VR_TOTAL": 50, "CANTIDAD": 2}]  # base = 100 ‚Üí igual al umbral
        result = run_monte_carlo_simulation(apu_details, num_simulations=100, min_cost_threshold=100)
        # Como base = 100, no se ignora
>       self.assertIsNotNone(result['mean'])
E       AssertionError: unexpectedly None

tests/test_models.py:299: AssertionError
______________________ TestProcessAllFilesIntegration.test_process_all_files_empty_presupuesto _______________________

self = <tests.test_procesador_csv.TestProcessAllFilesIntegration testMethod=test_process_all_files_empty_presupuesto>

    def test_process_all_files_empty_presupuesto(self):
        """Prueba manejo de presupuesto vac√≠o."""
        with patch('app.procesador_csv.PresupuestoProcessor') as mock_class:
            mock_processor = MagicMock()
            mock_class.return_value = mock_processor
            mock_processor.process.return_value = pd.DataFrame()
    
            resultado = process_all_files(
                self.presupuesto_path,
                self.apus_path,
                self.insumos_path,
                TEST_CONFIG
            )
    
            self.assertIn("error", resultado)
>           self.assertIn("presupuesto", resultado["error"].lower())
E           AssertionError: 'presupuesto' not found in 'error cr√≠tico en el pipeline: division by zero'

tests/test_procesador_csv.py:939: AssertionError
------------------------------------------------ Captured stderr call ------------------------------------------------
12:12:34 - INFO - ================================================================================
12:12:34 - INFO - üöÄ Iniciando procesamiento de archivos con patr√≥n pipeline...
12:12:34 - INFO - ================================================================================
12:12:34 - INFO - ‚úÖ Insumos cargados: 4 insumos √∫nicos
12:12:34 - INFO - Starting line-by-line parsing of: tmpjqveawse.csv
12:12:34 - INFO - File read successfully with encoding: utf-8
12:12:34 - INFO - Parsing complete. Extracted 0 raw records.
12:12:34 - WARNING - No records were extracted. The file might be empty or in an unexpected format.
12:12:34 - WARNING - Lista de registros vac√≠a
12:12:34 - INFO - ‚úÖ Parser Lark inicializado correctamente
12:12:34 - INFO - üöÄ Iniciando procesamiento de 0 registros...
12:12:34 - INFO - ============================================================
12:12:34 - INFO - üìä RESUMEN DE PROCESAMIENTO
12:12:34 - INFO - ============================================================
12:12:34 - INFO - üì• Registros de entrada: 0
12:12:34 - INFO - ‚úÖ Registros procesados: 0
12:12:34 - ERROR - ‚ùå Error cr√≠tico en el pipeline: division by zero
Traceback (most recent call last):
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/procesador_csv.py", line 1339, in _do_processing
    final_context = pipeline.run(initial_context)
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/procesador_csv.py", line 108, in run
    context = step.execute(context)
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/procesador_csv.py", line 290, in execute
    df_apus_raw = processor.process_all()
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/apu_processor.py", line 535, in process_all
    self._log_stats()
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/apu_processor.py", line 878, in _log_stats
    logger.info(f"üìà Tasa de √©xito: {(total_output/total_input*100):.1f}%")
ZeroDivisionError: division by zero
------------------------------------------------- Captured log call --------------------------------------------------
INFO     app.procesador_csv:procesador_csv.py:1313 ================================================================================
INFO     app.procesador_csv:procesador_csv.py:1314 üöÄ Iniciando procesamiento de archivos con patr√≥n pipeline...
INFO     app.procesador_csv:procesador_csv.py:1315 ================================================================================
INFO     app.procesador_csv:procesador_csv.py:539 ‚úÖ Insumos cargados: 4 insumos √∫nicos
INFO     app.report_parser_crudo:report_parser_crudo.py:100 Starting line-by-line parsing of: tmpjqveawse.csv
INFO     app.report_parser_crudo:report_parser_crudo.py:127 File read successfully with encoding: utf-8
INFO     app.report_parser_crudo:report_parser_crudo.py:110 Parsing complete. Extracted 0 raw records.
WARNING  app.report_parser_crudo:report_parser_crudo.py:112 No records were extracted. The file might be empty or in an unexpected format.
WARNING  app.apu_processor:apu_processor.py:486 Lista de registros vac√≠a
INFO     app.apu_processor:apu_processor.py:504 ‚úÖ Parser Lark inicializado correctamente
INFO     app.apu_processor:apu_processor.py:516 üöÄ Iniciando procesamiento de 0 registros...
INFO     app.apu_processor:apu_processor.py:873 ============================================================
INFO     app.apu_processor:apu_processor.py:874 üìä RESUMEN DE PROCESAMIENTO
INFO     app.apu_processor:apu_processor.py:875 ============================================================
INFO     app.apu_processor:apu_processor.py:876 üì• Registros de entrada: 0
INFO     app.apu_processor:apu_processor.py:877 ‚úÖ Registros procesados: 0
ERROR    app.procesador_csv:procesador_csv.py:1363 ‚ùå Error cr√≠tico en el pipeline: division by zero
Traceback (most recent call last):
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/procesador_csv.py", line 1339, in _do_processing
    final_context = pipeline.run(initial_context)
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/procesador_csv.py", line 108, in run
    context = step.execute(context)
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/procesador_csv.py", line 290, in execute
    df_apus_raw = processor.process_all()
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/apu_processor.py", line 535, in process_all
    self._log_stats()
  File "/home/gerardo/Documentos/GitHub/apu_filter/app/apu_processor.py", line 878, in _log_stats
    logger.info(f"üìà Tasa de √©xito: {(total_output/total_input*100):.1f}%")
ZeroDivisionError: division by zero
________________________________________________ test_normalize_unit _________________________________________________

    def test_normalize_unit():
        """Prueba que normalize_unit normaliza correctamente las unidades."""
        assert normalize_unit("m2") == "M2"
        assert normalize_unit("KM") == "KM"
        assert normalize_unit("hora") == "HORA"
        assert normalize_unit("Viaje") == "VIAJE"
        assert normalize_unit("ton-km") == "TON-KM"
        assert normalize_unit("xyz") == "XYZ"  # No reconocida ‚Üí se mantiene
        assert normalize_unit(None) == "UNIDAD"
>       assert normalize_unit("") == "UNIDAD"
E       AssertionError: assert '' == 'UNIDAD'
E         
E         - UNIDAD

tests/test_schemas.py:104: AssertionError
_____________________________________________ test_normalize_description _____________________________________________

    def test_normalize_description():
        """Prueba que normalize_description limpia y normaliza descripciones."""
        assert normalize_description("  Cemento Portland  ") == "CEMENTO PORTLAND"
>       assert normalize_description("Cemento con tilde: √°cido") == "CEMENTO CON TILDE: CIDO"
E       AssertionError: assert 'CEMENTO CON TILDE: ACIDO' == 'CEMENTO CON TILDE: CIDO'
E         
E         - CEMENTO CON TILDE: CIDO
E         + CEMENTO CON TILDE: ACIDO
E         ?                    +

tests/test_schemas.py:111: AssertionError
______________________________________ test_insumo_procesado_creacion_correcta _______________________________________

base_insumo_data = {'cantidad': 10.5, 'categoria': 'SUMINISTRO', 'codigo_apu': 'APU-001', 'descripcion_apu': 'Construcci√≥n de muro de concreto', ...}

    def test_insumo_procesado_creacion_correcta(base_insumo_data):
        """Prueba que InsumoProcesado se crea correctamente y normaliza campos."""
        insumo = InsumoProcesado(**base_insumo_data)
        assert insumo.codigo_apu == "APU-001"
>       assert insumo.descripcion_apu == "CONSTRUCCI√ìN DE MURO DE CONCRETO"
E       AssertionError: assert 'CONSTRUCCION DE MURO DE CONCRETO' == 'CONSTRUCCI√ìN DE MURO DE CONCRETO'
E         
E         - CONSTRUCCI√ìN DE MURO DE CONCRETO
E         ?           ^
E         + CONSTRUCCION DE MURO DE CONCRETO
E         ?           ^

tests/test_schemas.py:131: AssertionError
_________________________________________ test_mano_de_obra_unidad_no_tipica _________________________________________

mano_obra_data = {'cantidad': 2.0, 'categoria': 'MANO_DE_OBRA', 'codigo_apu': 'APU-002', 'descripcion_apu': 'Instalaci√≥n de tuber√≠as', ...}

    def test_mano_de_obra_unidad_no_tipica(mano_obra_data):
        """Prueba que ManoDeObra emite advertencia si unidad no es t√≠pica."""
        mano_obra_data["unidad_apu"] = "KG"
>       with pytest.warns(UserWarning, match="unidades 'KG' o 'BOLSA' no son t√≠picas"):
E       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) matching the regex were emitted.
E        Regex: unidades 'KG' o 'BOLSA' no son t√≠picas
E        Emitted warnings: [ UserWarning("Mano de Obra: unidades 'KG' o 'PERSONA' no son t√≠picas. Unidades esperadas: {'MES', 'DIA', 'SEMANA', 'HORA'}")].

tests/test_schemas.py:226: Failed
__________________________________________ test_transporte_unidad_no_tipica __________________________________________

transporte_data = {'cantidad': 5.0, 'categoria': 'TRANSPORTE', 'codigo_apu': 'APU-004', 'descripcion_apu': 'Transporte de arena', ...}

    def test_transporte_unidad_no_tipica(transporte_data):
        """Prueba que Transporte emite advertencia si unidad no es t√≠pica."""
        transporte_data["unidad_apu"] = "KG"
>       with pytest.warns(UserWarning, match="unidad 'KG' o 'VIAJE' inusual"):
E       Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.
E        Emitted warnings: [].

tests/test_schemas.py:260: Failed
_________________________________________ test_validate_insumo_data_exitoso __________________________________________

base_insumo_data = {'cantidad': 10.5, 'categoria': 'SUMINISTRO', 'codigo_apu': 'APU-001', 'descripcion_apu': 'Construcci√≥n de muro de concreto', ...}

    def test_validate_insumo_data_exitoso(base_insumo_data):
        """Prueba que validate_insumo_data limpia y normaliza correctamente."""
        cleaned = validate_insumo_data(base_insumo_data)
>       assert cleaned["unidad_apu"] == "M2"  # Normalizado
E       AssertionError: assert 'm2' == 'M2'
E         
E         - M2
E         + m2

tests/test_schemas.py:290: AssertionError
__________________________________ test_insumo_procesado_con_normalized_desc_manual __________________________________

base_insumo_data = {'cantidad': 10.5, 'categoria': 'SUMINISTRO', 'codigo_apu': 'APU-001', 'descripcion_apu': 'Construcci√≥n de muro de concreto', ...}

    def test_insumo_procesado_con_normalized_desc_manual(base_insumo_data):
        """Prueba que si se pasa normalized_desc, se ignora y se genera de nuevo."""
        base_insumo_data["descripcion_insumo"] = "Cemento"
        base_insumo_data["normalized_desc"] = "DESCRIPCION_MANUAL"
        insumo = InsumoProcesado(**base_insumo_data)
>       assert insumo.normalized_desc == "CEMENTO"  # No se usa el valor manual
E       AssertionError: assert 'DESCRIPCION_MANUAL' == 'CEMENTO'
E         
E         - CEMENTO
E         + DESCRIPCION_MANUAL

tests/test_schemas.py:341: AssertionError
___________________________________ test_insumo_procesado_con_categoria_diferente ____________________________________

base_insumo_data = {'cantidad': 10.5, 'categoria': 'OTRO', 'codigo_apu': 'APU-001', 'descripcion_apu': 'Construcci√≥n de muro de concreto', ...}

    def test_insumo_procesado_con_categoria_diferente(base_insumo_data):
        """Prueba que categoria se sobrescribe por tipo_insumo."""
        base_insumo_data["categoria"] = "OTRO"
        base_insumo_data["tipo_insumo"] = "SUMINISTRO"
        insumo = InsumoProcesado(**base_insumo_data)
>       assert insumo.categoria == "SUMINISTRO"  # No se mantiene el valor dado
E       AssertionError: assert 'OTRO' == 'SUMINISTRO'
E         
E         - SUMINISTRO
E         + OTRO

tests/test_schemas.py:349: AssertionError
_____________________________ TestTextNormalization.test_normalize_text_type_conversion ______________________________

self = <tests.test_utils.TestTextNormalization testMethod=test_normalize_text_type_conversion>

    def test_normalize_text_type_conversion(self):
        """Prueba conversi√≥n de tipos a string."""
        test_cases = [
            (123, "123"),
            (45.67, "4567"),  # El punto se elimina sin preserve_special_chars
            (True, "true"),
            (None, "none"),
            ([], ""),  # Lista vac√≠a se convierte a "[]" y luego se limpian los brackets
        ]
    
        for input_val, expected in test_cases:
            with self.subTest(input=input_val):
>               result = utils.normalize_text(input_val)
E               TypeError: unhashable type: 'list'

tests/test_utils.py:117: TypeError
______________________________ TestTextNormalization.test_safe_normalize_error_handling ______________________________

self = <tests.test_utils.TestTextNormalization testMethod=test_safe_normalize_error_handling>

    def test_safe_normalize_error_handling(self):
        """Prueba manejo de errores en _safe_normalize."""
        # Crear un objeto que cause error al convertir a string
        class BadObject:
            def __str__(self):
                raise ValueError("Cannot convert")
    
        series = pd.Series([BadObject(), "texto normal"])
    
>       with patch('utils.logger.warning') as mock_warning:

tests/test_utils.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
______________________________ TestNumericConversion.test_parse_number_currency_formats ______________________________

self = <tests.test_utils.TestNumericConversion testMethod=test_parse_number_currency_formats>

    def test_parse_number_currency_formats(self):
        """Prueba conversi√≥n con s√≠mbolos de moneda."""
        test_cases = [
            ("$1,234.56", 1234.56),
            ("‚Ç¨ 1.234,56", 1234.56),  # Formato europeo
            ("¬£999.99", 999.99),
            ("¬•10,000", 10000.0),
            ("50%", 50.0),
            ("$ 100 ", 100.0),
        ]
    
        for input_val, expected in test_cases:
            with self.subTest(input=input_val):
                result = utils.parse_number(input_val)
>               self.assertAlmostEqual(result, expected, places=2)
E               AssertionError: 1.23456 != 1234.56 within 2 places (1233.3254399999998 difference)

tests/test_utils.py:231: AssertionError
________________________ TestNumericConversion.test_parse_number_decimal_separator_detection _________________________

self = <tests.test_utils.TestNumericConversion testMethod=test_parse_number_decimal_separator_detection>

    def test_parse_number_decimal_separator_detection(self):
        """Prueba detecci√≥n autom√°tica del separador decimal."""
        test_cases = [
            ("1,234.56", 1234.56),    # Formato US: coma para miles
            ("1.234,56", 1234.56),    # Formato EU: punto para miles
            ("1234,56", 1234.56),     # Solo coma decimal
            ("1234.56", 1234.56),     # Solo punto decimal
            ("1,000", 1000.0),        # Coma para miles (3 d√≠gitos despu√©s)
            ("1,50", 1.50),           # Coma decimal (menos de 3 d√≠gitos)
        ]
    
        for input_val, expected in test_cases:
            with self.subTest(input=input_val):
                result = utils.parse_number(input_val, decimal_separator="auto")
>               self.assertAlmostEqual(result, expected, places=2)
E               AssertionError: 1.23456 != 1234.56 within 2 places (1233.3254399999998 difference)

tests/test_utils.py:247: AssertionError
_________________________________ TestNumericConversion.test_parse_number_edge_cases _________________________________

self = <tests.test_utils.TestNumericConversion testMethod=test_parse_number_edge_cases>

    def test_parse_number_edge_cases(self):
        """Prueba casos l√≠mite en conversi√≥n num√©rica."""
        test_cases = [
            ("abc", 0.0),                    # Texto no num√©rico
            ("12.34.56.78", 12345678.0),     # M√∫ltiples puntos
            ("1.234.567,89", 1234567.89),    # Formato EU complejo
            ("-", 0.0),                      # Solo signo
            ("+", 0.0),                      # Solo signo positivo
            ("1.2.3", 12.3),                 # M√∫ltiples puntos, √∫ltimo como decimal
        ]
    
        for input_val, expected in test_cases:
            with self.subTest(input=input_val):
                result = utils.parse_number(input_val)
>               self.assertAlmostEqual(result, expected, places=2)
E               AssertionError: 123456.78 != 12345678.0 within 2 places (12222221.22 difference)

tests/test_utils.py:273: AssertionError
_______________________________ TestNumericConversion.test_parse_number_special_values _______________________________

self = <tests.test_utils.TestNumericConversion testMethod=test_parse_number_special_values>

    def test_parse_number_special_values(self):
        """Prueba manejo de valores especiales."""
        test_cases = [
            (None, 0.0),
            ("", 0.0),
            ("   ", 0.0),
            (float('nan'), 0.0),
            (np.nan, 0.0),
            (float('inf'), 0.0),
            (float('-inf'), 0.0),
            (pd.NA, 0.0),  # Pandas NA
        ]
    
        for input_val, expected in test_cases:
            with self.subTest(input=str(input_val)):
                result = utils.parse_number(input_val)
>               self.assertEqual(result, expected)
E               AssertionError: inf != 0.0

tests/test_utils.py:215: AssertionError
_________________________________ TestAPUCode.test_clean_apu_code_validation_invalid _________________________________

self = <tests.test_utils.TestAPUCode testMethod=test_clean_apu_code_validation_invalid>

    def test_clean_apu_code_validation_invalid(self):
        """Prueba validaci√≥n de c√≥digos APU inv√°lidos."""
        # C√≥digo vac√≠o
        with self.assertRaises(ValueError) as context:
            utils.clean_apu_code("", validate_format=True)
        self.assertIn("no puede estar vac√≠o", str(context.exception))
    
        # C√≥digo demasiado corto
        with self.assertRaises(ValueError) as context:
            utils.clean_apu_code("A", validate_format=True)
        self.assertIn("demasiado corto", str(context.exception))
    
        # C√≥digo sin n√∫meros (deber√≠a generar warning pero no error)
>       with patch('utils.logger.warning') as mock_warning:

tests/test_utils.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
___________________________ TestUnitNormalization.test_normalize_unit_invalid_returns_und ____________________________

self = <tests.test_utils.TestUnitNormalization testMethod=test_normalize_unit_invalid_returns_und>

    def test_normalize_unit_invalid_returns_und(self):
        """Prueba que unidades inv√°lidas retornan 'UND'."""
        test_cases = [
            "",
            None,
            "INVALID_UNIT_XYZ",
            "@#$%",
            "123",
            "ABC",
            12345,  # N√∫mero
        ]
    
        for input_unit in test_cases:
            with self.subTest(input=input_unit):
                result = utils.normalize_unit(input_unit)
>               self.assertEqual(result, 'UND')
E               AssertionError: 'INVALID_UNIT_XYZ' != 'UND'
E               - INVALID_UNIT_XYZ
E               + UND

tests/test_utils.py:463: AssertionError
_________________________________ TestUnitNormalization.test_normalize_unit_logging __________________________________

self = <tests.test_utils.TestUnitNormalization testMethod=test_normalize_unit_logging>

    def test_normalize_unit_logging(self):
        """Prueba que se registren logs para unidades no reconocidas."""
>       with patch('utils.logger.debug') as mock_debug:

tests/test_utils.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
______________________________ TestUnitNormalization.test_normalize_unit_standard_units ______________________________

self = <tests.test_utils.TestUnitNormalization testMethod=test_normalize_unit_standard_units>

    def test_normalize_unit_standard_units(self):
        """Prueba normalizaci√≥n de unidades est√°ndar."""
        # Probar todas las unidades en STANDARD_UNITS
        for unit in utils.STANDARD_UNITS:
            with self.subTest(unit=unit):
                result = utils.normalize_unit(unit.lower())
>               self.assertEqual(result, unit)
E               AssertionError: 'L' != 'LT'
E               - L
E               + LT
E               ?  +

tests/test_utils.py:406: AssertionError
__________________________________ TestFileReading.test_safe_read_nonexistent_file ___________________________________

self = <tests.test_utils.TestFileReading testMethod=test_safe_read_nonexistent_file>

    def test_safe_read_nonexistent_file(self):
        """Prueba manejo de archivo inexistente."""
        nonexistent = self.temp_path / "nonexistent.csv"
    
>       with patch('utils.logger.error') as mock_error:

tests/test_utils.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
_________________________________ TestFileReading.test_safe_read_unsupported_format __________________________________

self = <tests.test_utils.TestFileReading testMethod=test_safe_read_unsupported_format>

    def test_safe_read_unsupported_format(self):
        """Prueba manejo de formato no soportado."""
        txt_file = self.temp_path / "test.txt"
        txt_file.write_text("contenido de texto")
    
>       with patch('utils.logger.error') as mock_error:

tests/test_utils.py:561: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
_____________________________ TestAnalysisDetection.test_detect_outliers_modified_zscore _____________________________

self = <tests.test_utils.TestAnalysisDetection testMethod=test_detect_outliers_modified_zscore>

    def test_detect_outliers_modified_zscore(self):
        """Prueba detecci√≥n con modified z-score (robusto)."""
        # Serie con outliers y valores constantes
        series = pd.Series([50] * 20 + [100, 200, 300])
    
        outliers, bounds = utils.detect_outliers(
            series,
            method='modified_zscore',
            threshold=3.5,
            return_bounds=True
        )
    
        self.assertIn('median', bounds)
        self.assertIn('mad', bounds)
    
        # Los valores extremos deben ser outliers
>       self.assertTrue(outliers.iloc[-1])  # 300
E       AssertionError: False is not true

tests/test_utils.py:870: AssertionError
______________________ TestDataFrameManipulation.test_find_and_rename_columns_conflict_warning _______________________

self = <tests.test_utils.TestDataFrameManipulation testMethod=test_find_and_rename_columns_conflict_warning>

    def test_find_and_rename_columns_conflict_warning(self):
        """Prueba warning cuando hay conflictos de mapeo."""
        df = pd.DataFrame({
            'codigo_1': [1],
            'codigo_2': [2],
            'descripcion': ['texto']
        })
    
        column_map = {
            'CODIGO': ['codigo']  # Ambas columnas coinciden
        }
    
>       with patch('utils.logger.warning') as mock_warning:

tests/test_utils.py:999: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
__________________________ TestDataFrameManipulation.test_find_and_rename_unmapped_logging ___________________________

self = <tests.test_utils.TestDataFrameManipulation testMethod=test_find_and_rename_unmapped_logging>

    def test_find_and_rename_unmapped_logging(self):
        """Prueba logging de columnas no mapeadas."""
        df = pd.DataFrame({
            'col1': [1],
            'col2': [2],
            'col3': [3],
            'col4': [4]
        })
    
        column_map = {
            'MAPPED': ['col1']
        }
    
>       with patch('utils.logger.debug') as mock_debug:

tests/test_utils.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1431: in __enter__
    self.target = self.getter()
../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1618: in <lambda>
    getter = lambda: _importer(target)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

target = 'utils.logger'

    def _importer(target):
        components = target.split('.')
        import_path = components.pop(0)
>       thing = __import__(import_path)
E       ModuleNotFoundError: No module named 'utils'

../../../miniconda3/envs/ap_filter_env/lib/python3.10/unittest/mock.py:1257: ModuleNotFoundError
____________________________________ TestSerialization.test_sanitize_numpy_types _____________________________________

self = <tests.test_utils.TestSerialization testMethod=test_sanitize_numpy_types>

    def test_sanitize_numpy_types(self):
        """Prueba sanitizaci√≥n de tipos NumPy."""
        data = {
            'np_int32': np.int32(42),
            'np_int64': np.int64(100),
            'np_float32': np.float32(3.14),
            'np_float64': np.float64(2.71),
            'np_bool': np.bool_(True),
            'np_array': np.array([1, 2, 3]),
            'np_nan': np.nan,
            'np_inf': np.inf,
            'np_ninf': -np.inf,
        }
    
        result = utils.sanitize_for_json(data)
    
        # Verificar conversi√≥n a tipos nativos
        self.assertIsInstance(result['np_int32'], int)
        self.assertIsInstance(result['np_int64'], int)
        self.assertIsInstance(result['np_float32'], float)
        self.assertIsInstance(result['np_float64'], float)
        self.assertIsInstance(result['np_bool'], bool)
        self.assertIsInstance(result['np_array'], list)
        self.assertIsNone(result['np_nan'])
>       self.assertIsNone(result['np_inf'])
E       AssertionError: inf is not None

tests/test_utils.py:1092: AssertionError
____________________________ TestAdditionalFunctions.test_calculate_statistics_all_nulls _____________________________

self = <tests.test_utils.TestAdditionalFunctions testMethod=test_calculate_statistics_all_nulls>

    def test_calculate_statistics_all_nulls(self):
        """Prueba estad√≠sticas con todos valores nulos."""
        null_series = pd.Series([None, np.nan, pd.NA])
        stats = utils.calculate_statistics(null_series)
    
        self.assertEqual(stats['count'], 0)
        self.assertIsNone(stats['mean'])
        # null_percentage debe manejarse correctamente
>       self.assertIn('null_percentage', stats)
E       AssertionError: 'null_percentage' not found in {'count': 0, 'mean': None, 'std': None, 'min': None, 'max': None, 'median': None}

tests/test_utils.py:1240: AssertionError
_____________________________ TestAdditionalFunctions.test_calculate_statistics_complete _____________________________

self = <tests.test_utils.TestAdditionalFunctions testMethod=test_calculate_statistics_complete>

    def test_calculate_statistics_complete(self):
        """Prueba c√°lculo completo de estad√≠sticas."""
        series = pd.Series([1, 2, 3, 4, 5, None, 7, 8, 9, 10])
        stats = utils.calculate_statistics(series)
    
        # Verificar todas las estad√≠sticas
        self.assertEqual(stats['count'], 9)
        self.assertAlmostEqual(stats['mean'], 5.444, places=2)
        self.assertAlmostEqual(stats['std'], 3.2, places=1)
        self.assertEqual(stats['min'], 1.0)
        self.assertEqual(stats['max'], 10.0)
        self.assertEqual(stats['median'], 5.0)
>       self.assertEqual(stats['q1'], 2.5)
E       AssertionError: 3.0 != 2.5

tests/test_utils.py:1215: AssertionError
______________________________ TestIntegrationE2E.test_complete_apu_processing_pipeline ______________________________

self = <tests.test_utils.TestIntegrationE2E testMethod=test_complete_apu_processing_pipeline>

    def test_complete_apu_processing_pipeline(self):
        """Prueba pipeline completo de procesamiento APU."""
        # Datos de entrada simulando un APU real
        raw_apu_data = {
            'CODIGO_APU': '  APU-2024.001  ',
            'DESCRIPCION_APU': 'Excavaci√≥n Manual en Tierra Com√∫n',
            'UNIDAD_APU': 'METROS CUBICOS',
            'CANTIDAD': '1.234,56',  # Formato EU
            'PRECIO': '$2,500.00',   # Con s√≠mbolo de moneda
            'RENDIMIENTO': '8 horas',
        }
    
        # 1. Limpiar c√≥digo APU
        clean_code = utils.clean_apu_code(raw_apu_data['CODIGO_APU'])
        self.assertEqual(clean_code, 'APU-2024.001')
    
        # 2. Normalizar descripci√≥n
        norm_desc = utils.normalize_text(raw_apu_data['DESCRIPCION_APU'])
        self.assertEqual(norm_desc, 'excavacion manual en tierra comun')
    
        # 3. Normalizar unidad
        norm_unit = utils.normalize_unit(raw_apu_data['UNIDAD_APU'])
>       self.assertEqual(norm_unit, 'M3')
E       AssertionError: 'METROS CUBICOS' != 'M3'
E       - METROS CUBICOS
E       + M3

tests/test_utils.py:1331: AssertionError
================================================== warnings summary ==================================================
tests/test_app.py: 17 warnings
  /home/gerardo/miniconda3/envs/ap_filter_env/lib/python3.10/site-packages/flask_session/redis/redis.py:51: RuntimeWarning: No valid Redis instance provided, attempting to create a new instance on localhost with default settings.
    warnings.warn(

tests/test_app.py: 17 warnings
tests/test_estimator.py: 6 warnings
  /home/gerardo/miniconda3/envs/ap_filter_env/lib/python3.10/site-packages/flask_session/base.py:172: DeprecationWarning: The 'use_signer' option is deprecated and will be removed in the next minor release. Please update your configuration accordingly or open an issue.
    warnings.warn(

tests/test_apu_processor.py::TestAPUProcessor::test_batch_processing
tests/test_apu_processor.py::TestAPUProcessor::test_build_optimized_dataframe
tests/test_apu_processor.py::TestAPUProcessor::test_process_all_basic
tests/test_apu_processor.py::TestIntegration::test_error_recovery
tests/test_apu_processor.py::TestIntegration::test_full_pipeline
tests/test_apu_processor.py::TestIntegration::test_large_dataset_performance
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:294: UserWarning: Inconsistencia: tipo_insumo='OTRO' pero categoria='MATERIALES'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_batch_processing
tests/test_apu_processor.py::TestAPUProcessor::test_build_optimized_dataframe
tests/test_apu_processor.py::TestAPUProcessor::test_process_all_basic
tests/test_apu_processor.py::TestIntegration::test_error_recovery
tests/test_apu_processor.py::TestIntegration::test_full_pipeline
tests/test_apu_processor.py::TestIntegration::test_large_dataset_performance
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:294: UserWarning: Inconsistencia: tipo_insumo='OTRO' pero categoria='MANO DE OBRA'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_batch_processing
tests/test_apu_processor.py::TestAPUProcessor::test_build_optimized_dataframe
tests/test_apu_processor.py::TestAPUProcessor::test_process_all_basic
tests/test_apu_processor.py::TestIntegration::test_error_recovery
tests/test_apu_processor.py::TestIntegration::test_full_pipeline
tests/test_apu_processor.py::TestIntegration::test_large_dataset_performance
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:294: UserWarning: Inconsistencia: tipo_insumo='OTRO' pero categoria='EQUIPO'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_batch_processing
tests/test_apu_processor.py::TestAPUProcessor::test_process_all_basic
tests/test_apu_processor.py::TestIntegration::test_error_recovery
tests/test_apu_processor.py::TestIntegration::test_full_pipeline
tests/test_apu_processor.py::TestIntegration::test_large_dataset_performance
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:294: UserWarning: Inconsistencia: tipo_insumo='OTRO' pero categoria='TRANSPORTE'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_fix_squad_units
tests/test_apu_processor.py::TestAPUProcessor::test_handle_duplicates
tests/test_apu_processor.py::TestAPUProcessor::test_validate_by_type
tests/test_apu_processor.py::TestAPUProcessor::test_validate_final_insumo
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:162: UserWarning: Inconsistencia: tipo_insumo='MANO_DE_OBRA' pero categoria='MO'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_fix_squad_units
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:91: UserWarning: Mano de Obra: unidades 'UNIDAD' o 'JOR' no son t√≠picas. Unidades esperadas: {'MES', 'DIA', 'SEMANA', 'HORA'}
    self._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_fix_squad_units
tests/test_apu_processor.py::TestAPUProcessor::test_handle_duplicates
tests/test_apu_processor.py::TestAPUProcessor::test_validate_by_type
tests/test_apu_processor.py::TestAPUProcessor::test_validate_final_insumo
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:91: UserWarning: Mano de Obra: unidades 'JOR' o 'JOR' no son t√≠picas. Unidades esperadas: {'MES', 'DIA', 'SEMANA', 'HORA'}
    self._validate_consistency()

tests/test_apu_processor.py::TestAPUProcessor::test_process_edge_cases
tests/test_apu_processor.py::TestIntegration::test_error_recovery
tests/test_apu_processor.py::TestRegression::test_scientific_notation
tests/test_apu_processor.py::TestRegression::test_very_long_descriptions
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:294: UserWarning: Inconsistencia: tipo_insumo='OTRO' pero categoria='TEST'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_apu_processor.py::TestRegression::test_unicode_handling
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:294: UserWarning: Inconsistencia: tipo_insumo='OTRO' pero categoria='SE√ëALIZACI√ìN'. Se recomienda alinear ambos campos.
    super()._validate_consistency()

tests/test_schemas.py::test_mano_de_obra_inconsistencia_rendimiento_cantidad
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:90: UserWarning: valor_total (300.0) no coincide con cantidad (5.0) * precio_unitario (150.0). Valor esperado: 750.0000. Considerar ajuste.
    self._validate_required_fields()

tests/test_schemas.py::test_mano_de_obra_unidad_no_tipica
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:91: UserWarning: Mano de Obra: unidades 'KG' o 'PERSONA' no son t√≠picas. Unidades esperadas: {'MES', 'DIA', 'SEMANA', 'HORA'}
    self._validate_consistency()

tests/test_schemas.py::test_insumo_procesado_con_categoria_diferente
  /home/gerardo/Documentos/GitHub/apu_filter/app/schemas.py:91: UserWarning: Inconsistencia: tipo_insumo='SUMINISTRO' pero categoria='OTRO'. Se recomienda alinear ambos campos.
    self._validate_consistency()

tests/test_utils.py::TestAdditionalFunctions::test_batch_process_dataframe_large
tests/test_utils.py::TestAdditionalFunctions::test_batch_process_dataframe_large
tests/test_utils.py::TestAdditionalFunctions::test_batch_process_dataframe_large
tests/test_utils.py::TestAdditionalFunctions::test_batch_process_dataframe_large
tests/test_utils.py::TestAdditionalFunctions::test_batch_process_dataframe_large
  /home/gerardo/Documentos/GitHub/apu_filter/tests/test_utils.py:1262: SettingWithCopyWarning: 
  A value is trying to be set on a copy of a slice from a DataFrame.
  Try using .loc[row_indexer,col_indexer] = value instead
  
  See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    batch_df['new_col'] = batch_df['cantidad'] * multiplier

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================================== short test summary info ===============================================
FAILED tests/test_app.py::TestAppEndpoints::test_concurrent_sessions - AssertionError: 500 != 200
FAILED tests/test_app.py::TestAppEndpoints::test_get_apu_detail_not_found - AssertionError: 500 != 200
FAILED tests/test_app.py::TestAppEndpoints::test_get_apu_detail_with_session - AssertionError: 500 != 200
FAILED tests/test_app.py::TestAppEndpoints::test_get_apu_detail_without_session - TypeError: the JSON object must be str, bytes or bytearray, not MagicMock
FAILED tests/test_app.py::TestAppEndpoints::test_get_estimate_invalid_content_type - TypeError: the JSON object must be str, bytes or bytearray, not MagicMock
FAILED tests/test_app.py::TestAppEndpoints::test_get_estimate_no_params - TypeError: the JSON object must be str, bytes or bytearray, not MagicMock
FAILED tests/test_app.py::TestAppEndpoints::test_get_estimate_with_session - AssertionError: 500 != 200
FAILED tests/test_app.py::TestAppEndpoints::test_get_estimate_without_session - TypeError: the JSON object must be str, bytes or bytearray, not MagicMock
FAILED tests/test_app.py::TestAppEndpoints::test_session_persistence_across_requests - AssertionError: 500 != 200
FAILED tests/test_app.py::TestAppEndpoints::test_upload_files_success - AssertionError: 500 != 200
FAILED tests/test_app.py::TestIntegration::test_complete_workflow - AssertionError: 500 != 200
FAILED tests/test_apu_processor.py::TestKeywordCache::test_all_keyword_categories - TypeError: KeywordCache.__init__() missing 1 required positional argument: 'config'
FAILED tests/test_apu_processor.py::TestKeywordCache::test_lazy_initialization - TypeError: KeywordCache.__init__() missing 1 required positional argument: 'config'
FAILED tests/test_apu_processor.py::TestKeywordCache::test_no_duplicate_keywords - TypeError: KeywordCache.__init__() missing 1 required positional argument: 'config'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_build_insumo_basico_variations - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_build_mo_completa_failure_cases - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_build_mo_completa_success - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_classify_insumo_with_cache - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_clean_token_variations - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_correct_total_value - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_detect_format_scenarios_0 - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_detect_format_scenarios_1 - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_detect_format_scenarios_2 - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_detect_format_scenarios_3 - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_parse_insumo_fields_with_waste - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_special_cases_classification - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUTransformer::test_validate_mo_format - TypeError: APUTransformer.__init__() missing 1 required positional argument: 'keyword_cache'
FAILED tests/test_apu_processor.py::TestAPUProcessor::test_batch_processing - AssertionError: 0 not greater than or equal to 50
FAILED tests/test_apu_processor.py::TestAPUProcessor::test_clean_record_fields - ValueError: C√≥digo APU no puede estar vac√≠o: ''
FAILED tests/test_apu_processor.py::TestAPUProcessor::test_infer_unit_intelligent - AssertionError: 'UND' != 'M2'
- UND
+ M2
FAILED tests/test_apu_processor.py::TestAPUProcessor::test_normalize_unit_cache - AssertionError: 'DAS' != 'DIA'
- DAS
?   -
+ DIA
?  +
FAILED tests/test_apu_processor.py::TestAPUProcessor::test_process_all_basic - AssertionError: 0 not greater than 0
FAILED tests/test_apu_processor.py::TestIntegration::test_error_recovery - AssertionError: 0 not greater than 0
FAILED tests/test_apu_processor.py::TestIntegration::test_full_pipeline - AssertionError: 0 not greater than 0
FAILED tests/test_apu_processor.py::TestIntegration::test_large_dataset_performance - AssertionError: 0 not greater than 500.0
FAILED tests/test_data_validator.py::TestDataValidator::test_validate_and_clean_data__none_in_apus_detail - AssertionError: None != [] : Debe convertir None a lista vac√≠a
FAILED tests/test_data_validator.py::TestDataValidator::test_validate_and_clean_data__none_in_presupuesto - AssertionError: None != [] : Debe convertir None a lista vac√≠a
FAILED tests/test_data_validator.py::TestDataValidator::test_validate_missing_descriptions__fuzzy_matching_enabled - AssertionError: 'Tornillo de acero 1/2 pulgadas' != 'Tornillo de acero 1/2"'
- Tornillo de acero 1/2 pulgadas
?                      ^^^^^^^^^
+ Tornillo de acero 1/2"
?                      ^
FAILED tests/test_data_validator.py::TestDataValidator::test_validate_missing_descriptions__no_fuzzy_available - AssertionError: 'fuzzywuzzy no instalado' not found in "Descripci√≥n faltante. Fuzzy matching no disponible. Instale 'fuzzywuzzy' para mejoras."
FAILED tests/test_data_validator.py::TestDataValidator::test_validate_zero_quantity_with_cost__invalid_types - AssertionError: 'alertas' not found in {'DESCRIPCION_INSUMO': 'Pintura', 'CANTIDAD': 'cero', 'VALOR_TOTAL': '100', 'VR_UNITARIO': '0'}
FAILED tests/test_estimator.py::test_calculate_estimate_delegates_correctly - assert 'error' not in {'error': "\u274c Columnas faltantes en APUs: {'tipo_apu', 'UNIDAD', 'EQUIPO', 'VALOR_SUMINISTRO_UN'}", 'log': "\U0001f575\ufe0f ESTIMADOR DETECTIVE INICIADO\n======================================================================\n\U0001f4da Datos cargados: 3 APUs disponibles\n\u274c Columnas faltantes en APUs: {'tipo_apu', 'UNIDAD', 'EQUIPO', 'VALOR_SUMINISTRO_UN'}"}
FAILED tests/test_models.py::TestProbabilityModels::test_sanitize_value_handles_non_numeric - ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
FAILED tests/test_models.py::TestProbabilityModels::test_simulation_with_min_cost_threshold - AssertionError: unexpectedly None
FAILED tests/test_procesador_csv.py::TestProcessAllFilesIntegration::test_process_all_files_empty_presupuesto - AssertionError: 'presupuesto' not found in 'error cr√≠tico en el pipeline: division by zero'
FAILED tests/test_schemas.py::test_normalize_unit - AssertionError: assert '' == 'UNIDAD'
  
  - UNIDAD
FAILED tests/test_schemas.py::test_normalize_description - AssertionError: assert 'CEMENTO CON TILDE: ACIDO' == 'CEMENTO CON TILDE: CIDO'
  
  - CEMENTO CON TILDE: CIDO
  + CEMENTO CON TILDE: ACIDO
  ?                    +
FAILED tests/test_schemas.py::test_insumo_procesado_creacion_correcta - AssertionError: assert 'CONSTRUCCION DE MURO DE CONCRETO' == 'CONSTRUCCI√ìN DE MURO DE CONCRETO'
  
  - CONSTRUCCI√ìN DE MURO DE CONCRETO
  ?           ^
  + CONSTRUCCION DE MURO DE CONCRETO
  ?           ^
FAILED tests/test_schemas.py::test_mano_de_obra_unidad_no_tipica - Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) matching the regex were emitted.
 Regex: unidades 'KG' o 'BOLSA' no son t√≠picas
 Emitted warnings: [ UserWarning("Mano de Obra: unidades 'KG' o 'PERSONA' no son t√≠picas. Unidades esperadas: {'MES', 'DIA', 'SEMANA', 'HORA'}")].
FAILED tests/test_schemas.py::test_transporte_unidad_no_tipica - Failed: DID NOT WARN. No warnings of type (<class 'UserWarning'>,) were emitted.
 Emitted warnings: [].
FAILED tests/test_schemas.py::test_validate_insumo_data_exitoso - AssertionError: assert 'm2' == 'M2'
  
  - M2
  + m2
FAILED tests/test_schemas.py::test_insumo_procesado_con_normalized_desc_manual - AssertionError: assert 'DESCRIPCION_MANUAL' == 'CEMENTO'
  
  - CEMENTO
  + DESCRIPCION_MANUAL
FAILED tests/test_schemas.py::test_insumo_procesado_con_categoria_diferente - AssertionError: assert 'OTRO' == 'SUMINISTRO'
  
  - SUMINISTRO
  + OTRO
FAILED tests/test_utils.py::TestTextNormalization::test_normalize_text_type_conversion - TypeError: unhashable type: 'list'
FAILED tests/test_utils.py::TestTextNormalization::test_safe_normalize_error_handling - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestNumericConversion::test_parse_number_currency_formats - AssertionError: 1.23456 != 1234.56 within 2 places (1233.3254399999998 difference)
FAILED tests/test_utils.py::TestNumericConversion::test_parse_number_decimal_separator_detection - AssertionError: 1.23456 != 1234.56 within 2 places (1233.3254399999998 difference)
FAILED tests/test_utils.py::TestNumericConversion::test_parse_number_edge_cases - AssertionError: 123456.78 != 12345678.0 within 2 places (12222221.22 difference)
FAILED tests/test_utils.py::TestNumericConversion::test_parse_number_special_values - AssertionError: inf != 0.0
FAILED tests/test_utils.py::TestAPUCode::test_clean_apu_code_validation_invalid - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestUnitNormalization::test_normalize_unit_invalid_returns_und - AssertionError: 'INVALID_UNIT_XYZ' != 'UND'
- INVALID_UNIT_XYZ
+ UND
FAILED tests/test_utils.py::TestUnitNormalization::test_normalize_unit_logging - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestUnitNormalization::test_normalize_unit_standard_units - AssertionError: 'L' != 'LT'
- L
+ LT
?  +
FAILED tests/test_utils.py::TestFileReading::test_safe_read_nonexistent_file - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestFileReading::test_safe_read_unsupported_format - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestAnalysisDetection::test_detect_outliers_modified_zscore - AssertionError: False is not true
FAILED tests/test_utils.py::TestDataFrameManipulation::test_find_and_rename_columns_conflict_warning - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestDataFrameManipulation::test_find_and_rename_unmapped_logging - ModuleNotFoundError: No module named 'utils'
FAILED tests/test_utils.py::TestSerialization::test_sanitize_numpy_types - AssertionError: inf is not None
FAILED tests/test_utils.py::TestAdditionalFunctions::test_calculate_statistics_all_nulls - AssertionError: 'null_percentage' not found in {'count': 0, 'mean': None, 'std': None, 'min': None, 'max': None, 'median': None}
FAILED tests/test_utils.py::TestAdditionalFunctions::test_calculate_statistics_complete - AssertionError: 3.0 != 2.5
FAILED tests/test_utils.py::TestIntegrationE2E::test_complete_apu_processing_pipeline - AssertionError: 'METROS CUBICOS' != 'M3'
- METROS CUBICOS
+ M3
========================= 71 failed, 287 passed, 2 xfailed, 85 warnings in 452.82s (0:07:32) =========================